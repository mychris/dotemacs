#+TITLE: Emacs configuration in org-mode
#+AUTHOR: Christoph GÃ¶ttschkes
#+EMAIL: just.mychris@googlemail.com
#+STARTUP: showeverything

* Configuration dependencies
To please the compiler, we need to require all the dependencies the settings have, which are not loaded using use-package, or are needed by use-package.
This is mostly use-package and local utilities which are used throught the configuration or are configured to be used interactively.
#+begin_src emacs-lisp
  ;;; settings.el --- personal configuration -*- coding: utf-8; lexical-binding: t; -*-
  ;;; Commentary:
  ;; Generated from `settings.org' in `init.el'.
  ;;; Code:
  (eval-when-compile
    (require 'use-package))
  (require 'cl-seq)
  (require 'delight)
  (require 'bind-key)
  (require 'my-utils)

  (eval-and-compile
    (require 'general)
    (general-create-definer emacs-map)
    (general-create-definer evil-imap :states 'insert)
    (general-create-definer evil-emap :states 'emacs)
    (general-create-definer evil-nmap :states 'normal)
    (general-create-definer evil-vmap :states 'visual)
    (general-create-definer evil-mmap :states 'motion)
    (general-create-definer evil-omap :states 'operator)
    (general-create-definer evil-rmap :states 'replace)
    (general-create-definer evil-iemap :states '(insert emacs))
    (general-create-definer evil-nvmap :states '(normal visual))
    (general-create-definer evil-nmmap :states '(normal motion)))

  ;; Leader keys to get rid of C- and M- prefix keys.
  (defvar buffer-local-leader-map
    (let ((map (make-sparse-keymap)))
      map)
    "Map for buffer local actions.")
  (general-create-definer buffer-local-leader
    :keymaps 'buffer-local-leader-map)

  (general-create-definer system-local-leader
    :states '(normal motion)
    :keymaps 'override
    :prefix "SPC s")
  (general-create-definer mode-action-leader
    :states '(normal motion)
    :prefix "SPC e")
  (general-create-definer inspect-leader
    :states '(normal motion)
    :prefix "SPC ,")
  ;; Try to replace as many C-x key bindings as possible
  (defvar c-x-leader-map
    (let ((map (make-sparse-keymap)))
      map)
    "C-x leader.")
  (general-create-definer c-x-leader
    :keymaps 'c-x-leader-map)

  (evil-nmmap
    "<backspace>" '(:keymap c-x-leader-map)
    "DEL" '(:keymap c-x-leader-map)
    "SPC" nil
    "SPC g" '(:keymap buffer-local-leader-map))

  (eval-and-compile
    (defvar user-emacs-cache-directory)) ;; from init.el
#+end_src
* Miscellaneous settings
** General Emacs configuration
#+begin_src emacs-lisp
  (setq
   blink-cursor-mode nil
   global-hl-line-mode t
   visible-bell t
   large-file-warning-threshold (* 100 1024 1024)
   read-process-output-max (* 1024 1024)
   initial-major-mode 'text-mode
   frame-title-format '("Emacs - %b"))
  (defalias 'yes-or-no-p 'y-or-n-p)
  (put 'narrow-to-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'overwrite-mode 'disabled t)
  (general-unbind
    "C-z" ;; Use C-z as a prefix key.
    "<help>"
    "C-h <help>"
    "<f1> <help>"
    "<find>"
    "<open>"
    "<clear>"
    "<f16>"
    "<f18>"
    "<f20>"
    "C-x C-z"
    "C-h g" ;; Who needs that?
    "<f1> g"
    "<f1> 4 i"
    "C-h 4 i"
    "M-`" ;; tmm-menubar
    "<f10>" ;; menu-bar-open
    "C-<f10>" ;; buffer-menu-open
    "C-x i" ;; insert-file
    "M-<"
    "M->")
  (emacs-map
    "<menu>" '(:keymap iso-transl-ctl-x-8-map))
  (emacs-map
    'iso-transl-ctl-x-8-map
    "<menu>" '(execute-extended-command :no-autoload t))

  ;; Use the c-x leader
  ;; For now, disable the old bindings to get used to it
  (with-eval-after-load 'evil
    (c-x-leader
      :no-autoload t
      "<escape> -" #'save-buffers-kill-terminal
      "<escape> <escape>" #'keyboard-quit
      "!" #'shell-command
      "8" #'async-shell-command
      "(" #'evil-record-macro
      "*" #'calc-dispatch
      "+" #'text-scale-adjust
      "-" #'text-scale-adjust
      "0" #'text-scale-adjust
      ":" #'eval-expression
      ";" #'eval-expression
      "b" #'switch-to-buffer
      "d" #'dired
      "f" #'find-file
      "h" '(:keymap help-map)
      "H" #'mark-whole-buffer
      "k" #'kill-buffer
      "p" '(:package projectile :keymap projectile-command-map)
      "s" #'save-buffer
      "S" #'save-some-buffers
      "u" #'undo-tree-visualize
      "w" #'write-buffer
      "x" #'execute-extended-command
      "X" #'exchange-point-and-mark
      "[" #'backward-page
      "]" #'forward-page
      "<left>" #'previous-buffer
      "<right>" #'next-buffer)
    (evil-emap
      :no-autoload t
      :keymaps 'global
      "M-:" #'eval-expression
      "C-x C-s" #'save-buffer
      "C-x s" #'save-some-buffers
      "C-x k" #'kill-buffer
      "C-x C-c" #'save-buffers-kill-terminal
      "C-x C-f" #'find-file
      "M-x" #'execute-extended-command
      "C-x b" #'switch-to-buffer
      "C-x d" #'dired
      "C-h" '(:keymap help-map)))

  (setq
   initial-buffer-choice nil
   inhibit-startup-message t
   inhibit-startup-echo-area-message t
   inhibit-startup-screen t
   inhibit-startup-buffer-menu t
   inhibit-x-resources t)
  ;; This is a weird one, see
  ;; https://emacshorrors.com/posts/advertising-your-freedom.html
  (fset 'display-startup-echo-area-message 'ignore)
#+end_src
** Libraries
#+begin_src emacs-lisp
  (use-package s :ensure t :defer t :demand nil)
  (use-package f :ensure t :defer t :demand nil)
  (use-package dash :ensure t :defer t :demand nil)
#+end_src
** compat - Emacs Lisp Compatibility Library
#+begin_src emacs-lisp
  (use-package compat
    :ensure t
    :demand nil)
#+end_src
** cua-base.el [built-in] - Emulate CUA key bindings
#+begin_src emacs-lisp
  (use-package cua-base
    :ensure nil
    :commands (cua-mode))
#+end_src
** nsm.el [built-in] - Network Security Manager
#+begin_src emacs-lisp
  (use-package nsm
    :ensure nil
    :demand t
    :custom
    (nsm-settings-file (expand-file-name "network-security.data" user-emacs-cache-directory))
    (network-security-level 'high))
#+end_src
** Emacs server and desktop
#+begin_src emacs-lisp
  (use-package server
    :ensure nil
    :commands (server-start))

  (use-package desktop
    :ensure nil
    :custom
    (desktop-auto-save-timeout 300)
    (desktop-path (list (file-name-as-directory user-emacs-cache-directory)))
    (desktop-base-file-name "desktop")
    (desktop-files-not-to-save nil)
    (desktop-globals-to-clear nil)
    (desktop-load-locked-desktop t)
    (desktop-missing-file-warning nil)
    (desktop-restore-eager 0)
    (desktop-restore-frames nil)
    (desktop-save 'ask-if-new)
    :hook
    (after-init-hook . (lambda () (desktop-save-mode -1))))
#+end_src
** Make sure that UTF-8 is used everywhere.
#+begin_src emacs-lisp
  (use-package mule
    :ensure nil
    :demand t
    :init
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (set-language-environment 'utf-8)
    (set-selection-coding-system 'utf-8)
    (prefer-coding-system 'utf-8)
    (set-input-method nil)
    (setq locale-coding-system 'utf-8)
    (add-to-list 'process-coding-system-alist '("python" . (utf-8 . utf-8)))
    (add-to-list 'process-coding-system-alist '("elpy" . (utf-8 . utf-8))))
#+end_src
** Savehist (minibuffer history)
#+begin_src emacs-lisp
  (use-package savehist
    :ensure nil
    :delight (savehist-mode)
    :custom
    (savehist-file (expand-file-name "savehist" user-emacs-cache-directory))
    (history-length 1000)
    (history-delete-duplicates t)
    (savehist-save-minibuffer-history t)
    :hook
    (after-init-hook . savehist-mode))
#+end_src
** Saveplace (cursor position)
#+begin_src emacs-lisp
  (use-package saveplace
    :ensure nil
    :delight (save-place-mode)
    :custom
    (save-place-file (expand-file-name "saveplace" user-emacs-cache-directory))
    (save-place-limit 2048)
    (save-place-forget-unreadable-files t)
    :hook
    (after-init-hook . save-place-mode))
#+end_src
** Backups and auto-save
#+begin_src emacs-lisp
  (use-package files
    :ensure nil
    :demand t
    :init
    ;; backups
    (let
        ((backup-dir (file-name-as-directory (expand-file-name "backups" user-emacs-cache-directory))))
      (unless (file-exists-p backup-dir) (make-directory backup-dir t))
      (setq-default backup-directory-alist `(("." . ,backup-dir)))
      (setq-default backup-by-copying t)
      (setq-default delete-old-versions t)
      (setq-default kept-new-versions 5)
      (setq-default kept-old-versions 2)
      (setq-default create-lockfiles nil))
    ;; auto-save
    (let
        ((auto-save-dir (file-name-as-directory (expand-file-name "auto-save" user-emacs-cache-directory)))
         (auto-save-list-dir (file-name-as-directory (expand-file-name "auto-save-list" user-emacs-cache-directory))))
      (unless (file-exists-p auto-save-dir) (make-directory auto-save-dir t))
      (unless (file-exists-p auto-save-list-dir) (make-directory auto-save-list-dir t))
      (setq-default auto-save-file-name-transforms `((".*" ,auto-save-dir t)))
      (setq-default auto-save-list-file-prefix (expand-file-name "saves-" auto-save-list-dir))
      (setq-default auto-save-default t)
      (setq-default auto-save-timeout 10)
      (setq-default auto-save-interval 200)))
#+end_src
** Completion for recent files and directories
#+begin_src emacs-lisp
  (use-package recentf
    :ensure nil
    :delight (recentf-mode)
    :commands (recentf-mode
               recentf-cleanup)
    :custom
    (recentf-save-file (expand-file-name "recentf" user-emacs-cache-directory))
    (recentf-save-file-modes #o600)
    (recentf-max-saved-items 512)
    (recentf-exclude '(;; compressed files and archives
                       "\\.tar$" "\\.tbz2$" "\\.tbz$" "\\.tgz$"
                       "\\.bz2$" "\\.bz$" "\\.gz$" "\\.gzip$" "\\.xz$" "\\.zpaq$"
                       "\\.lz$" "\\.lrz$" "\\.lzo$" "\\.lzma$" "\\.shar$" "\\.kgb$"
                       "\\.zip$" "\\.Z$" "\\.7z$" "\\.rar$"
                       ;; TRAMP paths
                       "^/sudo:" "^/ssh:"))
    (recentf-auto-cleanup 60)
    :config
    (advice-add #'recentf-cleanup :after #'(lambda (&rest _ignored)
                                             ;; Don't show the message in the bottom of the screen
                                             (message nil)))
    :hook
    (recentf-mode-hook . (lambda ()
                           ;; run a cleanup at startup and use `recentf-auto-cleanup'
                           ;; to cleanup every now and then
                           (run-with-idle-timer 5 nil (lambda ()
                                                        (recentf-cleanup)))))
    (after-init-hook . recentf-mode))
#+end_src
** Line numbers
#+begin_src emacs-lisp
  (use-package display-line-numbers
    :ensure nil
    :delight (display-line-numbers-mode)
    :commands (display-line-numbers-mode
               global-display-line-numbers-mode)
    :custom
    (display-line-numbers-type 'relative)
    (display-line-numbers-width-start t)
    (display-line-numbers-grow-only t)
    :init
    (set-face-attribute 'line-number-current-line nil :weight 'bold)
    (defun +display-line-numbers-disable ()
      (when (fboundp #'display-line-numbers-mode)
        (display-line-numbers-mode 0)))
    :hook
    ((emacs-startup-hook . global-display-line-numbers-mode)
     (prog-mode-hook . (lambda () (setq display-line-numbers-type 'visual)))
     (notmuch-hello-mode-hook . +display-line-numbers-disable)
     (notmuch-show-mode-hook . +display-line-numbers-disable)
     (notmuch-search-mode-hook . +display-line-numbers-disable)
     (message-mode-hook . +display-line-numbers-disable)
     (calc-mode-hook . +display-line-numbers-disable)
     (imenu-list-major-mode-hook . +display-line-numbers-disable)
     (treemacs-mode-hook . +display-line-numbers-disable)
     (shell-mode-hook . +display-line-numbers-disable)
     (term-mode-hook . +display-line-numbers-disable)))
#+end_src
** Fill column indicator
#+begin_src emacs-lisp
  (use-package display-fill-column-indicator
    :ensure nil
    :delight (display-fill-column-indicator-mode)
    :commands (display-fill-column-indicator-mode)
    :hook
    ((
      c-mode-common-hook c-mode-hook c++-mode-hook
      c-ts-mode-hook c++-ts-mode-hook
      emacs-lisp-mode-hook
      lisp-mode-hook lisp-data-mode-hook
      sh-mode-hook
      python-mode-hook
      makefile-mode-hook
      git-commit-setup-hook
      message-mode-hook
      )
     . display-fill-column-indicator-mode))
#+end_src
** package [built-in] - Simple package system for Emacs
#+begin_src emacs-lisp
  (use-package package
    :ensure nil
    :demand t
    :custom
    (package-enable-at-startup nil) ;; Also configured in early-init.el
    (package-quickstart nil) ;; Also configured in early-init.el
    :general
    (emacs-map
      'package-menu-mode-map
      "q" '(kill-buffer-and-window :no-autoload t)))
#+end_src
** pcache - persistent caching for Emacs
#+begin_src emacs-lisp
  (use-package pcache
    :ensure (pcache :pin melpa)
    :config
    (setq pcache-directory
          (let ((dir (expand-file-name "pcache" user-emacs-cache-directory)))
            (make-directory dir t)
            dir)))
#+end_src
** utils - Personal utilities
#+begin_src emacs-lisp
  (use-package my-utils
    :ensure nil
    :demand t
    :commands (+delete-most-recent-window)
    :general
    (emacs-map
      "C-x 9" #'+delete-most-recent-window)
    (evil-nmmap
      "SPC q" #'+delete-most-recent-window
      "Z O" #'+delete-most-recent-window))
#+end_src
** GC settings
#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :hook
    (after-init-hook . (lambda ()
                         (custom-set-variables
                          '(gc-cons-threshold (* 4 1024 1024))
                          '(gc-cons-percentage 0.2)))))
#+end_src
* Evil
** evil - Extensible Vi layer for Emacs.
#+begin_src emacs-lisp
  ;; `evil-collection' assumes that
  ;;   `evil-want-keybinding' is set to `t'
  ;;   `evil-want-integration' is set to `nil'
  ;; before loading `evil' and `evil-collection'
  ;; See https://github.com/emacs-evil/evil-collection#installation
  ;; With byte-code compilation turned on, it doesn't work if it is
  ;; specified in the :init or :preface section
  (eval-and-compile
    (setq evil-want-keybinding nil)
    (setq evil-want-integration t))
  (use-package evil
    :ensure (evil :pin melpa)
    :custom
    (evil-echo-state nil)
    (evil-want-C-u-scroll t)
    (evil-want-C-i-jump nil)
    (evil-undo-system #'undo-tree)
    (evil-want-minibuffer t)
    (evil-want-abbrev-expand-on-insert-exit nil)
    :config
    (defun +evil-set-cursor (orig-fun &rest args)
      (if (display-graphic-p)
          (apply orig-fun args)
        (let ((specs (car args)))
          (unless (equal cursor-type specs)
            (let ((shape (or (car-safe specs) specs))
                  (param))
              (setq param
                    (cond ((eq shape 'bar) "6")
                          ((eq shape 'hbar) "3")
                          (t "2")))
              (send-string-to-terminal
               (concat "\e[" param " q")))))))
    ;;(advice-add #'evil-set-cursor :around #'+evil-set-cursor)
    (evil-select-search-module 'evil-search-module 'isearch)
    (dolist (m '(help-mode Info-mode))
      (evil-set-initial-state m 'motion))
    :hook
    (emacs-startup-hook . evil-mode))

  ;; Use an additional use-package declaration.
  ;; I think general has some problems with the keybindings.
  ;; They are not always picked up.
  (use-package evil
    :after (:all evil)
    :general
    (emacs-map
      "C-w" nil)
    (evil-mmap
      "V" #'evil-visual-block
      "C-v" #'evil-visual-line
      "z Z" #'evil-window-middle
      "z T" #'evil-window-top
      "z B" #'evil-window-bottom)
   (evil-nmmap
      :keymaps 'override
      "SPC w" '(:keymap evil-window-map)
      "C-w" nil)
    (evil-emap
      :keymaps '(gdb-breakpoints-mode-map
                 gdb-registers-mode-map
                 gdb-locals-mode-map
                 gdb-frames-mode-map)
      "SPC w" '(:keymap evil-window-map))
    (evil-imap
      'eshell-mode-map
      "<left>" #'evil-backward-char
      "<right>" #'evil-forward-char
      "C-<left>" #'evil-backward-word-begin
      "C-<right>" #'evil-forward-word-begin))

  (use-package +evil
    :ensure nil
    :after (:all evil)
    :demand t
    :config
    (+evil-setup)
    :general
    (evil-nmap
      "g ;" #'+evil-goto-last-change-center
      "g ," #'+evil-goto-last-change-reverse-center)
    (emacs-map
      'evil-window-map
      "m" '(+switch-to-minibuffer-window :no-autoload t))
    (evil-mmap
      "`" #'+evil-goto-mark-center
      "'" #'+evil-goto-mark-line-center))
#+end_src
** evil-org - evil keybindings for org-mode
#+begin_src emacs-lisp
  (use-package evil-org
    :ensure (evil-org :pin melpa)
    :after (:all evil org)
    :delight (evil-org-mode)
    :hook
    (org-mode-hook . evil-org-mode))
#+end_src
** evil-collection - A set of keybindings for Evil mode
#+begin_src emacs-lisp
  (use-package evil-collection
    :ensure (evil-collection :pin melpa)
    :after (:all evil)
    :commands (evil-collection-init)
    :demand t
    :custom
    (evil-collection-setup-minibuffer t)
    :config
    ;; delight this mode in :delight doesn't work because the file is not in the load path
    (delight 'evil-collection-unimpaired-mode nil "evil-collection-unimpaired")
    (dolist (m '(help info man image evil-mc magit magit-section magit-todos))
      (cl-delete-if #'(lambda (e)
                        (or (equal e m)
                            (and (listp e)
                                 (equal (car e) m))))
                    evil-collection-mode-list))
    (evil-collection-init)
    (evil-collection-init '((image image-mode) magit (magit-section magit) (magit-todos magit))))
    ;;    (cl-delete-if #'(lambda (e) (and (listp e) (eq (car e) 'magit))) evil-collection-mode-list)
    ;;    (with-eval-after-load 'magit
    ;;      (evil-collection-init '((magit magit-repos magit-submodule) magit-section magit-todos)))
#+end_src
** evil-escape - Customizable key sequence to escape from insert state and everything else in Emacs.
#+begin_src emacs-lisp
  (use-package evil-escape
    :ensure t
    :after (:all evil)
    :delight (evil-escape-mode)
    :custom
    (evil-escape-key-sequence "jk")
    (evil-escape-delay 0.1)
    (evil-escape-unodered-key-sequence nil)
    :hook
    (evil-mode-hook . evil-escape-mode)
    (minibuffer-mode-hook . (lambda () (evil-escape-mode 0))))
#+end_src
** evil-surround - emulate surround.vim from Vim
#+begin_src emacs-lisp
  (use-package evil-surround
    :ensure (evil-surround :pin melpa)
    :after (:all evil)
    :commands (evil-surround-mode
               global-evil-surround-mode)
    :hook
    (evil-mode-hook . global-evil-surround-mode))
#+end_src
** evil-easymotion
#+begin_src emacs-lisp
  (use-package evil-easymotion
    :ensure t
    :after (:all evil)
    :demand t
    :functions (evilem-default-keybindings)
    :hook
    (evil-mode-hook . (lambda ()
                        (when (and (bound-and-true-p evil-mode)
                                   (fboundp 'evilem-default-keybindings))
                          (evilem-default-keybindings "C-a")))))
#+end_src
** evil-mc - Multiple cursors implementation for evil-mode
#+begin_src emacs-lisp
  (use-package evil-mc
    :ensure (evil-mc :pin melpa)
    :after (:all evil)
    :delight (evil-mc-mode)
    :commands (evil-mc-mode
               global-evil-mc-mode)
    :init
    ;; (setq-default evil-mc-one-cursor-show-mode-line-text nil)
    :general
    (emacs-map
      :keymaps 'evil-mc-key-map
      :states '(normal visual motion)
      "g ." '(:keymap evil-mc-cursors-map))
    (emacs-map
      :keymaps 'evil-mc-key-map
      :states '(normal visual motion)
      "g r" nil)
    (emacs-map
      :keymaps 'evil-mc-cursors-map
      :states '(normal visual)
      :no-autoload t
      "j" #'evil-mc-make-cursor-move-next-line
      "k" #'evil-mc-make-cursor-move-prev-line
      "q" #'evil-mc-undo-all-cursors)
    :hook
    (evil-mode-hook . global-evil-mc-mode))
#+end_src
* Interface enhancements
** Minibuffer [built-in]
#+begin_src emacs-lisp
  (use-package minibuffer
    :ensure nil
    :custom
    (minibuffer-default-prompt-format " [...]")
    :config
    (defun +switch-to-minibuffer-window ()
      "Switch to minibuffer window (if active)."
      (interactive)
      (when (active-minibuffer-window)
        (select-frame-set-input-focus (window-frame (active-minibuffer-window)))
        (select-window (active-minibuffer-window))))

    (defun +kill-other-buffers ()
      "Kill all other buffers."
      (interactive)
      (mapc #'+kill-buffer-save (delq (current-buffer) (buffer-list))))

    ;; https://www.emacswiki.org/emacs/KillingBuffers#toc9
    (defvar kill-buffer-save-list '("*scratch*" "*Messages*")
      "A list holding buffer names which should not be killed by `kill-buffer-save'.")
    (defun +kill-buffer-save (&optional buffer-or-name)
      "Only kill buffers not in the kill-buffer-save-list."
      (interactive)
      (or buffer-or-name (setq buffer-or-name (current-buffer)))
      (if (member
           (if (bufferp buffer-or-name) (buffer-name buffer-or-name) buffer-or-name)
           kill-buffer-save-list)
          (bury-buffer buffer-or-name)
        (kill-buffer buffer-or-name)))
    (defun +focus-minibuffer-or-completion ()
      "Focus the active minibuffer or completion window.
  TODO: needs refactoring."
      (interactive)
      (let* ((mini (active-minibuffer-window))
             (completions (get-window-with-predicate
                           (lambda (window)
                             (org-string-match-p
                              "\\*\\(Completions\\|Embark Collect \\(Live\\|Completions\\)\\)"
                              (format "%s" window))))))
        (cond ((and mini (not (minibufferp)))
               (select-window mini nil))
              ((and completions (not (eq (selected-window) completions)))
               (select-window completions nil)))))
    (setq completion-styles '(basic orderless))
    (setq completion-category-defaults nil)
    (setq completion-cycle-threshold 5)
    (setq completion-ignore-case t)
    (setq completion-category-defaults nil)
    (setq completion-auto-help nil)
    (setq read-file-name-completion-ignore-case t)
    (setq read-buffer-completion-ignore-case t)
    (setq completion-ignore-case t)
    (setq enable-recursive-minibuffers t)
    :general
    (emacs-map
      :no-autoload t
      "H-f" #'+focus-minibuffer-or-completion
      [remap kill-buffer] #'+kill-buffer-save
      "C-x K" #'+kill-other-buffer
      "C-x C-o" #'+switch-to-minibuffer-window)
    (emacs-map
      'minibuffer-local-map
      :no-autoload t
      "<left>" #'left-char
      "C-<left>" #'left-word
      "<right>" #'right-char
      "C-<right>" #'right-word
      "C-<kp-7>" #'minibuffer-keyboard-quit)
    (emacs-map
      'minibuffer-local-completion-map
      "RET" #'minibuffer-force-complete-and-exit
      "<tab>" #'minibuffer-complete
      "<backtab>" #'minibuffer-force-complete
      "M-RET" #'exit-minibuffer)
    (emacs-map
      'minibuffer-local-filename-completion-map
      "RET" #'minibuffer-force-complete-and-exit)
    (emacs-map
      'minibuffer-inactive-mode-map
      "<mouse-1>" nil))

  (use-package minibuf-eldef
    :ensure nil
    :hook
    (after-init-hook . minibuffer-electric-default-mode))

  (use-package mb-depth
    :ensure nil
    :custom
    (minibuffer-depth-indicator-function (lambda (depth) (format "[%2d] " depth)))
    :hook
    (after-init-hook . minibuffer-depth-indicate-mode))
#+end_src
** autorevert [built-in]
#+begin_src emacs-lisp
  (use-package autorevert
    :ensure nil
    :delight (auto-revert-mode)
    :commands (auto-revert-mode
               global-auto-revert-mode)
    :custom
    (auto-revert-verbose t)
    :hook
    (find-file-hook . auto-revert-mode))
#+end_src
** imenu [built-in] - find major definitions in a file by name
#+begin_src emacs-lisp
  (use-package imenu
    :ensure nil
    :commands (imenu)
    :hook
    (imenu-after-jump-hook . (lambda () (recenter-top-bottom))))

  (use-package imenu-list
    :ensure (imenu-list :pin melpa)
    :after (:all imenu)
    :defer t
    :commands (imenu-list
               imenu-list-minor-mode
               imenu-list-show
               imenu-list-quit-window)
    :functions (imenu-list-ret-dwim
                imenu-list-resize-window
                imenu-list-update)
    :custom
    (imenu-list-idle-update-delay 0.5)
    (imenu-list-position 'right)
    (imenu-list-buffer-name "*Ilist*")
    :general
    (emacs-map
      :no-autoload t
      "<f7>" #'imenu-list-smart-toggle)
    (emacs-map
      'imenu-list-major-mode-map
      "RET" #'imenu-list-display-dwim
      "<return>" #'imenu-list-display-dwim
      "TAB" '(hs-toggle-hiding :no-autoload t)
      "<tab>" '(hs-toggle-hiding :no-autoload t)))
#+end_src
** vertico - VERTical Interactive COmpletion
#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :delight (vertico-mode)
    :commands (vertico-mode)
    :custom
    (vertico-scroll-margin 0)
    (vertico-count 10)
    (vertico-resize nil)
    (vertico-cycle t)
    :general
    (emacs-map
      'vertico-map
      "<right>" '(forward-char :no-autoload t)
      "<left>" '(backward-char :no-autoload t)
      "<up>" #'vertico-previous
      "<down>" #'vertico-next
      "C-<up>" '(previous-history-element :no-autoload t)
      "C-<down>" '(next-history-element :no-autoload t)
      "C-<return>" #'vertico-exit-input
      "<backspace>" #'delete-backward-char
      "C-<backspace>" #'vertico-directory-delete-word
      "C-f" '(forward-char :no-autoload t)
      "C-b" '(backward-char :no-autoload t)
      "C-p" #'vertico-previous
      "C-k" #'vertico-previous
      "C-n" #'vertico-next
      "C-j" #'vertico-next
      "<prior>" #'vertico-scroll-up
      "C-u" #'vertico-scroll-up
      "<next>" #'vertico-scroll-down
      "C-d" #'vertico-scroll-down)
    (evil-imap
      'vertico-map
      "C-p" #'vertico-previous
      "C-k" #'vertico-previous
      "C-n" #'vertico-next
      "C-j" #'vertico-next)
    (evil-nmap
      'vertico-map
      "<up>" #'vertico-previous
      "<down>" #'vertico-next
      "<escape>" #'abort-recursive-edit
      "DEL" '(:keymap c-x-leader-map)
      "<backspace>" '(:keymap c-x-leader-map)
      "k" #'vertico-previous
      "j" #'vertico-next
      "C-p" #'vertico-previous
      "C-n" #'vertico-next
      "{" #'vertico-scroll-down
      "}" #'vertico-scroll-up
      "C-u" #'vertico-scroll-down
      "C-d" #'vertico-scroll-up
      "g g" #'vertico-first
      "G" #'vertico-last)
    :hook
    (emacs-startup-hook . vertico-mode)
    (minibuffer-setup-hook . (lambda ()
                               (setq-local evil-move-beyond-eol t)
                               (setq-local evil-move-cursor-back nil))))

  (use-package vertico-quick
    :ensure nil
    :after (:all vertico)
    :custom
    (vertico-quick1 "aoeuid")
    (vertico-quick2 "htns")
    :commands (vertico-quick-insert
               vertico-quick-exit
               vertico-quick-jump)
    :general
    (emacs-map
      'vertico-map
      "M-f" #'vertico-quick-insert
      "M-," #'vertico-quick-insert
      "M-." #'vertico-quick-exit)
    (evil-nmap
      'vertico-map
      "f" #'vertico-quick-insert
      "F" #'vertico-quick-exit))

  (use-package vertico-directory
    :ensure nil ;; part of vertico
    :after (:all vertico)
    :commands (vertico-directory-tidy)
    :general
    (emacs-map
      'vertico-map
      "<return>" #'vertico-directory-enter
      "<backspace>" #'vertico-directory-delete-char
      "M-<backspace>" #'vertico-directory-delete-word)
    :hook
    (rfn-eshadow-update-overlay . vertico-directory-tidy))

  (use-package vertico-multiform
    :ensure nil ;; part of vertico
    :after (:all vertico)
    :delight (vertico-multiform-mode)
    :commands (vertico-multiform-mode)
    :custom
    (vertico-multiform-commands '((consult-line buffer)
                                  (consult-imenu reverse buffer)))
    (vertico-multiform-categories '((imenu (:not indexed mouse))
                                    (symbol (vertico-sort-function . vertico-sort-alpha))))
    :hook
    (vertico-mode-hook . vertico-multiform-mode))
#+end_src
** Consult - Consulting completing-read
#+begin_src emacs-lisp
  (use-package consult
    :ensure (consult :pin melpa)
    :functions (consult-completion-in-region
                consult-register-format)
    :commands (consult-goto-line
               consult-line
               consult-isearch-history
               consult-mark
               consult-yank-from-kill-ring
               consult-ripgrep
               consult-grep
               consult-find
               consult-man
               consult-buffer
               consult-narrow-help
               consult-bookmark
               consult-completion-in-region
               consult-register-format)
    :init
    (setq completion-in-region-function
          #'(lambda (&rest args)
              (apply (if vertico-mode
                         #'consult-completion-in-region
                       #'completion--in-region)
                     args))
          register-preview-function #'consult-register-format)
    :custom
    (consult-line-numbers-widen t)
    (consult-async-min-input 3)
    (consult-async-input-debounce 0.5)
    (consult-async-input-throttle 0.8)
    (consult-narrow-key ">")
    (consult-ripgrep-args
     "rg --null --line-buffered --color=never --max-columns=1000 \
      --path-separator / --no-ignore-vcs --smart-case --no-heading \
      --with-filename --line-number --search-zip")
    :general
    (buffer-local-leader
      ":" #'consult-goto-line
      ";" #'consult-goto-line
      "l" #'consult-line
      "s" #'consult-isearch-history
      "m" #'consult-mark)
    (system-local-leader
      "y" #'consult-yank-from-kill-ring
      "g" #'consult-ripgrep
      "G" #'consult-grep
      "f" #'consult-find
      "m" #'consult-man)
    (c-x-leader
      "X" #'consult-mode-command
      "m" #'consult-minor-mode-menu)
    (emacs-map
      [remap switch-to-buffer] #'consult-buffer)
    (emacs-map
      'consult-narrow-map
      "?" #'consult-narrow-help)
    (evil-nmap
      [remap bookmark-jump] #'consult-bookmark
      "g l" #'consult-goto-line)
    :hook
    (embark-collect-mode-hook . consult-preview-at-point-mode))

  (use-package consult-imenu
    :ensure nil ;; part of consult
    :general
    (buffer-local-leader
      "i" #'consult-imenu-multi))

  (use-package consult-register
    :ensure nil ;; part of consult
    :general
    (emacs-map
      [remap jump-to-register] #'consult-register-load
      [remap point-to-register] #'consult-register-store))

  (use-package consult-lsp
    :ensure t
    :after (:all lsp consult)
    :general
    (inspect-leader
      'lsp-mode-map
      "S" #'consult-lsp-symbols
      "s" #'consult-lsp-file-symbols))

  (use-package +consult
    :ensure nil
    :commands (+consult-major-mode-menu
               +consult-tab)
    :general
    (c-x-leader
      "M" #'+consult-major-mode-menu))
#+end_src
** Marginalia - Enrich existing commands with completion annotations
#+begin_src emacs-lisp
  (use-package marginalia
    :ensure t
    :commands (marginalia-mode)
    :custom
    (marginalia-max-relative-age 0)
    :config
    ;; something changed in marginalia
    ;; TODO: refactor
    ;;(setq-default marginalia-annotators
    ;;              '(marginalia-annotators-heavy
    ;;                marginalia-annotators-light))
    :hook
    (emacs-startup-hook . marginalia-mode))
#+end_src
** Embark - Conveniently act on minibuffer completions
#+begin_src emacs-lisp
  (use-package embark
    :ensure t
    :custom
    (embark-quit-after-action t)
    (embark-mixed-indicator-delay 0)
    (embark-verbose-indicator-display-action '(display-buffer-at-bottom (window-height . fit-window-to-buffer)))
    :config
    ;; Show Embark actions via which-key
    ;; The following implementation is no longer supported.
    ;; See https://github.com/oantolin/embark/wiki/Additional-Configuration#use-which-key-like-a-key-menu-prompt
    ;; (setq embark-action-indicator
    ;;       (lambda (map)
    ;;        (which-key--show-keymap "Embark" map nil nil 'no-paging)
    ;;        #'which-key--hide-popup-ignore-command)
    ;;      embark-become-indicator embark-action-indicator)
    (defun +embark-collect-toggle-mark ()
      "Toggle the mark of the candidate at point in an Embark collect buffer."
      (interactive)
      (embark-collect-mark (embark-collect--marked-p)))
    :general
    (emacs-map
      "M-g a" #'embark-act
      "M-g M-a" #'embark-act)
    (emacs-map
      'embark-collect-mode-map
      "SPC" '(+embark-collect-toggle-mark :no-autoload t))
    (emacs-map
      'minibuffer-local-map
      "M-a" #'embark-act
      "M-b" #'embark-become
      "M-e" #'embark-export))

  (use-package embark-consult
    :ensure t
    :after (:all embark consult)
    :demand t)

  (use-package zed-embark
    :ensure nil
    :after (:all embark consult)
    :general
    (emacs-map
      'minibuffer-local-completion-map
      "C-n" #'zed-embark-switch-to-completion-buffer-top))
#+end_src
** Orderless - Use space-separated search terms in any order when completing with Icomplete or the default interface
#+begin_src emacs-lisp
  (use-package orderless
    :ensure t
    ;; If it is lazy loaded, a message is show in the minibuffer the
    ;; first time it is used
    :demand t
    :custom
    (completion-styles '(basic orderless))
    (completion-category-defaults nil)
    (completion-category-overrides
     '((file (styles . (basic partial-completion orderless)))
       (project-file (styles . (basic substring partial-completion orderless)))
       (imenu (styles . (basic substring orderless)))
       (kill-ring (styles . (basic substring orderless)))
       (consult-location (styles . (basic substring orderless)))))
    :config
    (defun +orderless-literal-style-dispatcher (pattern _index _total)
      "Style dispatcher which recognizes patterns which have an \"=\" as suffix and
  dispatches those to the orderless-literal style."
      (when (string-suffix-p "=" pattern)
        `(orderless-literal . ,(substring pattern 0 -1))))
    (defun +orderless-initialism-style-dispatcher (pattern _index _total)
      "Style dispatchter which recognizes patterns which have an \";\" as suffix and
  dispatches those to the orderless-initialism style."
      (when (string-suffix-p ";" pattern)
        `(orderless-initialism . ,(substring pattern 0 -1))))
    (defun +orderless-flex-style-dispatcher (pattern _index _total)
      "Style dispatcher which recognizes patterns which have an \",\" as suffix and
  dispatches those to the orderless-flex style."
      (when (string-suffix-p "," pattern)
        `(orderless-flex . ,(substring pattern 0 -1))))
    (setq orderless-component-separator " +")
    (setq orderless-matching-styles
          '(orderless-prefixes
            orderless-initialism
            orderless-regexp
            orderless-flex))
    (setq orderless-style-dispatchers
          '(+orderless-literal-style-dispatcher
            +orderless-initialism-style-dispatcher
            +orderless-flex-style-dispatcher))
    :general
    (emacs-map
      'minibuffer-local-completion-map
      "SPC" nil
      "?" nil))
#+end_src
** perspective - switch between named "perspectives" of the editor
#+begin_src emacs-lisp
  (use-package perspective
    :disabled t
    :ensure t
    :commands (persp-mode
               persp-switch
               persp-kill
               persp-current-name)
    :custom
    (persp-show-modestring t)
    (persp-modestring-short t)
    (persp-initial-frame-name "001")
    (persp-suppress-no-prefix-key-warning t)
    :config
    (defun persp-switch-to-frame-1 ()
      (interactive)
      (persp-switch "001"))
    (defun persp-switch-to-frame-2 ()
      (interactive)
      (persp-switch "010"))
    (defun persp-switch-to-frame-3 ()
      (interactive)
      (persp-switch "011"))
    (defun persp-switch-to-frame-4 ()
      (interactive)
      (persp-switch "100"))
    (defun persp-switch-to-frame-5 ()
      (interactive)
      (persp-switch "101"))
    (defun persp-switch-to-frame-6 ()
      (interactive)
      (persp-switch "110"))
    (defun persp-switch-to-frame-7 ()
      (interactive)
      (persp-switch "111"))
    (defun persp-kill-current-frame ()
      (interactive)
      (persp-kill (persp-current-name)))
    :general
    (emacs-map
      "M-1" '(persp-switch-to-frame-1 :no-autoload t)
      "M-2" '(persp-switch-to-frame-2 :no-autoload t)
      "M-3" '(persp-switch-to-frame-3 :no-autoload t)
      "M-4" '(persp-switch-to-frame-4 :no-autoload t)
      "M-5" '(persp-switch-to-frame-5 :no-autoload t)
      "M-6" '(persp-switch-to-frame-6 :no-autoload t)
      "M-7" '(persp-switch-to-frame-7 :no-autoload t)
      "M-0" '(persp-kill-current-frame :no-autoload t))
    :hook
    (emacs-startup-hook . persp-mode))
#+end_src
** tab-bar.el [built-in] - frame-local tabs with named persistent window configurations
#+begin_src emacs-lisp
  (use-package tab-bar
    :ensure nil
    :commands (tab-new)
    :general
    (emacs-map
      "C-x t" '(:keymap tab-prefix-map))
    (evil-emap
      "C-x t" '(:keymap tab-prefix-map))
    (evil-nmmap
      :keymaps 'override
      "SPC t" '(:keymap tab-prefix-map))
    (emacs-map
      'tab-prefix-map
      "<escape>" '(keyboard-quit :no-autoload t)
      "n" #'tab-new
      "c" #'tab-close
      "l" #'tab-next
      "h" #'tab-previous
      "t" #'tab-recent
      "T" #'other-tab-prefix
      "s" '(+consult-tab :no-autoload t)
      "o" #'tab-close-other
      "O" nil))
#+end_src
** pos-tip - Show tooltip at point
#+begin_src emacs-lisp
  (use-package pos-tip
    :ensure t)
#+end_src
* Help / Discovery / Cheat sheets
** help [built-in]
#+begin_src emacs-lisp
  (use-package help
    :ensure nil
    :commands (help-mode)
    :config
    (advice-add #'help-window-display-message
                :after #'(lambda (&rest _ignored)
                           ;; Don't show the message in the bottom of the screen
                           (message nil)))
    :general
    (emacs-map
      'help-mode-map
      "<mouse-8>" #'help-go-back
      "<wheel-left>" #'help-go-back
      "<mouse-9>" #'help-go-forward
      "<wheel-right>" #'help-go-forward
      "d" #'scroll-down-command
      "u" #'scroll-up-command)
    (emacs-map
      :keymaps 'help-mode-map
      :states '(normal visual motion)
      "d" #'evil-scroll-down
      "u" #'evil-scroll-up
      "g]" #'forward-button
      "g[" #'backward-button
      "gr" #'revert-buffer
      "<" #'help-go-back
      ">" #'help-go-forward
      "<tab>" #'forward-button
      "<backtab>" #'backward-button)
    (emacs-map
      :keymaps 'evil-window-map
      "e" #'view-echo-area-messages)
    (evil-mmap
      :keymaps 'help-mode-map
      "<mouse-8>" #'help-go-back
      "<wheel-left>" #'help-go-back))

  (use-package help-fns
    :ensure nil
    :commands (describe-keymap
               describe-command)
    :general
    (emacs-map
      'help-map
      "K" #'describe-keymap))
#+end_src
** info [built-in]
#+begin_src emacs-lisp
  (use-package info
    :ensure nil
    :general
    (emacs-map
      'Info-mode-map
      "TAB" #'Info-next-reference
      "<mouse-8>" #'Info-history-back
      "<wheel-left>" #'Info-history-back
      "<mouse-9>" #'Info-history-forward
      "<wheel-right>" #'Info-history-forward
      "<" #'Info-history-back
      ">" #'Info-history-forward)
    (evil-nmmap
      'Info-mode-map
      "<return>" #'Info-follow-nearest-node
      "C-t" #'Info-history-back
      "C-o" #'Info-history-back
      "<" #'Info-history-back
      "C-i" #'Info-history-forward
      ">" #'Info-history-forward
      "gj" #'Info-next
      "gk" #'Info-prev
      "TAB" #'Info-next-reference
      "g TAB" #'Info-next-reference
      "g]" #'Info-next-reference
      "g[" #'Info-prev-reference
      "T" #'Info-toc
      "^" #'Info-up))
#+end_src
** apropos [built-in]
#+begin_src emacs-lisp
  (use-package apropos
    :ensure nil
    :commands (apropos-mode
               apropos
               apropos-variable
               apropos-local-variable
               apropos-function
               apropos-command
               apropos-library
               apropos-value
               apropos-local-value
               apropos-documentation)
    :general
    (evil-nmmap
      'apropos-mode-map
      "[[" #'apropos-previous-symbol
      "]]" #'apropos-next-symbol
      "q" '(quit-window :no-autoload t)
      "ZQ" '(evil-quit :no-autoload t)
      "ZZ" '(quit-window :no-autoload t))
    (emacs-map
      'apropos-mode-map
      "[[" #'apropos-previous-symbol
      "]]" #'apropos-next-symbol
      "q" '(quit-window :no-autoload t)
      "ZQ" '(evil-quit :no-autoload t)
      "ZZ" '(quit-window :no-autoload t)))
#+end_src
** descr-text [built-in]
#+begin_src emacs-lisp
  (use-package descr-text
    :ensure nil
    :general
    (emacs-map
      'help-map
      "=" #'describe-char))
#+end_src
** man [built-in]
#+begin_src emacs-lisp
  (use-package man
    :ensure nil
    :commands (Man
               Man-next-section
               Man-at-mouse
               man-follow)
    :custom
    (Man-notify-method 'aggressive)
    :general
    (emacs-map
      'Man-mode-map
      [remap Man-next-section] #'(lambda (_n)
                                   (interactive "p" man-common)
                                   (call-interactively #'Man-next-section)
                                   (recenter))
      [remap Man-previous-section] #'(lambda (_n)
                                       (interactive "p" man-common)
                                       (call-interactively #'Man-previous-section)
                                       (recenter))
      "[[" #'Man-previous-section
      "]]" #'Man-next-section
      "q" '(quit-window :no-autoload t)
      "ZQ" '(evil-quit :no-autoload t)
      "ZZ" '(quit-window :no-autoload t))
    (evil-nmmap
      'Man-mode-map
      "[[" #'Man-previous-section
      "]]" #'Man-next-section
      "gr" #'Man-update-manpage
      "q" '(quit-window :no-autoload t)
      "ZQ" '(quit-window :no-autoload t)
      "ZZ" '(quit-window :no-autoload t))
    (evil-mmap
      'Man-mode-map
      "d" '(evil-scroll-down :no-autoload t)
      "u" '(evil-scroll-up :no-autoload t)))
#+end_src
** which-key - Display available key bindings in popup
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :delight (which-key-mode)
    :commands (which-key-mode
               which-key-show-top-level
               which-key-show-major-mode
               which-key-show-keymap
               which-key-add-key-based-replacements
               which-key-add-major-mode-key-based-replacements
               which-key-add-keymap-based-replacements)
    :custom
    (echo-keystrokes 0)
    (which-key-idle-delay 0.4)
    (which-key-idle-secondary-delay 0)
    (which-key-max-description-length 32)
    (which-key-add-column-padding 2)
    (which-key-min-display-lines 7)
    (which-key-use-C-h-commands t)
    (which-key-show-early-on-C-h t)
    (which-key-compute-remaps t)
    :config
    (which-key-add-key-based-replacements "C-x a" "abbrev prefix")
    (which-key-add-key-based-replacements "C-x t" "tab-bar prefix")
    (which-key-add-key-based-replacements "C-x C-k" "kmacro prefix")
    (which-key-add-key-based-replacements "SPC f" "link-hint prefix")
    (which-key-add-key-based-replacements "SPC g" "buffer-local-leader")
    (which-key-add-key-based-replacements "SPC s" "system-local-leader")
    (which-key-add-key-based-replacements "SPC e" "mode-action-leader")
    (which-key-add-key-based-replacements "SPC ," "inspect-leader")
    (which-key-add-key-based-replacements "SPC g e" "next-error prefix")
    (which-key-add-key-based-replacements "SPC g h" "hi-lock prefix")
    (which-key-add-key-based-replacements "g ." "evil-mc prefix")
    (which-key-add-key-based-replacements "SPC b" "bookmark prefix")
    (which-key-add-key-based-replacements "SPC w" "window prefix")
    (which-key-add-key-based-replacements "SPC t" "tab prefix")
    (which-key-add-key-based-replacements "<backspace> h" "help prefix")
    (which-key-add-key-based-replacements "<backspace> p" "proj prefix")
    (which-key-add-key-based-replacements "<backspace> g" "magit prefix")
    :general
    (c-x-leader
      "/" #'which-key-show-top-level
      "@" #'which-key-show-major-mode
      "^" #'which-key-show-keymap)
    :hook
    (emacs-startup-hook . which-key-mode))

  (use-package which-key-posframe
    :if (and (window-system) (version<= "26.1" emacs-version))
    :disabled t
    :ensure t
    :after (:all which-key)
    :delight (which-key-posframe-mode)
    :commands (which-key-posframe-mode)
    :custom
    (which-key-posframe-font nil)
    (which-key-posframe-poshandler #'+which-key-posframe-poshandler)
    (which-key-posframe-border-width 2)
    :preface
    (declare-function posframe-poshandler-frame-center "posframe")
    :config
    (defun +which-key-posframe-poshandler (info)
      (let ((centered (posframe-poshandler-frame-center info)))
        (cons (car centered) (/ (cdr centered) 2 ))))
    :hook
    (which-key-mode-hook . which-key-posframe-mode))
#+end_src
** free-keys - Show free keybindings for modkeys or prefixes
I found the ~free-keys~ documentation a bit confusing in the beginning.
If the prefix should be changed (using "p" in the buffer), do not type the prefix (don't hold C-c), but write the string into the completion buffer (type "C" "-" "c").
Same is true for the prefix argument.
Execute ~free-keys~ using C-u M-x "free-keys" and then type "C" "-" "c" into the completion buffer.
#+begin_src emacs-lisp
  (use-package free-keys
    :ensure t
    :commands (free-keys
               free-key-change-buffer
               free-key-set-prefix)
    :custom
    (free-keys-modifiers '("" "C" "M" "C-M"))
    :general
    (emacs-map
      'help-map
      "C-k" #'free-keys)
    (emacs-map
      'free-keys-mode-map
      "q" '(kill-buffer-and-window :no-autoload t))
    (evil-nmap
      'free-keys-mode-map
      "q" '(kill-buffer-and-window :no-autoload t)
      "p" #'free-keys-set-prefix
      "b" #'free-keys-change-buffer
      "<" '(beginning-of-buffer :no-autoload t)
      ">" '(end-of-buffer :no-autoload t)))
#+end_src
** keyfreq - track command frequencies
#+begin_src emacs-lisp
  (use-package keyfreq
    :ensure t
    :commands (keyfreq-mode
               keyfreq-autosave-mode
               keyfreq-show)
    :custom
    (keyfreq-buffer "*keyfreq-show*")
    (keyfreq-file (expand-file-name "keyfreq.hist" user-emacs-cache-directory))
    (keyfreq-file-lock (expand-file-name "keyfreq.hist.lock" user-emacs-cache-directory))
    :config
    (setq-default keyfreq-excluded-commands
                  '(self-insert-command
                    org-self-insert-command
                    mwheel-scroll
                    mouse-drag-region
                    mouse-set-point))
    :hook
    (emacs-startup-hook . keyfreq-mode)
    (emacs-startup-hook . keyfreq-autosave-mode))
#+end_src
** help-fns+.el - Extensions to `help-fns.el'
#+begin_src emacs-lisp
  (use-package help-fns+
    :ensure nil
    :commands (describe-buffer
               describe-option
               describe-option-of-type
               describe-file))
#+end_src
* File manager
** dired [built-in] - directory editor
#+begin_src emacs-lisp
  (use-package dired
    :ensure nil
    :defer t
    :commands (dired
               dired-other-window
               dired-other-frame
               dired-other-tab
               dired-jump
               dired-jump-other-window)
    :custom
    (dired-listing-switches "-AblGh --group-directories-first")
    :config
    (defun +dired-alternate-up-directory ()
      "In Dired, visit the parent directory via `find-alternate-file'.
  This kills the Dired buffer, then visits the parent directory."
      (interactive)
      (find-alternate-file ".."))
    (defun +dired-open ()
      "In Dired, visit the file or directory named on this line.
  If one is about to visit a directory, it is opened via `find-alternate-file'.
  This kills the Dired buffer, then visits the directory.
  Otherwise, it is opened via `find-file'."
      (interactive)
      (if (file-directory-p (dired-get-file-for-visit))
          (find-alternate-file (dired-get-file-for-visit))
        (find-file (dired-get-file-for-visit))))
    (defun +dired-mouse-find-file (event)
      (interactive "e")
      (dired-mouse-find-file event #'find-file #'find-alternate-file))
    (put 'dired-find-alternate-file 'disabled nil)
    :general
    (c-x-leader
      "D" #'dired-jump)
    (evil-emap
      "C-x D" #'dired-jump)
    (emacs-map
      :keymaps 'dired-mode-map
      :no-autoload t
      "<return>" #'+dired-open
      "<up>" #'dired-previous-line
      "<down>" #'dired-next-line
      "^" #'+dired-alternate-up-directory
      "o" #'+dired-open
      "C-o" #'dired-find-file-other-window
      "C-<return>" #'dired-find-file-other-window
      "<mouse-2>" #'+dired-mouse-find-file
      "<mouse-8>" #'+dired-alternate-up-directory
      "C-<mouse-2>" #'dired-mouse-find-file-other-window
      "C-<mouse-1>" #'dired-mouse-find-file-other-window
      "C-<down-mouse-1>" #'dired-mouse-find-file-other-window)
    (emacs-map
      :keymaps 'dired-mode-map
      :states '(normal visual motion)
      "gr" '(revert-buffer :no-autoload t)))

  (use-package +dired
    :ensure nil
    :after (:all dired)
    :commands (+dired-maybe-insert-subdir-or-kill-subdir)
    :general
    (emacs-map
      :keymaps 'dired-mode-map
      [remap dired-maybe-insert-subdir] #'+dired-maybe-insert-subdir-or-kill-subdir))
#+end_src
** dired-narrow - Live-narrowing of search results for dired
#+begin_src emacs-lisp
  (use-package dired-narrow
    :ensure (dired-narrow :pin melpa)
    :after (:all dired)
    :commands (dired-narrow
               dired-narrow-regexp
               dired-narrow-fuzzy))
#+end_src
** colored-dired - More colors for dired
#+begin_src emacs-lisp
  (use-package colored-dired
    :ensure nil
    :commands (colored-dired-setup-font-locking)
    :hook
    (dired-mode-hook . colored-dired-setup-font-locking))
#+end_src
** treemacs - A tree style file explorer package
#+begin_src emacs-lisp
  (use-package treemacs
    :ensure t
    :commands (treemacs)
    :custom
    (treemacs-persist-file (expand-file-name "treemacs-persist" user-emacs-cache-directory))
    :general
    (emacs-map
      "<f8>" #'treemacs)
    (emacs-map
      'treemacs-mode-map
      "<up>" #'treemacs-previous-line
      "<down>" #'treemacs-next-line)
    :config
    (treemacs-follow-mode))

  (use-package treemacs-projectile
    :ensure t
    :after (:all treemacs projectile))

  (use-package treemacs-magit
    :ensure t
    :after (:all treemacs magit))

  (use-package treemacs-persp
    :ensure t
    :after (:all treemacs perspective))
#+end_src
* Visual
** whitespace [built-in]
#+begin_src emacs-lisp
  (use-package whitespace
    :ensure nil
    :delight (whitespace-mode)
    :commands (whitespace-mode)
    :custom
    (whitespace-style '(face tab-mark newline-mark))
    (whitespace-display-mappings
     '((space-mark 32 [9251] [46])
       (space-mark 160 [164] [95])
       (tab-mark 9 [8677 9] [187 9] [92 9])
       (newline-mark 10 [8617 10] [36 10]))))
#+end_src
** hi-lock [built-in] - minor mode for interactive automatic highlighting
#+begin_src emacs-lisp
  (use-package hi-lock
    :ensure nil
    :demand t
    :delight (hi-lock-mode)
    :commands (hil-lock-mode
               global-hi-lock-mode)
    :config
    (defun +highlight-region-or-symbol (&optional face)
      "Highlight occurences of either the currently region or the symbol at point."
      (interactive
       (list (hi-lock-read-face-name)))
      (or (facep face) (setq face 'hi-yellow))
      (unless hi-lock-mode (hi-lock-mode 1))
      (let ((thing-to-highlight
             (if (use-region-p)
                 (buffer-substring (region-beginning) (region-end))
               (thing-at-point 'symbol 'no-properties))))
        (unless thing-to-highlight
          (user-error "Nothing to highlight"))
        (hi-lock-set-pattern (regexp-quote thing-to-highlight) face)))

    (defun +unhighlight-region-or-symbol ()
      "Unhighlight either the currently region or the symbol at point."
      (interactive nil hi-lock-mode)
      (let ((thing-to-highlight
             (if (use-region-p)
                 (buffer-substring (region-beginning) (region-end))
               (thing-at-point 'symbol 'no-properties))))
        (unhighlight-regexp (regexp-quote thing-to-highlight))))

    (defun +unhighlight-all ()
      "Unhighlight everything that has been previously highlighted."
      (interactive nil hi-lock-mode)
      (unhighlight-regexp t))
    :general
    (buffer-local-leader
      :no-autoload t
      "h i" #'hi-lock-find-patterns
      "h l" #'highlight-lines-matching-regexp
      "h p" #'highlight-phrase
      "h h" #'highlight-regexp
      "h r" #'unhighlight-regexp
      "h b" #'hi-lock-write-interactive-patterns
      "h ." #'+highlight-region-or-symbol
      "h ," #'+unhighlight-region-or-symbol
      "h U" #'+unhighlight-all
      "h q" #'+unhighlight-all)
    (emacs-map
      "C-x w i" nil
      "C-x w l" nil
      "C-x w p" nil
      "C-x w h" nil
      "C-x w ." nil
      "C-x w r" nil
      "C-x w b" nil)
    :hook
    (emacs-startup-hook . global-hi-lock-mode))
#+end_src
** highlight-thing - Minimalistic minor mode to highlight current thing under point
#+begin_src emacs-lisp
  (use-package highlight-thing
    :ensure t
    :delight (highlight-thing-mode)
    :commands (highlight-thing-mode
               global-hightlight-thing-mode)
    :custom
    (highlight-thing-delay-seconds 2)
    (highlight-thing-exclude-thing-under-point t)
    (highlight-thing-prefer-active-region t)
    :hook
    (emacs-startup-hook . global-highlight-thing-mode))
#+end_src
* Editing
** indent [built-in] - indentation commands for emacs
#+begin_src emacs-lisp
  (use-package emacs ;; indent does not `provide'
    :ensure nil
    :demand t
    :config
    (defun +indent-buffer ()
      (interactive)
      "Indent each nonblank line in the whole buffer."
      (save-excursion
        (indent-region (point-min) (point-max)))))
#+end_src
** expand-region - Increase selected region by semantic units
#+begin_src emacs-lisp
  (use-package expand-region
    :ensure t
    :commands (er/expand-region
	       er/contract-region
	       er/mark-symbol)
    :general
    (emacs-map
      "C-=" #'er/expand-region
      "C-+" #'er/contract-region
      "M-C-S-SPC" #'er/mark-symbol)
    (evil-nmmap
      "+" #'er/expand-region
      "-" #'er/contract-region))
#+end_src
** string-inflection - underscore -> UPCASE -> CamelCase -> lowerCamelCase conversion of names
#+begin_src emacs-lisp
  (use-package string-inflection
    :ensure t
    :commands (string-inflection-all-cycle
               string-inflection-upcase
               string-inflection-java-style-cycle
               string-inflection-python-style-cycle
               string-inflection-ruby-style-cycle)
    :config
    (defun +string-inflection-cycle-auto-detection ()
      (interactive)
      (cond
       ((eq major-mode 'java-mode)
        (string-inflection-java-style-cycle))
       ((eq major-mode 'python-mode)
        (string-inflection-python-style-cycle))
       ((eq major-mode 'ruby-mode)
        (string-inflection-ruby-style-cycle))
       (t
        (string-inflection-all-cycle))))
    :general
    (emacs-map
      "M-u" #'string-inflection-upcase
      "M-l" '(+string-inflection-cycle-auto-detection :no-autoloads t)))
#+end_src
** delsel [built-in] - delete selection if you insert
#+begin_src emacs-lisp
  (use-package delsel
    :ensure nil
    :commands (delete-selection-mode)
    :hook
    (emacs-startup-hook . delete-selection-mode))
#+end_src
* Kill-ring
** System clipboard integration
#+begin_src emacs-lisp
  (use-package menu-bar
    :ensure nil
    :commands (clipboard-kill-region
               clipboard-kill-ring-save
               clipboard-yank)
    :custom
    (save-interprogram-paste-before-kill t)
    :general
    (emacs-map
      "<XF86Cut>" #'clipboard-kill-region
      "<XF86Copy>" #'clipboard-kill-ring-save
      "<XF86Paste>" #'clipboard-yank))
#+end_src
** undo [built-in]
#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :demand t
    :custom
    (undo-limit 160000))
#+end_src
** undo-tree - Treat undo history as a tree
#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure (undo-tree :pin gnu-elpa-devel)
    :delight (undo-tree-mode)
    :commands (global-undo-tree-mode
               unto-tree-visualize
               unto-tree-undo)
    :custom
    (undo-tree-limit 160000)
    (undo-tree-auto-save-history t)
    (undo-tree-history-directory-alist
     `(("." . ,(file-name-as-directory
                (expand-file-name "undo" user-emacs-cache-directory)))))
    (undo-tree-visualizer-diff t)
    (undo-tree-visualizer-timestamps t)
    :config
    (let
        ((undo-dir (file-name-as-directory
                    (expand-file-name "undo" user-emacs-cache-directory))))
      (unless (file-exists-p undo-dir) (make-directory undo-dir t)))
    :general
    (emacs-map
      'undo-tree-map
      [remap undo] #'undo-tree-undo
      [remap undo-redo] #'undo-tree-redo
      "C-x U" #'undo-tree-visualize)
    (evil-nmmap
     'undo-tree-map
     "SPC U" #'undo-tree-visualize)
    (emacs-map
      'undo-tree-visualizer-mode-map
      "C-x u" #'undo-tree-visualize-quit)
    :hook
    (emacs-startup-hook . global-undo-tree-mode)
    (evil-local-mode-hook . turn-on-undo-tree-mode))
#+end_src
** elec-pair - Automatic parenthesis pairing
#+begin_src emacs-lisp
  (use-package elec-pair
    :ensure nil
    :custom
    (electric-pair-skip-whitespace nil)
    :commands (electric-pair-mode
               electric-pair-local-mode)
    :hook
    (c-mode-common-hook . electric-pair-local-mode))
#+end_src
* Movement / Navigation
#+begin_src emacs-lisp
  (use-package simple
    :ensure nil
    :custom
    (scroll-error-top-bottom 'true)
    (scroll-margin 0)
    (scroll-conservatively 100000)
    (scroll-preserve-screen-position 1)
    (backward-delete-char-untabify-method nil)
    :config
    (defun backward-kill-char-or-word ()
      "Kill characters backward.
  If the characters behind the cursor form a word
  \(possibly with ablank behind it\), `backward-kill-word'.
  If there are multiple blanks, `delete-horizontal-space',
  otherwise `backward-delete-char'"
      (interactive)
      (cond
       ((looking-back "[[:word:]][[:blank:]]?" 1)
        (backward-kill-word 1))
       ((looking-back "[[:blank:]]+" 1)
        (delete-horizontal-space t))
       (t
        (delete-char -1))))
    (defun forward-paragraph-recenter (&optional _arg)
      "Move forward to end of paragraph and center point using `recenter'.
  With argument ARG, do it ARG times; a negative argument ARG = -N means
  move backward N paragraphs."
      (interactive "^p")
      (call-interactively #'forward-paragraph)
      (recenter nil t))
    (defun backward-paragraph-recenter (&optional _arg)
      "Move backward to start of paragraph and center point using `recenter'.
  a negative argument ARG = -N means move forward N paragraphs."
      (interactive "^p")
      (call-interactively #'backward-paragraph)
      (recenter nil t))
    :general
    (emacs-map
      :no-autoload t
      "M-d" #'backward-kill-char-or-word
      [mouse-8] #'pop-tag-mark
      [C-mouse-8] #'previous-buffer
      [C-mouse-9] #'next-buffer
      "M-}" #'forward-paragraph-recenter
      "M-{" #'backward-paragraph-recenter
      "M-i" #'back-to-indentation))
#+end_src
** xt-mouse [built-in] - support the mouse when emacs run in an xterm
#+begin_src emacs-lisp
  (use-package xt-mouse
    :ensure nil
    :delight xterm-mouse-mode
    :commands (xterm-mouse-mode)
    :hook
    (after-make-frame-functions . (lambda (frame) (xterm-mouse-mode))))
#+end_src
** goto-chg - Go to last change
#+begin_src emacs-lisp
  (use-package goto-chg
    :ensure t
    :commands (goto-last-change
               goto-last-change-reverse)
    :general
    (emacs-map
      "M-s c" #'goto-last-change
      "M-s C" #'goto-last-change-reverse))
#+end_src
** disable-mouse - Disable mouse commands globally
#+begin_src emacs-lisp
  (use-package disable-mouse
    :disabled t
    :ensure t
    :delight (disable-mouse-mode)
    :commands (disable-mouse-mode
               disable-mouse-global-mode
               disable-mouse-in-keymap
               +disable-mouse-in-evil-mode)
    :config
    (defun +disable-mouse-in-evil-mode ()
      (interactive)
      (when (bound-and-true-p evil-mode)
        (mapc #'disable-mouse-in-keymap
              (list evil-motion-state-map
                    evil-normal-state-map
                    evil-visual-state-map
                    evil-insert-state-map))))
    :hook
    (emacs-startup-hook . disable-mouse-global-mode)
    (evil-mode-hook . +disable-mouse-in-evil-mode))
#+end_src
** golden-ratio-scroll-screen - Scroll half screen down or up, and highlight current line
#+begin_src emacs-lisp
  (use-package golden-ratio-scroll-screen
    :ensure t
    :custom
    (golden-ratio-scroll-highlight-flag nil "Do not highlight current line before/after scroll")
    :general
    (emacs-map
      [remap scroll-down-command] #'golden-ratio-scroll-screen-down
      [remap scroll-up-command] #'golden-ratio-scroll-screen-up)
    :hook
    (golden-ratio-scroll-screen-up-hook . (lambda () (recenter)))
    (golden-ratio-scroll-screen-down-hook . (lambda () (recenter))))
#+end_src
** move-text - Move current line or region with M-up or M-down.
#+begin_src emacs-lisp
  (use-package move-text
    :ensure t
    :commands (move-text-up
               move-text-down
               move-text-line-up
               move-text-line-down
               move-text-region
               move-text-region-up
               move-text-region-down)
    :general
    (emacs-map
      "M-p" #'move-text-up
      "M-n" #'move-text-down))
#+end_src
** Avy - Jump to arbitrary positions in visible text and select text quickly
#+begin_src emacs-lisp
  (use-package avy
    :ensure t
    :custom
    (avy-keys (list ?h ?t ?n ?s ?d ?u ?e ?o ?a))
    :general
    (buffer-local-leader
      "g" #'avy-goto-line
      "c" #'avy-goto-char
      "f" #'avy-goto-word-0)
    (evil-nmap
      "M-f" #'avy-goto-line))
#+end_src
** ace-window - Quickly switch windows
#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :commands (ace-window)
    :custom
    (aw-keys '(?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9))
    (aw-background nil)
    (aw-ignored-buffers '("*Ilist*" "*Calc Trail*" " *LV*"))
    :custom-face
    (aw-leading-char-face ((t (:inherit ace-jump-face-foreground :height 3.0))))
    :general
    (emacs-map
      [remap other-window] #'ace-window))
#+end_src
** view.el [built-in] - peruse file or buffer without editing
#+begin_src emacs-lisp
  (use-package view
    :ensure nil
    :commands (view-mode)
    :general
    (emacs-map
      "M-z" #'view-mode)
    (emacs-map
      'view-mode-map
      "n" #'next-line
      "p" #'previous-line)
    (evil-nmap
      'view-mode-map
      "d" #'View-scroll-page-forward
      "u" #'View-scroll-page-backward
      "s" '(isearch-forward :no-autoload t)
      "r" '(isearch-backward :no-autoload t)))
#+end_src
** link-hint - Use avy to open, copy, etc. visible links
#+begin_src emacs-lisp
  (use-package link-hint
    :ensure t
    :commands (link-hint-open-link
               link-hint-copy-link
               link-hint-copy-all-links
               link-hint-open-all-links
               link-hint-copy-link-at-point
               link-hint-open-link-at-point
               link-hint-copy-multiple-links
               link-hint-open-multiple-links)
    :custom
    (link-hint-restore t)
    :general
    (evil-nmmap
      :keymaps 'override
      "SPC f" #'link-hint-open-link
      "SPC F" #'link-hint-copy-link))

  (use-package +link-hint
    :ensure nil
    :after (link-hint)
    :demand t
    :functions (+link-hint-setup)
    :config
    (+link-hint-setup))
#+end_src
* Searching
** isearch [built-in]
#+begin_src emacs-lisp
  (use-package isearch
    :ensure nil
    :config
    (eval-when-compile (require 'isearch))
    (setq search-highlight t)
    (setq search-whitespace-regexp ".*?")
    (setq isearch-lax-whitespace t)
    (setq isearch-regexp-lax-whitespace nil)
    (setq isearch-lazy-count t)
    (setq isearch-lazy-highlight t)
    (eval-and-compile
      (defun +isearch-and-regex (search-input &optional _lax)
        (message search-input)
        search-input)
      (isearch-define-mode-toggle and "^" +isearch-and-regex
        "Turning on and search turns off regexp mode."))
    :general
    (emacs-map 'isearch-mode-map
      "C-g" #'isearch-cancel
      "<help>" nil
      "C-h <help>" nil
      "<f1> <help>" nil
      "M-ESC ESC" nil))
#+end_src
** replace / occur [built-in]
#+begin_src emacs-lisp
  (use-package replace
    :ensure nil
    :demand t
    :config
    (defun +occur-mode-move-beginning-of-line (arg)
      (interactive "^p")
      (or arg (setq arg 1))
      (if (/= arg 1)
          (let ((line-move-visual nil))
            (line-move (1- arg) t)))
      (let ((current-line (thing-at-point 'line t)))
        (if (string-match-p "^[[:space:]]*[0-9]+:" current-line)
            (progn
              (move-beginning-of-line 1)
              (re-search-forward "^[[:space:]]*[0-9]+:"))
          (move-beginning-of-line 1))))
    (defun +occur-mode-goto-occurrence-stay-occurrence-buffer (&optional _event)
      (interactive (list last-nonmenu-event))
      (let ((window (selected-window)))
        (call-interactively #'occur-mode-goto-occurrence)
        (select-window window)))
    :general
    (buffer-local-leader
      "&" #'query-replace
      "%" #'replace-string
      "o" #'occur
      "O" #'multi-occur)
    (emacs-map
      'occur-mode-map
      "C-a" #'+occur-mode-move-beginning-of-line
      "^" #'+occur-mode-move-beginnig-of-line
      "S-<return>" #'+occur-mode-goto-occurrence-stay-occurrence-buffer
      "q" #'kill-buffer-and-window
      "<up>" #'previous-line
      "<down>" #'next-line
      "j" #'next-line
      "k" #'previous-line
      [remap next-line] #'next-error-no-select
      [remap previous-line] #'previous-error-no-select)
    (evil-nmmap
      'occur-mode-map
      "o" #'occur-mode-goto-occurrence-other-window
      "r" #'occur-rename-buffer
      "q" #'kill-buffer-and-window)
    (emacs-map
      'occur-edit-mode-map
      "C-a" #'+occur-mode-move-beginning-of-line)
    (evil-nmap
      'occur-edit-mode-map
      "o" #'occur-mode-goto-occurrence-other-window))
#+end_src
** find-dired [built-in] - run a find command and dired the output
#+begin_src emacs-lisp
  (use-package find-dired
    :ensure nil
    :commands (find-dired
               find-dired-with-command
               find-name-dired
               find-grep-dired)
    :custom
    (find-ls-option (cons "-print0 |xargs -0 ls -ldh" "-ldh")))
#+end_src
** loccur - Perform an occur-like folding in current buffer
#+begin_src emacs-lisp
  (use-package loccur
    :ensure (loccur :pin melpa)
    :general
    (buffer-local-leader
      "R" #'loccur
      "r" #'loccur-isearch))
#+end_src
** grep [built-in]
#+begin_src emacs-lisp
  (use-package grep
    :ensure nil
    :commands (grep
               grep-mode
               grep-process-setup
               grep-compute-defaulst
               find-grep
               grep-find
               lgrep
               rgrep
               zrgrep
               rzgrep)
    :general
    (emacs-map
      'grep-mode-map
      "e" #'wgrep-change-to-wgrep-mod
      "q" '(kill-buffer-and-window :no-autoload t)))
#+end_src
** wgrep - Writable grep buffer and apply the changes to files
#+begin_src emacs-lisp
  (use-package wgrep
    :ensure t
    :commands (wgrep-setup
               wgrep-change-to-wgrep-mode)
    :general
    (emacs-map
      'grep-mode-map
      "C-c '" #'wgrep-change-to-wgrep-mode)
    (emacs-map
      'wgrep-mode-map
      "C-x C-s" nil
      "C-c c" #'wgrep-finish-edit
      "C-c k" #'wgrep-abort-changes
      "C-c r" #'wgrep-remove-change
      "C-c u" #'wgrep-remove-all-change))
#+end_src
** rg - A search tool based on ripgrep
#+begin_src emacs-lisp
  (use-package rg
    :ensure t
    :commands (rg
               rg-project
               rg-literal
               rg-dwim
               rg-dwim-project-dir
               rg-dwim-current-dir
               rg-dwim-current-file)
    :custom
    (rg-command-line-flags '("--no-ignore-vcs"))
    (rg-buffer-name "ripgrep")
    (rg-ignore-ripgreprc t)
    :general
    (emacs-map
      'rg-mode-map
      :no-autoload t
      "C-c '" #'wgrep-change-to-wgrep-mode
      "q" #'kill-buffer-and-window))

  (use-package rg-menu
    :ensure nil ;; part of rg
    :commands (rg-menu rg-enable-menu))

  (use-package wgrep-rg
    :ensure nil ;; part of rg
    :commands (wgrep-rg-setup)
    :hook
    (rg-mode-hook . wgrep-rg-setup))
#+end_src
* Coloring / themes / fonts
** Themes
#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t)

  (use-package zenburn-theme
    :ensure t)

  (use-package spacemacs-common
    :ensure (spacemacs-theme :pin melpa-stable))

  (use-package solarized-theme
    :ensure (solarized-theme :pin melpa-stable))

  (use-package ample-theme
    :ensure t)

  (use-package sexy-monochrome-theme
    :ensure t)

  (use-package gruber-darker-theme
    :ensure t)

  (use-package doom-themes
    :ensure t)

  (use-package gruvbox-theme
    :ensure (gruvbox-theme :pin melpa))

  (use-package naysayer-theme
    :ensure t)

  (use-package standard-themes
    :ensure t)

  (use-package custom
    :ensure nil
    :commands (switch-theme
               load-theme
               enable-theme)
    :config
    (defun switch-theme (theme)
      (interactive
       (list
        (intern (completing-read "Switch custom theme: "
                                 (mapcar #'symbol-name
                                         (custom-available-themes))))))
      (unless (custom-theme-name-valid-p theme)
        (error "Invalid theme name `%s'" theme))
      (unless (eq theme (car custom-enabled-themes))
        (mapc #'disable-theme custom-enabled-themes)
        (if (custom-theme-p theme)
            (enable-theme theme)
          (load-theme theme :no-confirm))))
    :hook
    (after-make-frame-functions . (lambda (frame)
                                    (if (or (display-graphic-p)
                                            ;; daemon running on GNU/Linux with X
                                            (and (eq system-type 'gnu/linux) (daemonp) (getenv "DISPLAY")))
                                        (switch-theme 'naysayer)
                                      (switch-theme 'naysayer)))))
#+end_src
** Fonst
#+begin_src emacs-lisp
  (use-package face-remap
    :ensure nil
    :demand t
    :init
    ;;;; Monospace font cycling and initial setup
    (defvar +font-cycle-list nil
      "The list of fonts used by `+font-cycle-step'")
    (defvar +font-cycle-list--idx 0
      "The next index into `+font-cycle-step'.
  The element at that index will be used at the next call to `+font-cycle-step'.")
    (setq +font-cycle-list nil)
    (setq +font-cycle-list--idx 0)
    (defun +font-cycle-step ()
      "Cycles to the next font defined in `+font-cycle-list'."
      (interactive)
      (when (and (display-graphic-p) (not (null (cdr +font-cycle-list))))
        (let ((next-font (nth +font-cycle-list--idx +font-cycle-list)))
          (set-face-attribute 'default nil :font next-font)
          (message "Switching font to %s." next-font)
          (setq +font-cycle-list--idx (mod (1+ +font-cycle-list--idx) (length +font-cycle-list))))))
    (defun +text-scale-reset ()
      (interactive)
      (text-scale-set 0))
    (defun +initialize-fonts ()
      (unless +font-cycle-list
        (when (find-font (font-spec :name "Source Code Pro"))
          (push "Source Code Pro:size=14:hintstyle=hintfull:autohint=true:antialise=true:rgba=rgb" +font-cycle-list))
        (when (find-font (font-spec :name "Hack"))
          (push "Hack:size=14:hintstyle=hintfull:autohint=true:antialise=true:rgba=rgb" +font-cycle-list))
        (when (find-font (font-spec :name "Inconsolata"))
          (push "Inconsolata:size=14:hintstyle=hintfull:autohint=true:antialise=true:rgba=rgb" +font-cycle-list))
        (when (find-font (font-spec :name "Victor Mono"))
          (push "Victor Mono:size=14:hintstyel=hintfull:autohint=true:antialise=true:rgba=rgb" +font-cycle-list))
        (when (find-font (font-spec :name "Fira Code"))
          (push "Fira Code:size=14:hintstyle=hintfull:autohint=true:antialise=true:rgba=rgb" +font-cycle-list))
        (unless +font-cycle-list
          (warn "settings.el: Failed to load custom fonts"))
        (+font-cycle-step)))
    (cond
     ((display-graphic-p)
      (add-hook 'emacs-startup-hook #'+initialize-fonts))
     ((and (eq system-type 'gnu/linux) (daemonp) (getenv "DISPLAY"))
      ;; daemon running on GNU/Linux with X
      (add-hook 'server-after-make-frame-hook #'(lambda () (when window-system (+initialize-fonts))))))
    (set-face-background 'glyphless-char "red")
    :general
    (emacs-map
      "M-<kp-add>" #'text-scale-increase
      "M-<kp-subtract>" #'text-scale-decrease
      "M-<kp-multiply>" #'+font-cycle-step
      "M-<kp-0>" #'+text-scale-reset))
#+end_src
** Ligature
#+begin_src emacs-lisp
  (use-package ligature
    :ensure t
    :commands (ligature-mode
               global-ligature-mode
               ligature-set-ligatures)
    :config
    (ligature-set-ligatures 'c-mode '("==" "!=" "<=" ">=" ">>" "<<" "||" "&&" "++" "--" "->" "//"
                                      ("0" (rx (and "x" (+ (in "A-F" "a-f" "0-9")))))))
    (ligature-set-ligatures 'c++-mode '("==" "!=" "<=" ">=" "<=>" ">>" "<<" "||" "&&" "++" "--" "->" "//"
                                        ("0" (rx (and "x" (+ (in "A-F" "a-f" "0-9")))))))
    :hook
    (emacs-startup-hook . global-ligature-mode))
#+end_src
* Modeline
** mode-line [built-in]
#+begin_src emacs-lisp
  (use-package simple
    :ensure nil
    :disabled t
    :init
    (setq-default mode-line-percent-position '(-3 "%p"))
    ;; mode-line-position-column-line-format '(" %l,%c") ; Emacs 28
    (setq-default mode-line-format
                  '("%e"
                    mode-line-front-space
                    mode-line-mule-info
                    mode-line-client
                    mode-line-modified
                    mode-line-remote
                    mode-line-frame-identification
                    mode-line-buffer-identification
                    "  "
                    mode-line-position
                    (vc-mode vc-mode)
                    "  "
                    mode-line-modes
                    " "
                    mode-line-misc-info
                    mode-line-end-spaces))
    :hook
    (emacs-startup-hook . line-number-mode)
    (emacs-startup-hook . column-number-mode))
#+end_src
** keycast - Show current command and its binding
#+begin_src emacs-lisp
  (use-package keycast
    :ensure t
    :commands (keycast-mode)
    :config
    (setq keycast-mode-line-remove-tail-elements nil)
    (setq keycast-mode-line-insert-after 'mode-line-buffer-identification)
    (dolist (input '(self-insert-command
                     org-self-insert-command))
      (add-to-list 'keycast-substitute-alist `(,input "." "Typingâ¦")))
    (dolist (event '(mouse-event-p
                     mouse-movement-p
                     mwheel-scroll))
      (add-to-list 'keycast-substitute-alist `(,event "." "Mouseâ¦"))))
#+end_src
** telephon-line - Rewrite of Powerline
#+begin_src emacs-lisp
  (use-package telephone-line
    :ensure (telephone-line :pin melpa)
    :delight (telephone-line-mode)
    :custom
    (telephone-line-height 24)
    (telephone-line-primary-left-separator 'telephone-line-cubed-left)
    (telephone-line-secondary-left-separator 'telephone-line-cubed-hollow-left)
    (telephone-line-primary-right-separator 'telephone-line-cubed-right)
    (telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-right)
    :config
    (telephone-line-defsegment* +telephone-line-vc-segment ()
      (let ((branch vc-mode))
        (when branch
          (setq branch (replace-regexp-in-string
                        "^Git:\\(?:constr\\|detector\\)/PLENG-"
                        "Git:PLENG-"
                        branch))
          (if (< 19 (length branch))
              (concat (substring branch 0 19) "â¦")
            branch))))
    (setq-default
     telephone-line-lhs '((accent . (+telephone-line-vc-segment
                                     telephone-line-erc-modified-channels-segment
                                     telephone-line-process-segment))
                          (evil . (telephone-line-evil-tag-segment))
                          (nil . (telephone-line-minor-mode-segment
                                  telephone-line-buffer-segment)))
     telephone-line-rhs '((nil . (telephone-line-flycheck-segment
                                  telephone-line-misc-info-segment))
                          ;; telephone-line-projectile-segment))
                          (accent . (telephone-line-major-mode-segment))
                          (nil . (telephone-line-airline-position-segment))))
    :hook
    (emacs-startup-hook . telephone-line-mode))
#+end_src
* Shells
** shell [built-in] - specialized comint.el for running the shell
#+begin_src emacs-lisp
  (use-package shell
    :ensure nil
    :commands (shell
               shell-mode)
    :hook
    (shell-mode-hook . (lambda ()
                         (face-remap-set-base 'comint-highlight-prompt :inherit nil))))
#+end_src
** eshell [built-in] - the Emacs command shell
#+begin_src emacs-lisp
  (use-package eshell
    :ensure nil
    :preface
    (defvar +eshell-frame-shell-alist nil)
    :config
    ;; These hooks are used for emacsclient which open an eshell in the server.
    ;; Every eshell is associated with its frame.  If a frame is deleted, all
    ;; eshells which have been created by this frame are killed as well.
    (add-hook 'eshell-mode-hook #'(lambda ()
                                    (let ((frame (selected-frame))
                                          (buffer (current-buffer)))
                                      (setf (alist-get frame +eshell-frame-shell-alist)
                                            (append (list buffer) (alist-get frame +eshell-frame-shell-alist))))))
    (add-to-list 'delete-frame-functions
                 #'(lambda (frame)
                     (let ((buffers (assoc frame +eshell-frame-shell-alist)))
                       (while buffers
                         (when (buffer-live-p (car buffers))
                           (kill-buffer (car buffers)))
                         (setq buffers (cdr buffers)))))))

  (use-package esh-mode
    :ensure nil
    :preface
    (defvar-local +eshell-last-directory-cache nil)
    :commands (esh-mode)
    :hook
    (eshell-post-command-hook . (lambda ()
                                  (when (or (null +eshell-last-directory-cache)
                                            (not (string= +eshell-last-directory-cache default-directory)))
                                    (eval-and-compile
                                      (require 'vc-git)
                                      (require 'vc-hg))
                                    (cond
                                     ((vc-git-root default-directory)
                                      (vc-mode-line default-directory 'Git))
                                     ((vc-hg-root default-directory)
                                      (vc-mode-line default-directory 'Hg))
                                     (t
                                      (setq vc-mode nil)))))))

  (use-package em-hist
    :ensure nil
    :after (:all esh-mode)
    :custom
    (eshell-history-file-name (expand-file-name "eshell-history" user-emacs-cache-directory))
    (eshell-hist-ignoredups t)
    (eshell-save-history-on-exit t))

  (use-package em-dirs
    :ensure nil
    :after (:all esh-mode)
    :custom
    (eshell-last-dir-ring-file-name (expand-file-name "eshell-lastdir" user-emacs-cache-directory)))

  (use-package +eshell
    :ensure nil
    :after (:all eshell)
    :demand t)
#+end_src
** term [built-in] - general command interpreter in a window stuff
#+begin_src emacs-lisp
  (use-package term
    :ensure nil
    :config
    (defun +kill-term-process-sentinel ()
      (let* ((buff (current-buffer))
             (proc (get-buffer-process buff)))
        (set-process-sentinel
         proc
         `(lambda (process event)
            (when (string= event "finished\n")
              (kill-buffer ,buff))))))
    :general
    (evil-imap
      'term-raw-map
      "<delete>" #'term-send-del)
    (emacs-map
      'term-raw-map
      "M-1" nil
      "M-2" nil
      "M-3" nil
      "M-4" nil
      "M-5" nil
      "M-6" nil
      "M-7" nil
      "M-8" nil
      "M-9" nil
      "M-0" nil)
    :hook
    (term-exec-hook . +kill-term-process-sentinel))
#+end_src
* TRAMP
#+begin_src emacs-lisp
  (use-package tramp
    :ensure nil
    :custom
    (tramp-persistency-file-name (expand-file-name "tramp" user-emacs-cache-directory)))
#+end_src
* Project management
** projectile - Manage and navigate projects in Emacs easily
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :delight (projectile-mode)
    :commands (projectile-mode)
    :custom
    (projectile-cache-file (expand-file-name "projectile.cache" user-emacs-cache-directory))
    (projectile-known-projects-file (expand-file-name "projectile-bookmarks.eld" user-emacs-cache-directory))
    (projectile-tags-backend 'ggtags)
    (projectile-switch-project-action 'projectile-dired)
    (projectile-ignored-projects `(,user-emacs-directory))
    :general
    (emacs-map
      "<escape> <escape> p" #'projectile-switch-project
      "M-s p" #'projectile-switch-project
      "C-x p o" #'projectile-ripgrep
      "C-x p O" #'projectile-grep
      "C-x p t" #'projectile-test-project)
    (emacs-map
      'bookmark-map
      "p" #'projectile-switch-project)
    :hook
    ;; after-init-hook is required, otherwise directory variables won't be applied
    ;; if emacs is created with a file argument
    (after-init-hook . projectile-mode))
#+end_src
** fzf - A front-end for fzf.
#+begin_src emacs-lisp
  (use-package fzf
    :ensure (fzf :pin melpa)
    :after (:all projectile))
#+end_src
** bookmark [built-in] - Set bookmarks, maybe annotate them, jump to them later
#+begin_src emacs-lisp
  (use-package bookmark
    :ensure nil
    :commands (bookmark-maybe-load-default-file
               bookmark-load
               bookmark-jump
               bookmark-set
               bookmark-set-no-overwrite
               bookmark-save
               bookmark-bmenu-list)
    :custom
    (bookmark-save-flag 5)
    ;; We do not change the bookmark file from outside of emacs
    (bookmark-watch-bookmark-file nil)
    ;; Do not use the .elp suffix, otherwise prog-mode will be loaded early.
    (bookmark-default-file (expand-file-name "bookmarks" user-emacs-directory))
    (bookmark-sort-flag t)
    (bookmark-fringe-mark nil)
    :general
    (emacs-map
      'bookmark-map
      "<escape>" '(keyboard-quit :no-autoload t)
      "m" #'bookmark-set-no-overwrite
      "M" #'bookmark-set
      "L" #'bookmark-bmenu-list
      "p" '(projectile-switch-project :no-autoload t))
    (evil-nmmap
      :keymaps 'override
      "SPC b" '(:keymap bookmark-map)))

  (use-package +bookmark
    :ensure nil
    :after (:all bookmark)
    :demand t
    :commands (+bookmark-setup
               +bookmark-load-default-contents)
    :config
    ;; Always load bookmarks.
    ;; Didn't find a way to overload bookmark-maybe-load-default-file yet
    (+bookmark-load-default-contents)
    (+bookmark-setup))
#+end_src
* Programming generic
** abbrev [built-in] - abbrev mode commands for Emacs
#+begin_src emacs-lisp
  (use-package abbrev
    :ensure nil
    :commands (abbrev-mode
               edit-abbrevs-mode
               read-abbrev-file
               quietly-read-abbrev-file
               write-abbrev-file
               expand-abbrev
               unexpand-abbrev
               abbrev-insert
               insert-abbrevs
               list-abbrevs
               define-abbrevs
               edit-abbrevs
               edit-abbrevs-redefine
               add-global-abbrev
               add-mode-abbrev
               inverse-add-global-abbrev
               inversa-add-mode-abbrev
               insert-abbrev-table-description
               abbrev-suggest-show-report)
    :custom
    ;; Do not use the .elp suffix, otherwise prog-mode will be loaded early.
    (abbrev-file-name (expand-file-name "abbrevs" user-emacs-directory))
    (only-global-abbrevs nil "Enable mode-specific abbrevs")
    (save-abbrevs nil "Do not save abbrevs") ;; abbrevs are too complicated
    (abbrev-all-caps nil)
    (abbrev-suggest nil "Do not suggest using an abbrev in the echo area")
    :hook
    ((prog-mode-hook . abbrev-mode)
     (org-mode-hook . abbrev-mode)))

  (use-package +abbrev
    :ensure nil
    :after (:all abbrev yasnippet)
    :demand t)
#+end_src
** paren [built-in] - highlight matching paren
#+begin_src emacs-lisp
  (use-package paren
    :ensure nil
    :commands (show-paren-mode)
    :custom
    (show-paren-delay 0.25)
    (show-paren-style 'parenthesis)
    :hook
    (prog-mode-hook . show-paren-mode))
#+end_src
** autoinsert [built-in] - auto insert text when a new file is created
#+begin_src emacs-lisp
  (use-package autoinsert
    :ensure nil
    :delight (auto-insert-mode)
    :commands (auto-insert-mode)
    :custom
    (auto-insert 'other)
    (auto-insert-query nil)
    (auto-insert-alist nil)
    :init
    (defun +auto-insert-using-yasnippet (mode name)
      "Expand a yas snippet with the given NAME in MODE."
      (eval-and-compile '(require yasnippet))
      (yas-expand-snippet
       (yas--template-content
        (yas--get-template-by-uuid mode name))))
    :config
    (define-auto-insert '(sh-mode . "Shell script") '(lambda () (+auto-insert-using-yasnippet 'sh-mode "new-file-template")))
    (define-auto-insert '(emacs-lisp-mode . "Emacs Lisp") '(lambda () (+auto-insert-using-yasnippet 'emacs-lisp-mode "new-file-template")))
    :hook
    (find-file-hook . auto-insert))
#+end_src
** COMMENT treesit [built-in] - tree-sitter utilities
#+begin_src emacs-lisp
  (use-package treesit
    :ensure nil
    :disabled t
    :demand t
    :if (and
         (version<= "29.1" emacs-version)
         (file-directory-p
          (file-name-as-directory
           (expand-file-name "dist" (expand-file-name "tree-sitter-module" user-emacs-directory)))))
    :custom
    (treesit-extra-load-path
     (list (file-name-as-directory
            (expand-file-name "dist" (expand-file-name "tree-sitter-module" user-emacs-directory))))))
#+end_src
** xref [built-in] - Cross-referencing commands
#+begin_src emacs-lisp
  (use-package xref
    :ensure nil
    :config
    (defun +ref-find-definitions-at-mouse (event)
      "Find the definition of identifier at or around mouse click.
  This command is intended to be bound to a mouse event."
      (interactive "e")
      (let ((identifier
             (save-excursion
               (mouse-set-point event)
               (xref-backend-identifier-at-point (xref-find-backend)))))
        (if identifier
            (xref-find-definitions identifier)
          (user-error "No identifier here"))))
    (unless (fboundp 'xref-find-definitions-at-mouse)
      (defalias 'xref-find-definitions-at-mouse '+xref-find-definitions-at-mouse))
    (defun +elisp-describe-thing-at-point ()
      "Show the documentation of the Elisp function and variable near point.
        This checks in turn:
        -- for a function name where point is
        -- for a variable name where point is
        -- for a surrounding function call
        "
      (interactive)
      (let (sym)
        ;; sigh, function-at-point is too clever.  we want only the first half.
        (cond ((setq sym (ignore-errors
                           (with-syntax-table emacs-lisp-mode-syntax-table
                             (save-excursion
                               (or (not (zerop (skip-syntax-backward "_w")))
                                   (eq (char-syntax (char-after (point))) ?w)
                                   (eq (char-syntax (char-after (point))) ?_)
                                   (forward-sexp -1))
                               (skip-chars-forward "`'")
                               (let ((obj (read (current-buffer))))
                                 (and (symbolp obj) (fboundp obj) obj))))))
               (describe-function sym))
              ((setq sym (variable-at-point)) (describe-variable sym))
              ;; now let it operate fully -- i.e. also check the
              ;; surrounding sexp for a function call.
              ((setq sym (function-called-at-point)) (describe-function sym)))))
    :general
    (evil-nmap
      'emacs-lisp-mode-map
      "C-<down-mouse-1>" #'xref-find-definitions-at-mouse
      "C-<mouse-1>" #'xref-find-definitions-at-mouse
      "<wheel-left>" #'xref-go-back
      "<wheel-right>" #'xref-go-forward)
    (inspect-leader
      "r" #'xref-find-references
      "d" #'xref-find-definitions
      "p" #'xref-go-back
      "n" #'xref-go-forward
      "s" #'xref-find-apropos))
#+end_src
** smart-tabs-mode - Intelligently indent with tabs, align with spaces!
#+begin_src emacs-lisp
  (use-package smart-tabs-mode
    :ensure (smart-tabs-mode :pin melpa)
    :disabled t
    :commands (smart-tabs-mode
               smart-tabs-mode-enable
               smart-tabs-advice
               smart-tabs-insinuate)
    :hook
    ((prog-mode-hook . (lambda ()
                         (smart-tabs-insinuate 'c 'c++)))))
#+end_src
** yasnippet - A template system for Emacs
#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :commands (yas-minor-mode
               yas-reload-all
               yas-expand-snippet
               yas-new-snippet
               yas-insert-snippet
               yas-lookup-snippet
               yas-visit-snippet-file)
    :custom
    (yas-snippet-dirs
     `(,(file-name-as-directory (expand-file-name "snippets" user-emacs-directory))))
    (yas-indent-line 'auto)
    (yas-also-auto-indent-first-line t)
    (yas-also-indent-empty-lines nil)
    (yas-wrap-around-region t)
    (yas-alias-to-yas/prefix-p nil)
    :config
    ;; customizing `yas-snippet-dirs' calls `yas-reload-all' already.
    ;; (yas-reload-all)
    (defun +yas--find-next-field-expand-abbrev-advice (&rest args)
      "Advice which should run before `yas--find-next-field' to expand abbrevs."
      (expand-abbrev))
    (advice-add 'yas--find-next-field :before #'+yas--find-next-field-expand-abbrev-advice)
    :general
    (evil-imap
      'yas-minor-mode-map
      "C-<tab>" #'yas-expand)
    (emacs-map
      'yas-keymap
      "C-<tab>" #'yas-next-field)
    :hook
    (prog-mode-hook . yas-minor-mode)
    (org-mode-hook . yas-minor-mode))
#+end_src
** lsp - Language Server Protocol support for Emacs
#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure (lsp-mode :pin melpa)
    :commands (lsp)
    :custom
    (lsp-keymap-prefix "s-g")
    (lsp-session-file (expand-file-name "lsp-session-v1" user-emacs-cache-directory))
    (lsp-enable-snippet nil)
    (lsp-completion-provider :none)
    :config
    (defun +lsp-find-definition-at-mouse (_click)
      "Click to start `xref-find-definitions-at-mouse' at clicked point."
      (interactive "e")
      (call-interactively #'mouse-set-point)
      (call-interactively #'xref-find-definitions-at-mouse))
    (add-hook 'lsp-mode-hook #'evil-normalize-keymaps)
    :general
    (emacs-map
      'lsp-mode-map
      "C-<down-mouse-1>" #'+lsp-find-definition-at-mouse
      "C-<mouse-1>" #'+lsp-find-definition-at-mouse
      "<wheel-left>" #'xref-go-back
      "<wheel-right>" #'xref-go-forward)
    (inspect-leader
      'lsp-mode-map
      "r" #'lsp-find-references
      "d" #'lsp-find-definition)
    :hook
    ((rustic-mode-hook . lsp)
     (tuareg-mode-hook . lsp)))

  (use-package lsp-lens
    :ensure nil ;; part of lsp-mode
    :delight (lsp-lens-mode))

  (use-package lsp-ui
    :ensure (lsp-ui :pin melpa)
    :custom
    (lsp-ui-peek-enable t)
    (lsp-ui-sideline-enable t)
    (lsp-ui-sideline-show-hover t)
    (lsp-ui-sideline-update-mode 'line)
    (lsp-ui-sideline-delay 1)
    (lsp-ui-doc-enable t)
    (lsp-ui-doc-show-with-cursor nil)
    (lsp-ui-doc-show-with-mouse nil)
    (lsp-ui-doc-position 'at-point))

  (use-package lsp-maybe
    :ensure nil
    :commands (lsp-maybe lsp-maybe-add-predicate))
#+end_src
** ggtags - emacs frontend to GNU Global source code tagging system
#+begin_src emacs-lisp
  (use-package ggtags
    :ensure t
    :delight (ggtags-mode))
#+end_src
** company - Modular text completion framework
#+begin_src emacs-lisp
  (use-package company
    :ensure (company :pin melpa)
    :commands (company-mode)
    :custom
    (company-tooltip-align-annotations t)
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.2) ;; 0.2 should not be noticeable
    (company-show-quick-access 'left)
    (company-quick-access-modifier 'meta)
    (company-quick-access-keys '("1" "2" "3" "4" "5" "6" "7" "8" "9" "0"))
    :init
    (setq tab-always-indent 'complete)
    (defun my/wrap--company-yasnippet--candidates (orig-fun &rest args)
      "Wrapper for `company-yasnippet--candidates'.
  For some reason, the yasnippet backend also provides completion if the prefix
  is empty.  This gives yasnippet completion everytime and makes completion
  often a burden.

  A less hacky way of implementing this would be using a transformer and removing
  all yasnippet candidates if there are more than a certain threshold (using the
  `company-backend' text property), but it is useless work to compute all the
  candidates if they are later dropped."
      (if (and (stringp (car args)) (string-blank-p (car args)))
          nil
        (apply orig-fun args)))
    (defun my/company-backend-with-yas (backends)
      "Add :with company-yasnippet to company BACKENDS.
   Taken from https://github.com/syl20bnr/spacemacs/pull/179."
      (if (and (listp backends) (member 'company-yasnippet backends))
          backends
        (append (if (consp backends)
                    backends
                  (list backends))
                '(:with company-yasnippet))))
    (defun my/company-sort-yas-first (candidates)
      (sort candidates
            (lambda (c1 _c2)
              (equal (get-text-property 0 'company-backend c1) 'company-yasnippet)))
      candidates)
    (defun my/company-abort-insert-tab ()
      (interactive)
      (company-abort)
      (insert ?\t))
    :config
    ;; (setq company-backends (delete 'company-dabbrev company-backends))
    ;; (setq company-backends (delete 'company-bbdb company-backends))
    ;; (setq company-backends (mapcar #'my/company-backend-with-yas company-backends))
    (setq company-backends '((company-capf :with company-yasnippet)
                             (company-dabbrev-code company-keywords company-files)
                             (company-dabbrev)))
    (setq company-transformers '(delete-consecutive-dups
                                 company-sort-prefer-same-case-prefix
                                 company-sort-by-occurrence
                                 my/company-sort-yas-first))
    (advice-add 'company-yasnippet--candidates :around #'my/wrap--company-yasnippet--candidates)
    :general
    (emacs-map
      'company-mode-map
      [remap c-indent-line-or-region] #'company-indent-or-complete-common
      [remap indent-for-tab-command] #'company-indent-or-complete-common)
    (emacs-map
      'company-active-map
      "C-n" #'company-select-next-or-abort
      "C-j" #'company-select-next-or-abort
      "C-p" #'company-select-previous-or-abort
      "C-k" #'company-select-previous-or-abort
      "<return>" nil
      "RET" nil
      "<tab>" #'company-complete-selection
      "<backtab>" #'my/company-abort-insert-tab
      "TAB" #'company-complete-selection)
    (emacs-map
      'company-search-map
      "C-n" #'company-select-next-or-abort
      "C-j" #'company-select-next-or-abort
      "C-p" #'company-select-previous-or-abort
      "C-k" #'company-select-previous-or-abort)
    :hook
    ((emacs-lisp-mode-hook
      sh-mode-hook
      c-mode-common-hook
      c-ts-mode-hook
      c++-ts-mode-hook
      rustic-mode-hook
      rust-ts-mode-hook
      tuareg-mode-hook
      sly-mode-hook
      lsp-mode-hook
      makefile-mode-hook
      yamfile-mode-hook)
     . company-mode))

  (use-package company-dabbrev-code
    :ensure nil ;; packaged with company
    :after (:all company)
    :demand t
    :commands (company-dabbrev-code)
    :custom
    (setq company-dabbrev-code-other-buffers t)
    (setq company-dabbrev-code-everywhere t)
    (setq company-dabbrev-code-ignore-case nil)
    :config
    (add-to-list 'company-dabbrev-code-modes 'sh-mode))

  (use-package company-quickhelp
    :ensure t
    :after (:all company)
    :demand t
    :commands (company-quickhelp-mode
               company-quickhelp-local-mode)
    :custom
    (company-quickhelp-delay 0.2)
    (company-quickhelp-max-lines 40)
    :hook
    (company-mode-hook . company-quickhelp-local-mode))
#+end_src
** flycheck - On-the-fly syntax checking
#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :delight (flycheck-mode)
    :commands (flycheck-mode)
    :functions (flycheck-define-error-level)
    :custom
    (flycheck-check-syntax-automatically '(save idle-change mode-enabled))
    (flycheck-idle-change-delay 2)
    :config
    (define-fringe-bitmap 'flycheck-fringe-bitmap-one-excl
      (vector #b00000000
              #b00000000
              #b00000000
              #b00110000
              #b00110000
              #b00110000
              #b00110000
              #b00110000
              #b00110000
              #b00110000
              #b00110000
              #b00000000
              #b00110000
              #b00110000
              #b00000000
              #b00000000
              #b00000000))
    (define-fringe-bitmap 'flycheck-fringe-bitmap-two-excl
      (vector #b00000000
              #b00000000
              #b00000000
              #b01100110
              #b01100110
              #b01100110
              #b01100110
              #b01100110
              #b01100110
              #b01100110
              #b01100110
              #b00000000
              #b01100110
              #b01100110
              #b00000000
              #b00000000
              #b00000000))

    (flycheck-define-error-level 'error
      :severity 100
      :compilation-level 2
      :overlay-category 'flycheck-error-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-two-excl
      :fringe-face 'flycheck-fringe-error
      :error-list-face 'flycheck-error-list-error)
    (flycheck-define-error-level 'warning
      :severity 10
      :compilation-level 1
      :overlay-category 'flycheck-warning-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-one-excl
      :fringe-face 'flycheck-fringe-warning
      :error-list-face 'flycheck-error-list-warning)
    (flycheck-define-error-level 'info
      :severity -10
      :compilation-level 0
      :overlay-category 'flycheck-info-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-one-excl
      :fringe-face 'flycheck-fringe-info
      :error-list-face 'flycheck-error-list-info)
    (add-to-list 'flycheck-checkers 'mail-aspell-dynamic)
    :hook
    ((lsp-mode-hook . flycheck-mode)
     (emacs-lisp-mode-hook . flycheck-mode)
     (sh-mode-hook . flycheck-mode)
     (org-src-mode-hook . (lambda ()
                            (setq-local flycheck-disabled-checkers
                                        '(emacs-lisp-checkdoc))))
     (message-mode-hook . flycheck-mode)))

  (use-package flycheck-popup-tip
    :ensure t
    :after (:all flycheck)
    :demand t
    :commands (flycheck-popup-tip-mode)
    :custom
    ;; 27a4 â¤ 2b9e â®
    (flycheck-popup-tip-error-prefix "> ")
    :hook
    (flycheck-mode-hook . flycheck-popup-tip-mode))
#+end_src
** flycheck-aspell - Aspell checker for flycheck
#+begin_src emacs-lisp
  (use-package flycheck-aspell
    :ensure t
    :after (:all flycheck)
    :demand t)
#+end_src
** next-error [built-in]
#+begin_src emacs-lisp
  (use-package simple
    :ensure nil
    :demand t
    :custom
    (next-error-recenter '(4))
    :general
    (buffer-local-leader
      "e n" #'next-error
      "e p" #'previous-error
      "e b" #'next-error-select-buffer))
#+end_src
** gdb-mi [built-in] - User Interface for running GDB
#+begin_src emacs-lisp
  (use-package gdb-mi
    :ensure nil)
#+end_src
* Programming languages
** C/C++
#+begin_src emacs-lisp
  (use-package cc-mode ;; built-in
    :ensure nil
    :config
    (defun my/c-mark-block ()
      "Put mark at end of current statement, point at beginning."
      (interactive)
      (let ((start (progn
                     (call-interactively #'backward-up-list)
                     (point)))
            (end (progn
                   (call-interactively #'forward-list)
                   (point))))
        (goto-char start)
        (push-mark end)
        (setq mark-active t)))
    (defun lsp-maybe-active-if-compile-commands-in-projectile-root ()
      "Enable `lsp' if the project root contains `compile_commands.json'.
  The project root is found using `projectile-project-root'."
      (let ((project-root (projectile-project-root)))
        (if (not project-root)
            t
          (file-exists-p (expand-file-name "compile_commands.json" project-root)))))
    (defun +c-mode-setup ()
      (lsp-maybe)
      (setq-local indent-tabs-mode nil)
      (modify-syntax-entry ?_ "w"))
    (lsp-maybe-add-predicate 'c-mode #'lsp-maybe-active-if-compile-commands-in-projectile-root)
    :general
    (mode-action-leader
      'c-mode-base-map
      "." #'c-set-style
      ";" #'comment-dwim
      "c" #'projectile-compile-project
      "h" #'ff-find-other-file)
    (mode-action-leader
      'c-mode-map)
    (mode-action-leader
      'c++-mode-map)
    (emacs-map
      'c-mode-map
      "M-h" #'my/c-mark-block
      "C-M-h" #'c-mark-function)
    :hook
    (c-mode-common-hook . +c-mode-setup)
    (c-mode-hook . +c-mode-setup)
    (c++-mode-hook . +c-mode-setup))

  (use-package c-ts-mode ;; built-in
    :ensure nil
    :disabled t
    :if (version< "29.0" emacs-version)
    :init
    (add-to-list 'major-mode-remap-alist '(c-mode . c-ts-mode))
    (add-to-list 'major-mode-remap-alist '(c++-mode . c++-ts-mode))
    :config
    (defun +c-ts-mode-setup ()
      (lsp-maybe)
      (setq-local indent-tabs-mode nil)
      (modify-syntax-entry ?_ "w"))
    (lsp-maybe-add-predicate 'c-ts-mode #'lsp-maybe-active-if-compile-commands-in-projectile-root)
    :hook
    (c-ts-mode-hook . +c-ts-mode-setup)
    (c++-ts-mode-hook . +c-ts-mode-setup))

  (defconst openjdk-cc-style
    `((c-recognize-knr-p . nil)
      (c-enable-xemacs-performance-kludge-p . t)
      (c-basic-offset . 2)
      (indent-tabs-mode . nil)
      (c-comment-only-line-offset . 0)
      (c-hanging-braces-alist . ((defun-open after)
                                 (defun-close before after)
                                 (class-open after)
                                 (class-close before after)
                                 (inexpr-class-open after)
                                 (inexpr-class-close before)
                                 (namespace-open after)
                                 (inline-open after)
                                 (inline-close before after)
                                 (block-open after)
                                 (block-close . c-snug-do-while)
                                 (extern-lang-open after)
                                 (extern-lang-close after)
                                 (statement-case-open after)
                                 (substatement-open after)))
      (c-hanging-colons-alist . ((case-label)
                                 (label after)
                                 (access-label after)
                                 (member-init-intro before)
                                 (inher-intro)))
      (c-hanging-semi&comma-criteria
       . (c-semi&comma-no-newlines-for-oneline-inliners
          c-semi&comma-inside-parenlist
          c-semi&comma-no-newlines-before-nonblanks))
      (c-indent-comments-syntactically-p . t)
      (comment-column . 40)
      (c-indent-comment-alist . ((other . (space . 2))))
      (c-cleanup-list . (brace-else-brace
                         brace-elseif-brace
                         brace-catch-brace
                         empty-defun-braces
                         defun-close-semi
                         list-close-comma
                         scope-operator))
      (c-offsets-alist . ((arglist-intro google-c-lineup-expression-plus-4)
                          (func-decl-cont . ++)
                          (member-init-intro . ++)
                          (inher-intro . ++)
                          (comment-intro . 0)
                          (arglist-close . c-lineup-arglist)
                          (topmost-intro . 0)
                          (block-open . 0)
                          (inline-open . 0)
                          (substatement-open . 0)
                          (statement-cont
                           .
                           (,(when (fboundp 'c-no-indent-after-java-annotations)
                               'c-no-indent-after-java-annotations)
                            ,(when (fboundp 'c-lineup-assignments)
                               'c-lineup-assignments)
                            ++))
                          (label . /)
                          (case-label . +)
                          (statement-case-open . +)
                          (statement-case-intro . +) ; case w/o {
                          (access-label . /)
                          (innamespace . 0))))
    "OpenJDK C/C++ Programming Style.")

  (c-add-style "OpenJDK" openjdk-cc-style nil)
#+end_src
** Rust
#+begin_src emacs-lisp
  (use-package rustic
    :ensure (rustic :pin melpa)
    :custom
    (rustic-analyzer-command '("rustup" "run" "stable" "rust-analyzer")))

  (setq mouse-wheel-scroll-amount '(3 ((shift) . 1) ((control) . nil)))
  (setq mouse-wheel-progressive-speed nil)
#+end_src
** Emacs-lisp
#+begin_src emacs-lisp
  (use-package elisp-mode
    :ensure nil
    :commands (emacs-lisp-mode)
    :config
    (defun +eval-buffer-force ()
      "Execute the current buffer as Lisp code.
  Top-level forms are evaluated with `eval-defun' so that `defvar'
  and `defcustom' forms reset their default values."
      (interactive)
      (save-excursion
        (goto-char (point-min))
        (while (not (eobp))
          (forward-sexp)
          (eval-defun nil))))
    (defun +emacs-lisp-mode-setup ()
      (setq-local indent-tabs-mode t)
      (setq-local fill-column 80)
      (setq-local show-trailing-whitespace t)
      (modify-syntax-entry ?- "w"))
    :general
    (mode-action-leader
      'emacs-lisp-mode-map
      "f" '(+indent-buffer :no-autoload t)
      "c" #'emacs-lisp-byte-compile-and-load
      "C" #'emacs-lisp-native-compile-and-load
      "e e" #'eval-last-sexp
      "e E" #'pp-eval-last-sexp
      "e b" #'eval-buffer
      "e B" #'+eval-buffer-force
      "e d" #'eval-defun
      "e p" #'eval-print-last-sexp)
    :hook
    (emacs-lisp-mode-hook . +emacs-lisp-mode-setup))

  (use-package pp
    :ensure nil)

  (use-package eldoc
    :ensure nil
    :delight (eldoc-mode
              global-eldoc-mode)
    :hook
    (emacs-lisp-mode-hook . eldoc-mode))
#+end_src
** Ocaml
#+begin_src emacs-lisp
  (use-package tuareg
    :ensure t
    :init
    (add-to-list 'safe-local-variable-values '(eval projectile-project-compilation-cmd))
    :config
    (add-hook 'tuareg-mode-hook #'electric-pair-local-mode)
    (setq auto-mode-alist
          (append '(("\\.ml[ily]?$" . tuareg-mode)
                    ("\\.topml$" . tuareg-mode))
                  auto-mode-alist))
    :hook
    (tuareg-mode-hook . utop-minor-mode))

  (use-package utop
    :ensure t
    :commands (utop-minor-mode)
    :config
    (autoload 'utop-minor-mode "utop" "Minor mode for utop" t)
    (setq utop-command "opam config exec -- dune utop . -- -emacs")
    :general
    (emacs-map
      [remap tuareg-eval-phrase] #'utop-eval-phrase
      [remap tuareg-eval-buffer] #'utop-eval-buffer
      [remap tuareg-eval-region] #'utop-eval-region))

  (use-package dune
    :ensure t)
#+end_src
** Common lisp
#+begin_src emacs-lisp
  (use-package lisp-mode
    :ensure nil
    :commands (lisp-mode lisp-data-mode)
    :config
    (defun +lisp-mode-setup ()
      (setq-local fill-column 100)
      (setq-local show-trailing-whitespace t)
      (indent-tabs-mode 0)
      (modify-syntax-entry ?- "w"))
    (font-lock-add-keywords 'lisp-mode '(("(\\(\\(?:generator-lambda\\)\\|\\(?:deftest\\)\\|\\(?:testing\\)\\)" 1 font-lock-keyword-face)))
    :hook
    (lisp-mode-hook . +lisp-mode-setup)
    (lisp-data-mode-hook . +lisp-mode-setup))
#+end_src
#+begin_src emacs-lisp
  (use-package sly
    :ensure t
    :commands (sly sly-mode)
    :custom
    (sly-kill-without-query-p t)
    (sly-net-coding-system 'utf-8-unix)
    (sly-complete-symbol-function #'sly-simple-completions)
    (sly-default-lisp 'sbcl)
    :config
    (setq sly-lisp-implementations '((sbcl ("/usr/bin/sbcl"))
                                     (clisp ("/usr/bin/clisp"))
                                     (cmucl ("/usr/bin/cmucl"))
                                     (ccl ("/usr/bin/ccl"))
                                     (ecl ("/usr/bin/ecl"))
                                     (clasp ("/usr/bin/clasp"))
                                     (abcl ("/usr/bin/abcl"))
                                     (goingto ("/home/chris/dev/goingto/goingto" "toplevel"))))
    (defun sly-apropos-next-symbol ()
      "Move cursor down to the next symbol in an `sly-apropos-mode' buffer."
      (interactive nil sly-apropos-mode)
      (forward-line)
      (while (and (not (eq (get-text-property (point) 'face) 'sly-apropos-symbol))
                  (< (point) (point-max)))
        (forward-line)))
    (defun sly-apropos-previous-symbol ()
      "Move cursor back to the last symbol in an `sly-apropos-mode' buffer."
      (interactive nil sly-apropos-mode)
      (forward-line -1)
      (while (and (not (eq (get-text-property (point) 'face) 'sly-apropos-symbol))
                  (> (point) (point-min)))
        (forward-line -1)))
    :general
    (mode-action-leader
      'sly-mode-map
      "." #'sly-edit-definition
      "," #'sly-edit-uses
      "~" #'sly-mrepl-sync
      "f" '(+indent-buffer :no-autoload t)
      "e e" #'sly-eval-last-expression
      "e E" #'sly-macroexpand-1
      "e b" #'sly-eval-buffer
      "e d" #'sly-eval-defun
      "e p" #'sly-eval-print-last-expression
      "e i" #'sly-inspect
      "d ." #'sly-describe-symbol
      "d a" #'sly-apropos-all
      "d h" #'sly-hyperspec-lookup)
    (emacs-map 'sly-mode-map
      "C-c C-d ." #'sly-describe-symbol
      "C-c C-d C-." #'sly-describe-symbol)
    (emacs-map 'sly-apropos-mode-map
      "n" #'sly-apropos-next-symbol
      "p" #'sly-apropos-previous-symbol)
    (emacs-map 'sly-inspector-mode-map
      "?" #'describe-mode
      "SPC" #'scroll-up-command
      "S-SPC" #'scroll-down-command
      "DEL" #'scroll-down-command
      "TAB" #'forward-button
      "<backtab>" #'backward-button
      "C-M-i" #'backward-button
      "C-c C-c" #'sly-button-inspect
      "r" #'sly-inspector-next
      "l" #'sly-inspector-pop
      "C-c C-f" #'sly-inspector-next
      "C-c C-b" #'sly-inspector-pop
      "<wheel-left>" #'sly-inspector-pop
      "<wheel-right>" #'sly-inspector-next
      "<mouse-8>" #'sly-inspector-pop
      "<mouse-9>" #'sly-inspector-next)
    (evil-imap 'sly-mrepl-mode-map
      "<up>" #'sly-mrepl-previous-input-or-button
      "<down>" #'sly-mrepl-next-input-or-button))

  (use-package sly-cl-indent
    :ensure nil ;; part of sly
    :defer t ;; will be loaded with sly
    :demand nil
    :config
    (put 'deftest 'sly-common-lisp-indent-function '(&lambda &rest sly--lisp-indent-function-lambda-hack))
    (put 'testing 'sly-common-lisp-indent-function '(&lambda &rest sly--lisp-indent-function-lambda-hack))
    (put 'generator-lambda 'sly-common-lisp-indent-function '(&lambda &rest sly--lisp-indent-function-lambda-hack)))
#+end_src
** Shell
The shell mode is built-in.
Flycheck can use ~shellcheck~ out of the box.
The ~company-shell~ package provides completion for CLI utilities and environment variables,
but not for variables or functions defined in the shell file.
Use ~company-dabbrev-code~ for now, until another tool is found.
#+begin_src emacs-lisp
  (use-package sh-script
    :ensure nil
    :commands (sh-mode)
    :init
    (defun +sh-mode-setup ()
      (setq-local tab-width 4)
      (setq-local indent-tabs-mode nil)
      (setq-local fill-column 132)
      (setq-local show-trailing-whitespace t)
      (setq-local company-dabbrev-minimum-length 2)
      (setq-local company-dabbrev-code-everywhere t)
      (setq-local company-dabbrev-code-other-buffers t)
      (setq-local company-backends '((company-dabbrev-code :with company-yasnippet company-shell company-shell-env)
                                     (company-shell company-shell-env :with company-yasnippet))))
    (setq sh-basic-offset 4)
    :general
    (emacs-map'sh-mode-map
     "C-c (" nil
     "C-c +" nil
     "C-c :" nil
     "C-c C-\\" nil
     "C-c TAB" nil
     "C-c C-l" nil
     "C-c C-r" nil
     "C-c C-c" nil
     "C-c C-f" nil
     "C-c C-n" nil
     "C-c C-o" nil
     "C-c C-s" nil
     "C-c C-t" nil
     "C-c C-u" nil
     "C-c C-w" nil
     "C-c C-x" nil
     "C-c C-z" nil)
    :hook
    (sh-mode-hook . +sh-mode-setup))

  (use-package company-shell
    :ensure t
    :init
    (setq company-shell-delete-duplicates t)
    (setq company-shell-use-help-arg nil))
#+end_src
** Python
#+begin_src emacs-lisp
  (use-package python
    :ensure nil
    :defer t
    :init
    (defun +python-mode-setup ()
      (setq-local fill-column 80))
    :hook
    (python-mode-hook . +python-mode-setup))

  (use-package elpy
    :ensure t
    :defer t
    :commands (elpy-enable elpy-config elpy-rpc-reinstall-virtualenv)
    :init
    (advice-add 'python-mode :before 'elpy-enable)
    :config
    (setq elpy-rpc-virtualenv-path 'default)
    (setq elpy-rpc-python-command "python3")
    (setq elpy-rpc-ignored-buffer-size (* 1024 1024)) ;; Some projects are nuts
    (setq elpy-modules (delq 'elpy-module-yasnippet elpy-modules)))
#+end_src
** Groovy
#+begin_src emacs-lisp
  (use-package groovy-mode
    :ensure t)
#+end_src
** FASM
#+begin_src emacs-lisp
  (use-package fasm-mode
    :ensure nil
    :mode (("\\.[Aa][Ss][Mm]\\'" . fasm-mode))
    :commands (fasm-mode)
    :config
    (defun +fasm-mode-setup ()
      (setq-local fasm-basic-offset 8)
      (setq-local tab-width 8)
      (setq-local indent-tabs-mode t)
      (setq-local fill-column 88))
    :general
    (emacs-map
      'fasm-mode-map
      "TAB" '(self-insert-command :no-autoload t))
    :hook
    (fasm-mode-hook . +fasm-mode-setup))
#+end_src
** jenkinsfile-mode
#+begin_src emacs-lisp
  (use-package jenkinsfile-mode
    :ensure t
    :after (:all groovy-mode))
#+end_src
** make-mode [built-in]
#+begin_src emacs-lisp
  (use-package make-mode
    :ensure nil
    :commands (makefile-mode)
    :functions (+makefile-mode-setup)
    :config
    (defun +makefile-join-line (&optional arg beg end)
      "Join this line to previous in a makefile specific way.
  With prefix ARG, join the current line to the following line.
  When BEG and END are non-nil, join all lines in the region they
  define.  Interactively, BEG and END are, respectively, the start
  and end of the region if it is active, else nil.  (The region is
  ignored if prefix ARG is given.)"
      (interactive
       (progn (barf-if-buffer-read-only)
              (cons current-prefix-arg
                    (and (use-region-p)
                         (list (region-beginning) (region-end))))))
      ;; Consistently deactivate mark even when no text is changed.
      (setq deactivate-mark t)
      (if (and beg (not arg))
          ;; Region is active.  Go to END, but only if region spans
          ;; multiple lines.
          (and (goto-char beg)
               (> end (line-end-position))
               (goto-char end))
        ;; Region is inactive.  Set a loop sentinel
        ;; (subtracting 1 in order to compare less than BOB).
        (setq beg (1- (line-beginning-position (and arg 2))))
        (when arg (forward-line)))
      (let ((prefix (and (> (length fill-prefix) 0)
                         (regexp-quote fill-prefix))))
        (while (and (> (line-beginning-position) beg)
                    (forward-line 0)
                    (= (preceding-char) ?\n))
          (delete-char -1)
          ;; If the appended line started with the fill prefix,
          ;; delete the prefix.
          (if (and prefix (looking-at prefix))
              (replace-match "" t t))
          ;; Additional fixes for makefile specific line joining.
          (cond
           ;; If two .PHONY: targets are joined, remove the target and make it
           ;; a single one
           ((and (looking-at "\\.PHONY:")
                 (string-prefix-p ".PHONY:" (buffer-substring-no-properties
                                             (line-beginning-position)
                                             (line-end-position))))
            (delete-char 7))
           ;; If lines have been splitted, remove the backslash of the end of
           ;; the previous line
           ((looking-back "\\\\" 1)
            (delete-char -1))
           ;; If two comment lines have been joined, remove the pound symbol
           ((and (nth 4 (syntax-ppss))
                 (looking-at "#"))
            (delete-char 1)))
          (fixup-whitespace))))
    (defun +makefile-mode-setup ()
      (setq-local tab-width 8)
      (setq-local indent-tabs-mode t)
      (setq-local fill-column 132)
      (setq-local show-trailing-whitespace t)
      (setq-local makefile-space 'trailing-whitespace)
      (makefile-pickup-everything t))
    (with-eval-after-load 'evil
      (evil-define-operator +evil-makefile-join (beg end)
        "Join the selected lines in a makefile specific way."
        :motion evil-line
        (let ((count (count-lines beg end)))
          (when (> count 1)
            (setq count (1- count)))
          (goto-char beg)
          (dotimes (_ count)
            (+makefile-join-line 1)))))
    :general
    (emacs-map
      'makefile-mode-map
      "C-c C-c" '(comment-dwim :no-autoload t))
    (evil-nmap
      'makefile-mode-map
      "J" #'+evil-makefile-join)
    (evil-nmmap
      'makefile-mode-map
      "[[" #'makefile-previous-dependency
      "]]" #'makefile-next-dependency)
    :hook
    (makefile-mode-hook . +makefile-mode-setup)
    (after-save-hook . (lambda () (when (derived-mode-p 'makefile-mode)
                                    (makefile-pickup-everything t)))))
#+end_src
** yamfile-mode
#+begin_src emacs-lisp
  (use-package yamfile-mode
    :ensure nil
    :commands (yamfile-mode)
    :config
    (defun +yamfile-mode-setup ()
      (yamfile-mode-pickup-macros))
    :general
    (evil-nmmap
      'yamfile-mode-map
      "[[" #'yamfile-mode-previous-dependency
      "]]" #'yamfile-mode-next-dependency)
    :mode (("\\(?:/\\|\\`\\)[Yy]amfile\\'\\|\\.yam\\'" . yamfile-mode))
    :hook
    (yamfile-mode-hook . +yamfile-mode-setup)
    (after-save-hook . (lambda () (when (derived-mode-p 'yamfile-mode)
                                    (yamfile-mode-pickup-macros)))))
#+end_src
* Markup languages
** Outline Mode
#+begin_src emacs-lisp
  (use-package outline-mode
    :ensure nil
    :commands (outline-mode
               outline-minor-mode)
    :hook
    (outline-mode-hook . (lambda ()
                           ;; Check if the mode is realy outline-mode.
                           ;; Some major modes derive from outline-mode.
                           (when (eq major-mode 'outline-mode)
                             (font-lock-mode -1)
                             (display-line-numbers-mode -1)))))
#+end_src
** Org Mode
#+begin_src emacs-lisp
  (use-package org
    :ensure nil
    :commands (org-mode)
    :delight (org-src-mode)
    :custom
    (org-directory "~/Documents/org")
    (org-imenu-depth 7)
    (org-adapt-indentation nil)
    (org-agenda-files '("~/Documents/org"))
    (org-agenda-span 14)
    (org-agenda-start-on-weekday 1)
    (org-id-locations-file (expand-file-name "org-id-locations" user-emacs-cache-directory))
    :config
    ;; code blocks languages
    (org-babel-do-load-languages
     'org-babel-load-languages '((emacs-lisp . t)
                                 (shell . t)
                                 (python . t)
                                 (perl . t)))
    :general
    (emacs-map
      'org-mode-map
      "C-c a" #'org-agenda
      "C-c ." #'org-time-stamp
      "C-c C-." #'org-time-stamp-inactive)
    (emacs-map
      'org-src-mode-map
      "C-c C-c" #'org-edit-src-exit)
    (mode-action-leader
      'org-mode-map
      "'" #'org-edit-special
      "c i" #'org-clock-in
      "c o" #'org-clock-out
      "c g" #'org-clock-goto
      "c q" #'org-clock-cancel
      "c d" #'org-clock-display
      "c r" #'org-clock-remove-overlays)
    :hook
    (org-mode-hook . (lambda () (indent-tabs-mode 0))))

  (use-package org-src
    :ensure nil
    :after (:all org)
    :commands (org-src-mode)
    :general
    (emacs-map
      'org-src-mode-map
      "C-c s" #'org-edit-src-save
      "C-c c" #'org-edit-src-exit
      "C-c k" #'org-edit-src-abort))

  (use-package org-superstar
    :ensure t
    :after (:all org)
    :delight (org-superstar-mode)
    :commands (org-superstar-mode)
    :custom
    (org-superstar-remove-leading-stars t)
    (org-superstar-headline-bullets-list  '("â" "â" "â¸" "â¿" "â¼" "â¬"))
    :hook
    (org-mode-hook . org-superstar-mode))
#+end_src
** Markdown
#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :commands (markdown-mode)
    :custom
    (markdown-command "multimarkdown"))
#+end_src
** TOML
#+begin_src emacs-lisp
  (use-package toml-mode
    :ensure t
    :mode (("\\.toml\\'" . toml-mode))
    :commands (toml-mode))
#+end_src
** YAML
#+begin_src emacs-lisp
  (use-package yaml-mode
    :ensure t
    :mode (("\\.yml\\'" . yaml-mode)
           ("\\.yaml\\'" . yaml-mode))
    :commands (yaml-mode))
#+end_src
** JSON
#+begin_src emacs-lisp
  (use-package json-mode
    :ensure t
    :mode (("\\.json\\'" . json-mode))
    :commands (json-mode))
#+end_src
* Configuration files
** git-modes
#+begin_src emacs-lisp
  (use-package git-modes
    :ensure t
    :commands (gitattributes-mode gitconfig-mode gitignore-mode))
#+end_src
** xmodmap
#+begin_src emacs-lisp
  (use-package xmodmap-mode
    :ensure nil
    :mode (("\\.Xmodmap\\'" . xmodmap-mode))
    :commands (xmodmap-mode))
#+end_src
** i3wm-config
#+begin_src emacs-lisp
  (use-package i3wm-config-mode
    :ensure t
    :commands (i3wm-config-mode))
#+end_src
* Tools
** calc [built-in] - The GNU Emacs calculator
#+begin_src emacs-lisp
  (use-package calc
    :ensure nil
    :commands (calc
               full-calc)
    :config
    (defun +calc-mode-setup ()
      (when (fboundp 'undo-tree-mode) (undo-tree-mode -1)))
    :general
    (evil-nmmap
      :keymaps 'calc-mode-map
      [remap evil-redo] #'calc-redo)
    :hook
    (calc-mode-hook . +calc-mode-setup))
#+end_src
** ispell [built-in] - Interface to spell checkers
#+begin_src emacs-lisp
  (use-package ispell
    :ensure nil
    :commands (ispell)
    :custom
    (ispell-dictionary "en_US"))
#+end_src
** vc [built-in] - drive a version-control system from within Emacs
#+begin_src emacs-lisp
  (use-package vc
    :ensure nil
    :custom
    (vc-handled-backends '(Git)))
#+end_src
** Magit - A Git Porcelain inside Emacs
#+begin_src emacs-lisp
  (use-package magit
    :ensure (magit :pin melpa)
    :commands (magit-status
               magit-commit
               magit-load-config-extensions
               magit-process-git
               magit-blame
               magit-log)
    :functions (magit-restore-window-configuration
                magit-mode-get-buffers)
    :config
    (defun +kill-magit-buffers ()
      "Kill all magit buffers and restore the window configuration."
      (interactive)
      (magit-restore-window-configuration)
      (mapc #'kill-buffer (magit-mode-get-buffers)))
    :general
    (c-x-leader
      "g h" #'magit-info
      "g g" #'magit-status
      "g G" #'magit-status-quick
      "g s" #'magit-show-commit
      "g l" #'magit-log
      "g d" #'magit-diff-buffer-file
      "g c" #'magit-commit
      "g f" #'magit-fetch
      "g p" #'magit-push
      "g m" #'magit-merge
      "g b" #'magit-blame
      "g z" #'magit-stash
      "g v" #'magit-generate-changelog
      "g !" #'magit-shell-command
      "g U" #'magit-run-git-gui)
    (emacs-map
      "C-x g" nil)
    (evil-emap
      "C-x g" #'magit-status)
    (evil-nmap
      'magit-status-mode-map
      "J" #'magit-section-forward
      "K" #'magit-section-backward
      "[ [" #'magit-section-backward-sibling
      "] ]" #'magit-section-forward-sibling)
    (emacs-map 'magit-section-mode-map
      "M-1" nil
      "M-2" nil
      "M-3" nil
      "M-4" nil)
    (emacs-map 'magit-mode-map
      "DEL" nil)
    (emacs-map 'magit-diff-mode-map
      "DEL" nil)
    (emacs-map 'git-rebase-mode-map
      "DEL" nil)
    (emacs-map 'magit-blame-read-only-mode-map
      "DEL" nil
      "SPC" nil
      "S-SPC" nil
      "p" nil
      "P" nil
      "n" nil
      "N" nil
      "b" nil
      "r" nil
      "f" nil
      "B" nil
      "c" nil
      "q" nil
      "M-w" nil)
    (evil-nmap
      'magit-blame-read-only-mode-map
      "u" #'evil-scroll-up
      "d" #'evil-scroll-down
      "c" #'magit-blame-cycle-style
      "q" #'magit-blame-quit
      "s" #'magit-show-commit
      "gk" #'magit-blame-previous-chunk
      "gK" #'magit-blame-previous-chunk-same-commit
      "gj" #'magit-blame-next-chunk
      "gJ" #'magit-blame-next-chunk-same-commit)
    :hook
    (magit-mode-hook . magit-load-config-extensions))

  (use-package magit-autorevert ;; part of magit
    :ensure nil
    :commands (magit-auto-revert-mode)
    :hook
    (emacs-startup-hook . magit-auto-revert-mode))

  (use-package git-commit ;; part of magit
    :ensure nil
    :commands (git-commit-turn-on-flyspell)
    :custom
    (git-commit-summary-max-length 72)
    :general
    (emacs-map 'git-commit-mode-map
      "C-c c" #'with-editor-finish
      "C-c k" #'with-editor-cancel)
    :hook
    (git-commit-setup-hook . (lambda ()
                               (setq-local fill-column 72)
                               (git-commit-turn-on-flyspell)
                               (when (fboundp 'evil-insert-state)
                                 (evil-insert-state)))))

  (use-package git-rebase ;; part of magit
    :ensure nil
    :general
    (emacs-map
      'git-rebase-mode-map
      "C-k" #'git-rebase-move-line-up
      "C-j" #'git-rebase-move-line-down))
#+end_src
** spray - A speed reading mode for Emacs
#+begin_src emacs-lisp
  (use-package spray
    :ensure t
    :commands (spray-mode)
    :custom
    (spray-wpm 375 "Words per minute")
    (spray-height 400 "Height of characters")
    (spray-margin-top 1 "Character margin at top of buffer")
    (spray-margin-left 1 "Character margin at left of buffer")
    (spray-ramp 3 "Initial words before ramping up to full speed")
    :general
    (emacs-map
      "<f6>" #'spray-mode)
    (emacs-map
      'spray-mode-map
      "SPC" #'spray-start/stop
      "h" #'spray-backward-word
      "<left>" #'spray-backward-word
      "l" #'spray-forward-word
      "<right>" #'spray-forward-word
      "f" #'spray-faster
      "s" #'spray-slower
      "q" #'spray-quit
      "RET" #'spray-quit
      "<return>" #'spray-quit))
#+end_src
** system-packages - functions to manage system packages
#+begin_src emacs-lisp
  (use-package system-packages
    :ensure t)
#+end_src
* Directory-local variables
#+begin_src emacs-lisp
  (dir-locals-set-class-variables
   'work-projects
   '((c-mode . ((fill-column . 80)
                (c-file-style . "linux")
                (indent-tabs-mode . t)
                (c-basic-offset . 8)))
     (c-ts-mode . ((fill-column . 80)
                   (c-file-style . "linux")
                   (indent-tabs-mode . t)
                   (c-basic-offset . 8)
                   (c-ts-mode-indent-offset . 8)
                   (c-ts-mode-indent-style . 'linux)))))
  (dir-locals-set-directory-class
   "/loc" 'work-projects)
#+end_src
* Postface
#+begin_src emacs-lisp
  ;; The functions in `after-make-frame-functions' are not run for the initial frame.
  ;; So let's do that after emacs started.
  (add-hook 'emacs-startup-hook #'(lambda ()
                                    (mapc #'(lambda (callback)
                                              (apply callback '(nil)))
                                          after-make-frame-functions)))
  ;; Local Variables:
  ;; indent-tabs-mode: nil
  ;; End:

  ;;; settings.el ends here
#+end_src
* Using local build of Emacs
Install dependencies:
#+begin_src sh
  # pacman -Syu $(pacman -Si emacs-nativecomp |grep 'Depends On' |awk '{for(i=4;i<=NF;++i)print $i}')
#+end_src
Build with a prefix of /opt/emacs. Need to create a .desktop file in ~/.local/share/applications.
#+begin_src sh
  $ git clean -xdf
  $ git pull
  $ bash autogen.sh
  $ emacs -nw -q --batch --eval '(message "%s" system-configuration-options)' 2>&1 |xargs bash configure
  # --with-cairo --with-harfbuzz --with-modules --with-x-toolkit=gtk3 --with-xft --with-sound=alsa --with-imagemagick --with-json --with-mailutils --with-tree-sitter --with-small-ja-dic --without-compress-install --with-native-compilation=aot --prefix=/opt/emacs 'CFLAGS=-mtune=native -march=native -O2 -g3 -pipe -fomit-frame-pointer --param=ssp-buffer-size=4 -fno-plt' CPPFLAGS=-D_FORTIFY_SOURCE=2 LDFLAGS=-Wl,--sort-common,--as-needed,-z,relro,-z,now
  $ make NATIVE_FULL_AOT=1 -j16
  $ sudo make install
#+end_src
