#+TITLE: Emacs configuration in org-mode
#+AUTHOR: Christoph Göttschkes
#+EMAIL: just.mychris@googlemail.com
#+STARTUP: showeverything

* Configuration dependencies
To please the compiler, we need to require all the dependencies the settings have, which are not loaded using use-package, or are needed by use-package.
This is mostly use-package and local utilities which are used throught the configuration or are configured to be used interactively.
#+begin_src emacs-lisp
  ;;; settings.el --- personal configuration           -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Generated from `settings.org' in `init.el'.
  ;;; Code:
  (eval-when-compile
    (require 'use-package))
  (require 'diminish)
  (require 'bind-key)
  (require 'my-utils)
#+end_src
* Miscellaneous settings
** General Emacs configuration
#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :demand
    :init
    (global-hl-line-mode 1) ;; highlight the line in all windows
    (setq large-file-warning-threshold (* 100 1000 1000))
    (setq frame-title-format
          '("Emacs - "
            (:eval (if (buffer-file-name)
                       (abbreviate-file-name (buffer-file-name))
                     "%b"))
            (:eval (when (buffer-modified-p)
                       " ↯"))))
    (setq echo-keystrokes 0)        ;; use the which-key package
    (setq visible-bell t)
    (setq initial-major-mode 'text-mode)
    (defalias 'yes-or-no-p 'y-or-n-p)
    (put 'narrow-to-region 'disabled nil)
    (put 'upcase-region 'disabled nil)
    (put 'downcase-region 'disabled nil)
    (put 'dired-find-alternate-file 'disabled nil)
    (put 'overwrite-mode 'disabled t)
    (global-unset-key (kbd "C-z")) ;; Use C-z as a prefix key.
    (global-unset-key (kbd "<help>"))
    (global-unset-key (kbd "C-h <help>"))
    (global-unset-key (kbd "<f1> <help>"))
    (global-unset-key (kbd "<find>"))
    (global-unset-key (kbd "<open>"))
    (global-unset-key (kbd "<clear>"))
    (global-unset-key (kbd "<f16>"))
    (global-unset-key (kbd "<f18>"))
    (global-unset-key (kbd "<f20>"))
    (global-unset-key (kbd "C-x C-z"))
    (global-unset-key (kbd "C-h g")) ;; Who needs that?
    (global-unset-key (kbd "<f1> g"))
    (global-unset-key (kbd "C-h n"))
    (global-unset-key (kbd "C-h C-n"))
    (global-unset-key (kbd "<f1> n"))
    (global-unset-key (kbd "<f1> C-n"))
    (global-unset-key (kbd "<f1> 4 i"))
    (global-unset-key (kbd "C-h 4 i"))
    (global-unset-key (kbd "M-`")) ;; tmm-menubar
    (global-unset-key (kbd "<f10>")) ;; menu-bar-open
    (global-unset-key (kbd "C-<f10>")) ;; buffer-menu-open
    (global-unset-key (kbd "C-x i")) ;; insert-file
    (global-unset-key (kbd "M-<"))
    (global-set-key (kbd "M-C-{") #'beginning-of-buffer)
    (global-unset-key (kbd "M->"))
    (global-set-key (kbd "M-C-}") #'end-of-buffer)
    )

  (use-package emacs
    :ensure nil
    :demand
    :init
    (global-unset-key (kbd "<up>"))
    (global-unset-key (kbd "C-<up>"))
    (global-unset-key (kbd "M-<up>"))
    (global-unset-key (kbd "C-M-<up>"))
    (global-unset-key (kbd "<down>"))
    (global-unset-key (kbd "C-<down>"))
    (global-unset-key (kbd "M-<down>"))
    (global-unset-key (kbd "C-M-<down>"))
    (global-unset-key (kbd "<left>"))
    (global-unset-key (kbd "C-<left>"))
    (global-unset-key (kbd "M-<left>"))
    (global-unset-key (kbd "C-M-<left>"))
    (global-unset-key (kbd "<right>"))
    (global-unset-key (kbd "<C-right>"))
    (global-unset-key (kbd "<M-right>"))
    (global-unset-key (kbd "<C-M-right>"))
    )
  
#+end_src
** nsm.el [built-in] - Network Security Manager
#+begin_src emacs-lisp
  (use-package nsm
    :ensure nil
    :demand
    :custom
    (nsm-settings-file (expand-file-name "network-security.data" user-emacs-cache-directory))
    (network-security-level 'high))
#+end_src
** Emacs server and desktop
#+begin_src emacs-lisp
  (use-package server
    :ensure nil
    :commands (server-start)
    :init
    (run-with-idle-timer 5 nil (lambda ()
                                 (when (not (display-graphic-p))
                                   (server-start)))))

  (use-package desktop
    :ensure nil
    :init
    (setq-default desktop-auto-save-timeout 300)
    (setq-default desktop-dirname (file-name-as-directory user-emacs-cache-directory))
    (setq-default desktop-path `(,desktop-dirname))
    (setq-default desktop-base-file-name "desktop")
    (setq-default desktop-files-not-to-save nil)
    (setq-default desktop-globals-to-clear nil)
    (setq-default desktop-load-locked-desktop t)
    (setq-default desktop-missing-file-warning nil)
    (setq-default desktop-restore-eager 0)
    (setq-default desktop-restore-frames nil)
    (setq-default desktop-save 'ask-if-new)
    (desktop-save-mode 0))

  (use-package emacs
    :ensure nil
    :demand
    :init
    (setq-default initial-buffer-choice t)
    (setq-default inhibit-startup-message t)
    (setq-default inhibit-startup-screen t)
    (setq-default inhibit-startup-buffer-menu t)
    (setq-default inhibit-x-resources t))
#+end_src
** Make sure that UTF-8 is used everywhere.
#+begin_src emacs-lisp
  (use-package mule
    :ensure nil
    :demand
    :init
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (set-language-environment 'utf-8)
    (set-selection-coding-system 'utf-8)
    (prefer-coding-system 'utf-8)
    (set-input-method nil)
    (setq locale-coding-system 'utf-8)
    (add-to-list 'process-coding-system-alist '("python" . (utf-8 . utf-8)))
    (add-to-list 'process-coding-system-alist '("elpy" . (utf-8 . utf-8))))
#+end_src
** Savehist (minibuffer history)
#+begin_src emacs-lisp
  (use-package savehist
    :ensure nil
    :diminish
    :commands (savehist-mode)
    :init
    (setq-default savehist-file (expand-file-name "savehist" user-emacs-cache-directory))
    (setq-default history-length 1000)
    (setq-default history-delete-duplicates t)
    (setq-default savehist-save-minibuffer-history t)
    (savehist-mode 1))
#+end_src
** Saveplace (cursor position)
#+begin_src emacs-lisp
  (use-package saveplace
    :ensure nil
    :diminish
    :init
    (setq-default save-place-file (expand-file-name "saveplace" user-emacs-cache-directory))
    (setq-default save-place-forget-unreadable-files t)
    :hook (emacs-startup-hook . save-place-mode))
#+end_src
** Backups
#+begin_src emacs-lisp
  (use-package files
    :ensure nil
    :demand
    :init
    (let
        ((backup-dir (file-name-as-directory (expand-file-name "backups" user-emacs-cache-directory))))
      (unless (file-exists-p backup-dir) (make-directory backup-dir t))
      (setq-default backup-directory-alist `(("." . ,backup-dir)))
      (setq-default backup-by-copying t)
      (setq-default delete-old-versions t)
      (setq-default kept-new-versions 5)
      (setq-default kept-old-versions 2)
      (setq-default create-lockfiles nil)))
#+end_src
** Auto-save
#+begin_src emacs-lisp
  (use-package files
    :ensure nil
    :demand
    :init
    (let
        ((auto-save-dir (file-name-as-directory (expand-file-name "auto-save" user-emacs-cache-directory)))
         (auto-save-list-dir (file-name-as-directory(expand-file-name "auto-save-list" user-emacs-cache-directory))))
      (unless (file-exists-p auto-save-dir) (make-directory auto-save-dir t))
      (unless (file-exists-p auto-save-list-dir) (make-directory auto-save-list-dir t))
      (setq-default auto-save-file-name-transforms `((".*" ,auto-save-dir t)))
      (setq-default auto-save-list-file-prefix (expand-file-name "saves-" auto-save-list-dir))
      (setq-default auto-save-default t)
      (setq-default auto-save-timeout 10)
      (setq-default auto-save-interval 200)))
#+end_src
** Completion for recent files and directories
#+begin_src emacs-lisp
  (use-package recentf
    :ensure nil
    :diminish
    :defer 1
    :init
    (setq-default recentf-save-file (expand-file-name "recentf" user-emacs-cache-directory))
    (setq-default recentf-max-saved-items 200)
    (setq-default recentf-exclude '("\\.gz" "\\.xz" "\\.zip" "/elpa/" "/ssh:" "/sudo:"))
    :hook (emacs-startup-hook . recentf-mode))
#+end_src
** Line numbers
#+begin_src emacs-lisp
  (use-package display-line-numbers
    :ensure nil
    :disabled ;; For now, try to life without it, performance degradation is sometimes too bad.
    :diminish
    :commands (display-line-numbers-mode global-display-line-numbers-mode)
    :init
    (setq-default display-line-numbers-type t)
    (setq-default display-line-numbers-width-start t)
    (setq-default display-line-numbers-grow-only t)
    (set-face-attribute 'line-number-current-line nil :weight 'bold)
    (global-display-line-numbers-mode)
    :hook
    (prog-mode-hook . (lambda ()
                        (setq display-line-numbers-type 'visual))))
#+end_src
** S - The long lost Emacs string manipulation library
#+begin_src emacs-lisp
  (use-package s
    :demand
    :ensure t)
#+end_src
** f - Modern API for working with files and directories
#+begin_src emacs-lisp
  (use-package f
    :demand
    :ensure t)
#+end_src
** dash - A modern list API for Emacs.
#+begin_src emacs-lisp
  (use-package dash
    :demand
    :ensure t)
#+end_src
** package [built-in] - Simple package system for Emacs
#+begin_src emacs-lisp
  (use-package package
    :ensure nil
    :demand
    :custom
    (package-enable-at-startup nil) ;; Also configured in early-init.el
    (package-quickstart nil) ;; Also configured in early-init.el
    :bind (:map package-menu-mode-map
                ("q" . kill-buffer-and-window)))
#+end_src
** GCMH - the Garbage Collector Magic Hack
#+begin_src emacs-lisp
  (use-package gcmh
    :ensure t
    :diminish gcmh-mode
    :custom
    (gcmh-idle-delay 'auto)
    (gcmh-auto-idle-delay-factor 10)
    (gcmh-high-cons-threshold (* 16 1024 1024))
    (gcmh-verbose nil)
    :hook
    (emacs-startup-hook . gcmh-mode))
#+end_src
** utils - Personal utilities
#+begin_src emacs-lisp
  (use-package my-utils
    :ensure nil
    :demand
    :load-path "elisp"
    :bind (("C-x 9" . my/delete-most-recent-window)))
#+end_src
* Interface enhancements
** Minibuffer [built-in]
#+begin_src emacs-lisp
  (use-package minibuffer
    :ensure nil
    :config
    (defun switch-to-minibuffer-window ()
      "Switch to minibuffer window (if active)"
      (interactive)
      (when (active-minibuffer-window)
        (select-frame-set-input-focus (window-frame (active-minibuffer-window)))
        (select-window (active-minibuffer-window))))

    (defun kill-other-buffers ()
      "Kill all other buffers."
      (interactive)
      (mapc 'kill-buffer-save (delq (current-buffer) (buffer-list))))

    ;; https://www.emacswiki.org/emacs/KillingBuffers#toc9
    (setq kill-buffer-save-list '("*scratch*" "*Messages*"))
    (defun kill-buffer-save (&optional buffer-or-name)
      "Only kill buffers not in the kill-buffer-save-list."
      (interactive "bKill buffer: ")
      (or buffer-or-name (setq buffer-or-name (current-buffer)))
      (if (member
           (if (bufferp buffer-or-name) (buffer-name buffer-or-name) buffer-or-name)
           kill-buffer-save-list)
          (bury-buffer buffer-or-name)
        (kill-buffer buffer-or-name)))
    (defun myext-focus-minibuffer-or-completion ()
      "Focus the active minibuffer or completion window.
  TODO: needs refactoring."
      (interactive)
      (let* ((mini (active-minibuffer-window))
             (completions (get-window-with-predicate
                           (lambda (window)
                             (org-string-match-p
                              "\\*\\(Completions\\|Embark Collect \\(Live\\|Completions\\)\\)"
                              (format "%s" window))))))
        (cond ((and mini (not (minibufferp)))
               (select-window mini nil))
              ((and completions (not (eq (selected-window) completions)))
               (select-window completions nil)))))
    (setq completion-styles '(basic orderless))
    (setq completion-category-defaults nil)
    (setq completion-cycle-threshold 5)
    (setq completion-ignore-case t)
    (setq completion-category-defaults nil)
    (setq completion-auto-help nil)
    (setq read-file-name-completion-ignore-case t)
    (setq read-buffer-completion-ignore-case t)
    (setq completion-ignore-case t)
    (setq enable-recursive-minibuffers t)
    (setq minibuffer-eldef-shorten-default t)
    (setq minibuffer-depth-indicator-function (lambda (depth)
                                                (format "[%2d] " depth)))
    (minibuffer-depth-indicate-mode 1)
    (minibuffer-electric-default-mode 1)

    :bind (("H-f" . myext-focus-minibuffer-or-completion)
           ("C-x k" . kill-buffer-save)
           ("C-x K" . kill-other-buffers)
           ("C-x C-o" . switch-to-minibuffer-window)
           :map minibuffer-local-completion-map
           ("RET" . minibuffer-force-complete-and-exit)
           ("<tab>" . minibuffer-complete)
           ("<backtab>" . minibuffer-force-complete)
           ("M-RET" . exit-minibuffer)
           :map minibuffer-local-filename-completion-map
           ("RET" . minibuffer-force-complete-and-exit)
           ))
#+end_src
** autorevert [built-in]
#+begin_src emacs-lisp
  (use-package autorevert
    :ensure nil
    :diminish auto-revert-mode
    :config
    (setq auto-revert-verbose t)
    :hook (after-init-hook . global-auto-revert-mode))
#+end_src
** imenu [built-in] - find major definitions in a file by name
#+begin_src emacs-lisp
  (use-package imenu
    :ensure nil
    )

  (use-package imenu-list
    :ensure t
    :after (:all imenu)
    :defer t
    :commands (imenu-list)
    :functions (imenu-list-ret-dwim
                imenu-list-resize-window
                imenu-list-update
                imenu-list-show
                imenu-list-quit-window)
    :config
    (setq imenu-list-idle-update-delay-time 0.5)
    (setq imenu-list-porition 'right)
    (setq imenu-list-buffer-name "*Ilist*")
    (defun my/imenu-list-toggle ()
      "Open the imenu-list buffer."
      (interactive)
      (if (string= (buffer-name) "*Ilist*")
          (imenu-list-quit-window)
        (progn
          (imenu-list-minor-mode 1)
          (if (get-buffer "*Ilist*")
              (imenu-list-show)
            (imenu-list))
          (imenu-list-update)
          (imenu-list-resize-window)
          (enlarge-window-horizontally 2)
          )))
    (defun my/imenu-list-ret-dwim ()
      "Jump to the entry at `point' and close the imenu-list window."
      (interactive)
      (call-interactively #'imenu-list-ret-dwim)
      (kill-buffer "*Ilist*"))
    :hook
    (imenu-list-major-mode-hook . (lambda () (display-line-numbers-mode 0)))
    :bind (("<f7>" . my/imenu-list-toggle)
           :map imenu-list-major-mode-map
           ("RET" . imenu-list-display-dwim)
           ("<return>" . imenu-list-display-dwim)
           ("TAB" . hs-toggle-hiding)
           ("<tab>" . hs-toggle-hiding)))
#+end_src
** vertico - VERTical Interactive COmpletion
#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :init
    (setq vertico-scroll-margin 0)
    (setq vertico-count 10)
    (setq vertico-resize nil)
    (setq vertico-cycle t)
    (vertico-mode 1)
    (vertico-multiform-mode 1)
    :bind (:map vertico-map
                ("<right>" . forward-char)
                ("<left>" . backward-char)
                ("<up>" . vertico-previous)
                ("<down>" . vertico-next)
                ("C-<up>" . previous-history-element)
                ("C-<down>" . next-history-element)
                ("C-f" . forward-char)
                ("C-b" . backward-char)
                ("C-p" . vertico-previous)
                ("C-n" . vertico-next)
                ("<prior>" . vertico-scroll-up)
                ("<next>" . vertico-scroll-down)
                ("M-f" . vertico-quick-insert)
                ("M-," . vertico-quick-insert)
                ("M-." . vertico-quick-exit)))

  (use-package vertico-directory
    :ensure nil ;; part of vertico
    :after vertico
    :commands (vertico-directory-tidy)
    :bind (:map vertico-map
                ("RET" . vertico-directory-enter)
                ("DEL" . vertico-directory-delete-char)
                ("M-DEL" . vertico-directory-delete-word))
    :hook
    (rfn-eshadow-update-overlay . vertico-directory-tidy))

  (use-package vertico-multiform
    :ensure nil ;; part of vertico
    :after vertico
    :commands (vertico-multiform-mode)
    :config
    (setq vertico-multiform-commands
          '((consult-line buffer)
            (consult-imenu reverse buffer)))
    (setq vertico-multiform-categories
          '((imenu (:not indexed mouse))
            (symbol (vertico-sort-function . vertico-sort-alpha)))))
#+end_src
** Consult - Consulting completing-read
#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :demand
    :config
    (setq consult-line-numbers-widen t)
    (setq completion-in-region-function #'consult-completion-in-region)
    (setq register-preview-function #'consult-register-format)
    (setq consult-async-min-input 3)
    (setq consult-async-input-debounce 0.5)
    (setq consult-async-input-throttle 0.8)
    (setq consult-narrow-key ">")
    :bind (("M-g l" . consult-goto-line)
           ("M-g M-l" . consult-goto-line)
           ("M-X" . consult-mode-command)
           ("M-s m" . consult-mark)
           ("M-s i" . consult-imenu)
           ("M-s y" . consult-yank)
           ("M-s l" . consult-line)
           ("M-s g" . consult-ripgrep)
           ([remap switch-to-buffer] . consult-buffer)
           ([remap jump-to-register] . consult-register-load)
           ([remap point-to-register] . consult-register-store)
           :map consult-narrow-map
           ("?" . consult-narrow-help)))

  (use-package consult-lsp
    :ensure t
    :after (:all lsp consult)
    :bind (:map lsp-mode-map
                ("M-s S" . consult-lsp-symbols)
                ("M-s s" . consult-lsp-file-symbols))
    )
#+end_src
** Marginalia - Enrich existing commands with completion annotations
#+begin_src emacs-lisp
  (use-package marginalia
    :ensure t
    :commands (marginalia-mode)
    :init
    (setq-default marginalia-annotators
                  '(marginalia-annotators-heavy
                    marginalia-annotators-light))
    (setq-default marginalia-max-relative-age 0)
    (marginalia-mode))
#+end_src
** Embark - Conveniently act on minibuffer completions
#+begin_src emacs-lisp
  (use-package embark
    :ensure t
    :custom
    (embark-quit-after-action t)
    (embark-mixed-indicator-delay 0)
    (embark-verbose-indicator-display-action '(display-buffer-at-bottom (window-height . fit-window-to-buffer)))
    :config
    ;; Show Embark actions via which-key
    (setq embark-action-indicator
          (lambda (map)
            (which-key--show-keymap "Embark" map nil nil 'no-paging)
            #'which-key--hide-popup-ignore-command)
          embark-become-indicator embark-action-indicator)
    (defun embark-collect-toggle-mark ()
      "Toggle the mark of the candidate at point in an Embark collect buffer."
      (interactive)
      (embark-collect-mark (embark-collect--marked-p)))
    :bind (("M-g a" . embark-act)
           ("M-g M-a" . embark-act)
           :map embark-collect-mode-map
           ("SPC" . embark-collect-toggle-mark)
           :map minibuffer-local-map
           ("M-a" . embark-act)
           ("M-b" . embark-become)
           ("M-e" . embark-export)))

  (use-package embark-consult
    :ensure t
    :after (:all embark consult)
    :demand t
    :hook (embark-collect-mode-hook . embark-consult-preview-minor-mode))

  (use-package zed-embark
    :ensure nil
    :after (:all embark consult)
    :hook
    (prot-embark-clear-live-buffers . zed-embark-clear-all-collection-buffers)
    :bind (:map minibuffer-local-completion-map
                ("C-n" . zed-embark-switch-to-completion-buffer-top)))
#+end_src
** Orderless - Use space-separated search terms in any order when completing with Icomplete or the default interface
#+begin_src emacs-lisp
  (use-package orderless
    :ensure t
    :demand ;; If it is lazy loaded, a message is show in the minibuffer the
            ;; first time it is used
    :custom
    (completion-styles '(basic orderless))
    (completion-category-defaults nil)
    (completion-category-overrides
     '((file (styles . (basic partial-completion orderless)))
       (project-file (styles . (basic substring partial-completion orderless)))
       (imenu (styles . (basic substring orderless)))
       (kill-ring (styles . (basic substring orderless)))
       (consult-location (styles . (basic substring orderless)))))
    :config
    (defun my/orderless-literal-style-dispatcher (pattern _index _total)
      "Style dispatcher which recognizes patterns which have an '=' as suffix and
  dispatches those to the orderless-literal style"
      (when (string-suffix-p "=" pattern)
        `(orderless-literal . ,(substring pattern 0 -1))))
    (defun my/orderless-initialism-style-dispatcher (pattern _index _total)
      "Style dispatchter which recognizes patterns which have an ';' as suffix and
  dispatches those to the orderless-literal style"
      (when (string-suffix-p ";" pattern)
        `(orderless-initialism . ,(substring pattern 0 -1))))
    (defun my/orderless-flex-style-dispatcher (pattern _index _total)
      "Style dispatcher which recognizes patterns which have an ',' as suffix and
  dispatches those to the orderless-flex style"
      (when (string-suffix-p "," pattern)
        `(orderless-flex . ,(substring pattern 0 -1))))
    (setq orderless-component-separator " +")
    (setq orderless-matching-styles
          '(orderless-prefixes
            orderless-initialism
            orderless-regexp
            orderless-flex))
    (setq orderless-style-dispatchers
          '(my/orderless-literal-style-dispatcher
            my/orderless-initialism-style-dispatcher
            my/orderless-flex-style-dispatcher))
    :bind (:map minibuffer-local-completion-map
                ("SPC" . nil)
                ("?" . nil)))
#+end_src
** perspective - switch between named "perspectives" of the editor
#+begin_src emacs-lisp
  (use-package perspective
    :ensure t
    :commands (persp-switch persp-kill persp-current-name)
    :init
    ;; TODO: look into the new behaviour
    (setq persp-suppress-no-prefix-key-warning t)
    (setq persp-initial-frame-name "001")
    (defun persp-switch-to-frame-1 ()
      (interactive)
      (persp-switch "001"))
    (defun persp-switch-to-frame-2 ()
      (interactive)
      (persp-switch "010"))
    (defun persp-switch-to-frame-3 ()
      (interactive)
      (persp-switch "011"))
    (defun persp-switch-to-frame-4 ()
      (interactive)
      (persp-switch "100"))
    (defun persp-switch-to-frame-5 ()
      (interactive)
      (persp-switch "101"))
    (defun persp-switch-to-frame-6 ()
      (interactive)
      (persp-switch "110"))
    (defun persp-switch-to-frame-7 ()
      (interactive)
      (persp-switch "111"))
    (defun persp-kill-current-frame ()
      (interactive)
      (persp-kill (persp-current-name)))
    :config
    (persp-mode)
    :bind (("M-1" . persp-switch-to-frame-1)
           ("M-2" . persp-switch-to-frame-2)
           ("M-3" . persp-switch-to-frame-3)
           ("M-4" . persp-switch-to-frame-4)
           ("M-5" . persp-switch-to-frame-5)
           ("M-6" . persp-switch-to-frame-6)
           ("M-7" . persp-switch-to-frame-7)
           ("M-0" . persp-kill-current-frame)))
#+end_src
* Help / Discovery / Cheat sheets
** help [built-in]
#+begin_src emacs-lisp
  (use-package help
    :ensure nil
    :bind (:map help-mode-map
                ("<mouse-8>" . help-go-back)
                ("<wheel-left>" . help-go-back)
                ("<mouse-9>" . help-go-forward)
                ("<wheel-right>" . help-go-forward)))
#+end_src
** man [built-in]
#+begin_src emacs-lisp
  (use-package man
    :ensure nil
    :functions (Man-next-section)
    :config
    (setq Man-notify-method 'aggressive)
    :bind (:map Man-mode-map
                ([remap Man-next-section] . (lambda () (interactive) (progn (Man-next-section 1) (recenter))))))
#+end_src
** which-key - Display available key bindings in popup
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :defer 5
    :diminish which-key-mode
    :commands (which-key-mode
               which-key-add-key-based-replacements
               which-key-add-major-mode-key-based-replacements
               which-key-add-keymap-based-replacements)
    :custom
    (which-key-idle-delay 0.4)
    (which-key-idle-secondary-delay 0)
    (which-key-max-description-length 32)
    (which-key-add-column-padding 2)
    (which-key-min-display-lines 7)
    (which-key-use-C-h-commands t)
    (which-key-show-early-on-C-h t)
    :config
    (which-key-mode 1))
#+end_src
** free-keys - Show free keybindings for modkeys or prefixes
I found the ~free-keys~ documentation a bit confusing in the beginning.
If the prefix should be changed (using "p" in the buffer), do not type the prefix (don't hold C-c), but write the string into the completion buffer (type "C" "-" "c").
Same is true for the prefix argument.
Execute ~free-keys~ using C-u M-x "free-keys" and then type "C" "-" "c" into the completion buffer.
#+begin_src emacs-lisp
  (use-package free-keys
    :ensure t
    :commands (free-keys)
    :custom
    (free-keys-modifiers '("" "C" "M" "C-M"))
    :bind (("C-h C-k" . 'free-keys)
           :map free-keys-mode-map
           ("q" . kill-buffer-and-window)))
#+end_src
** keyfreq - track command frequencies
#+begin_src emacs-lisp
  (use-package keyfreq
    :ensure t
    :defer 2
    :commands (keyfreq-mode keyfreq-autosave-mode)
    :custom
    (keyfreq-buffer "*keyfreq-show*")
    (keyfreq-file (expand-file-name "keyfreq.hist" user-emacs-cache-directory))
    (keyfreq-file-lock (expand-file-name "keyfreq.hist.lock" user-emacs-cache-directory))
    (keyfreq-excluded-commands
     '(self-insert-command
       org-self-insert-command
       mwheel-scroll
       mouse-set-point))
    :config
    (keyfreq-mode 1)
    (keyfreq-autosave-mode 1))
#+end_src
** help-fns+.el - Extensions to `help-fns.el'
#+begin_src emacs-lisp
  (use-package help-fns+
    :ensure nil
    :load-path "elisp"
    :bind (("C-h K" . describe-keymap)))
#+end_src
* File manager
** dired [built-in] - directory editor
#+begin_src emacs-lisp
  (use-package dired
    :ensure nil
    :custom
    (dired-listing-switches "-AblGh --group-directories-first")
    :init
    (defun dired-alternate-up-directory ()
      "In Dired, visit the parent directory via `find-alternate-file'.
  This kills the Dired buffer, then visits the parent directory."
      (interactive)
      (find-alternate-file ".."))
    (defun my/dired-open ()
      "In Dired, visit the file or directory named on this line.
  If one is about to visit a directory, it is opened via `find-alternate-file'.
  This kills the Dired buffer, then visits the directory.
  Otherwise, it is opened via `find-file'."
      (interactive)
      (if (file-directory-p (dired-get-file-for-visit))
          (find-alternate-file (dired-get-file-for-visit))
        (find-file (dired-get-file-for-visit))))
    :bind (:map dired-mode-map
                ("<return>" . my/dired-open)
                ("^" . dired-alternate-up-directory)
                ("o" . my/dired-open)
                ("C-o" . dired-find-file-other-window)
                ("C-<return>" . dired-find-file-other-window)
                ("<mouse-2>" . dired-mouse-find-file)
                ("C-<mouse-2>" . dired-mouse-find-file-other-window)
                ("C-<mouse-1>" . dired-mouse-find-file-other-window)
                ("C-<down-mouse-1>" . dired-mouse-find-file-other-window)))
#+end_src
** neotree - A tree plugin like NerdTree for Vim
#+begin_src emacs-lisp
  (use-package neotree
    :disabled
    :ensure t
    :defer 1
    :custom
    (neo-smart-open t)
    (neo-vc-integration '(face char))
    (neo-window-fixed-size nil)
    (neo-window-width 55)
    (neo-theme (if (display-graphic-p) 'icons 'arrow))
    :bind (("<f8>" . neotree-toggle)
           :map neotree-mode-map
           ("<C-return>" . neotree-change-root)
           ("d" . neotree-delete-node)
           ("<delete>" . neotree-delete-node)
           ("C-h" . neotree-hidden-file-toggle)
           ("r" . neotree-rename-node)))
#+end_src
** treemacs - A tree style file explorer package
#+begin_src emacs-lisp
  (use-package treemacs
    :ensure t
    :defer 1
    :config
    (setq-default treemacs-follow-mode t)
    (setq-default treemacs-persist-file (expand-file-name "treemacs-persist" user-emacs-cache-directory))
    :hook
    (treemacs-mode-hook . (lambda () (display-line-numbers-mode 0)))
    :bind (("<f8>" . treemacs)))

  (use-package treemacs-projectile
    :ensure t
    :after (:all treemacs projectile))

  (use-package treemacs-magit
    :ensure t
    :after (:all treemacs magit))

  (use-package treemacs-persp
    :ensure t
    :after (:all treemacs perspective))
#+end_src
** Quick file opening shortcuts
#+begin_src emacs-lisp
  (use-package quick-file-access
    :ensure nil
    :load-path "elisp"
    :config
    (setq-default quick-file-access-file-list
                  '("~/.emacs.d/settings.org"
                    "~/.emacs.d/init.el"
                    "~/.emacs.d/early-init.el"
                    "~/.Xresources"))
    :bind (("<escape> <escape> o" . quick-file-access-open-file)))
#+end_src
* Visual
** whitespace [built-in]
#+begin_src emacs-lisp
  (use-package whitespace
    :ensure nil
    :diminish
    :commands (whitespace-mode)
    :init
    (setq-default whitespace-style '(face tab-mark))
    :hook
    (prog-mode-hook . whitespace-mode))
#+end_src
** hi-lock [built-in] - minor mode for interactive automatic highlighting
#+begin_src emacs-lisp
  (use-package hi-lock
    :ensure nil
    :demand
    :diminish
    :init
    (defun my/highlight-region-or-symbol (&optional face)
      "Highlight occurences of either the currently region or the symbol at point."
      (interactive
       (list (hi-lock-read-face-name)))
      (or (facep face) (setq face 'hi-yellow))
      (unless hi-lock-mode (hi-lock-mode 1))
      (let ((thing-to-highlight
             (if (use-region-p)
                 (buffer-substring (region-beginning) (region-end))
               (thing-at-point 'symbol 'no-properties))))
        (unless thing-to-highlight
          (user-error "Nothing to highlight"))
        (hi-lock-set-pattern (regexp-quote thing-to-highlight) face)))

    (defun my/unhighlight-region-or-symbol ()
      "Unhighlight either the currently region or the symbol at point."
      (interactive nil hi-lock-mode)
      (let ((thing-to-highlight
             (if (use-region-p)
                 (buffer-substring (region-beginning) (region-end))
               (thing-at-point 'symbol 'no-properties))))
        (unhighlight-regexp (regexp-quote thing-to-highlight))))

    (defun my/unhighlight-all ()
      "Unhighlight everything that has been previously highlighted."
      (interactive nil hi-lock-mode)
      (unhighlight-regexp t))
    :bind (("M-s h ." . my/highlight-region-or-symbol)
           ("M-s h ," . my/unhighlight-region-or-symbol)
           ("M-s h U" . my/unhighlight-all)))
#+end_src
** highlight-thing - Minimalistic minor mode to highlight current thing under point
#+begin_src emacs-lisp
  (use-package highlight-thing
    :ensure t
    :demand
    :diminish
    :custom
    (highlight-thing-delay-seconds 2)
    (highlight-thing-exclude-thing-under-point t)
    (highlight-thing-prefer-active-region t)
    :init
    (global-highlight-thing-mode 1))
#+end_src
** undo-tree - Treat undo history as a tree
#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure t
    :demand ;; we always want the undo tree and its presistance.
    :diminish undo-tree-mode
    :commands (global-undo-tree-mode unto-tree-visualize unto-tree-undo)
    :custom
    (undo-tree-auto-save-history t)
    (undo-tree-history-directory-alist `(("." . ,(file-name-as-directory
                                                  (expand-file-name
                                                   "undo"
                                                   user-emacs-cache-directory)))))
    (undo-tree-visualizer-diff t)
    (undo-tree-visualizer-timestamps t)
    :config
    (let
        ((undo-dir (file-name-as-directory
                    (expand-file-name "undo" user-emacs-cache-directory))))
      (unless (file-exists-p undo-dir) (make-directory undo-dir t)))
    (global-undo-tree-mode 1)
    :bind (:map undo-tree-map
                ([remap undo] . undo-tree-undo)
                ([remap undo-redo] . undo-tree-redo)
                ("C-x U" . undo-tree-visualize)
                :map undo-tree-visualizer-mode-map
                ("C-x u" . undo-tree-visualize-quit)))
#+end_src
* Editing
** expand-region - Increas the selected region by semantic units
#+begin_src emacs-lisp
  (use-package expand-region
    :ensure t
    :defer 1
    :bind (("C-=" . er/expand-region)
           ("C-+" . er/contract-region)
           ("M-C-S-SPC" . er/mark-symbol)))

#+end_src
** string-inflection - underscore -> UPCASE -> CamelCase -> lowerCamelCase conversion of names
#+begin_src emacs-lisp
  (use-package string-inflection
    :ensure t
    :commands (string-inflection-upcase-function
               string-inflection-underscore-function
               string-inflection-java-style-cycle-function
               string-inflection-python-style-cycle-function
               string-inflection-ruby-style-cycle-function
               string-inflection-all-cycle-function)
    :config
    (defun string-inflection-cycle-auto-detection ()
      (interactive)
      (cond
       ((eq major-mode 'java-mode)
        (string-inflection-java-style-cycle))
       ((eq major-mode 'python-mode)
        (string-inflection-python-style-cycle))
       ((eq major-mode 'ruby-mode)
        (string-inflection-ruby-style-cycle))
       (t
        (string-inflection-all-cycle))))
    :bind (("M-u" . string-inflection-upcase)
           ("M-l" . string-inflection-cycle-auto-detection)
    ))
#+end_src
* Kill-ring
** System clipboard integration
#+begin_src emacs-lisp
  (use-package simple
    :ensure nil
    :demand
    :init
    (setq-default save-interprogram-paste-before-kill t))
#+end_src
* Movement / Navigation
#+begin_src emacs-lisp
  (defun backward-kill-char-or-word ()
    "Kill characters backward.
  If the characters behind the cursor form a word
  \(possibly with ablank behind it\), 'backward-kill-word'.
  If there are multiple blanks, 'delete-horizontal-space',
  otherwise 'backward-delete-char'"
    (interactive)
    (cond
     ((looking-back "[[:word:]][[:blank:]]?" 1)
      (backward-kill-word 1))
     ((looking-back "[[:blank:]]+" 1)
      (delete-horizontal-space t))
     (t
      (backward-delete-char 1))))

  ;; bind Meta-Backspace (M-DEL)
  (global-set-key [?\M-\d] 'backward-kill-char-or-word)

  (setq scroll-error-top-bottom 'true
        scroll-margin 0
        scroll-conservatively 100000
        scroll-preserve-screen-position 1)

  (global-set-key [mouse-8] 'pop-tag-mark)

  (global-set-key [C-mouse-8] 'previous-buffer)
  (global-set-key [C-mouse-9] 'next-buffer)

  (defun forward-paragraph-recenter (&optional arg)
    "Move forward to end of paragraph and center point using `recenter'.
  With argument `ARG', do it `ARG' times; a negative argument `ARG' = -N means
  move backward N paragraphs."
    (interactive "^p")
    (call-interactively #'forward-paragraph)
    (recenter nil t))

  (defun backward-paragraph-recenter (&optional arg)
    "Move backward to start of paragraph and center point using `recnter'.

  a negative argument `ARG' = -N means move forward N paragraphs."
    (interactive "^p")
    (call-interactively #'backward-paragraph)
    (recenter nil t))

  (global-set-key (kbd "M-}") #'forward-paragraph-recenter)
  (global-set-key (kbd "M-{") #'backward-paragraph-recenter)
  (global-set-key (kbd "M-i") #'back-to-indentation)
#+end_src
** golden-ratio-scroll-screen - Scroll half screen down or up, and highlight current line
#+begin_src emacs-lisp
  (use-package golden-ratio-scroll-screen
    :ensure t
    :custom
    (golden-ratio-scroll-highlight-flag nil "Do not highlight current line before/after scroll")
    :hook
    (golden-ratio-scroll-screen-up-hook . (lambda () (recenter)))
    (golden-ratio-scroll-screen-down-hook . (lambda () (recenter)))
    :bind (([remap scroll-down-command] . golden-ratio-scroll-screen-down)
           ([remap scroll-up-command] . golden-ratio-scroll-screen-up)))
#+end_src
** move-text - Move current line or region with M-up or M-down.
#+begin_src emacs-lisp
  (use-package move-text
    :ensure t
    :commands (move-text-up
               move-text-down
               move-text-line-up
               move-text-line-down
               move-text-region
               move-text-region-up
               move-text-region-down)
    :bind (("M-p" . move-text-up)
           ("M-n" . move-text-down)))
#+end_src
** iy-go-to-char.el - Go to next CHAR
#+begin_src emacs-lisp
  (use-package iy-go-to-char
    :ensure nil ;; Not on melpa.
    :bind (("M-m" . iy-go-up-to-char)
           ("M-M" . iy-go-up-to-char-backward))
    )
#+end_src
** Avy - Jump to arbitrary positions in visible text and select text quickly
#+begin_src emacs-lisp
  (use-package avy
    :ensure t
    :bind (("M-g g" . avy-goto-line)
           ("M-g M-g" . avy-goto-line)
           ("M-g c" . avy-goto-char)
           ("M-g M-c" . avy-goto-char)
           ("M-g f" . avy-goto-word-0)
           ("M-g M-f" . avy-goto-word-0)))
#+end_src
** smartparens - Automatic insertion, wrapping and paredit-like navigation with user defined pairs.
#+begin_src emacs-lisp
  (use-package smartparens
    :ensure t
    :diminish
    :hook (prog-mode-hook . smartparens-mode)
    :config
    (defun my/sp-beginning-of-sexp (&optional ARG)
      "Like `sp-beginning-of-sexp` but a bit better.
  Falls back to `backward-sexp` if point does not move."
      (interactive "^P")
      (let ((current-point (point)))
        (sp-beginning-of-sexp ARG)
        (when (= (point) current-point)
          (backward-sexp ARG))))
    (defun my/sp-end-of-sexp (&optional ARG)
      "Like `sp-beginning-of-sexp` but a bit better.
  Falls back to `forward-sexp` if point does not move."
      (interactive "^P")
      (let ((current-point (point)))
        (sp-end-of-sexp ARG)
        (when (= (point) current-point)
          (forward-sexp ARG))))
    (setq sp-autoinsert-pair nil)
    (setq sp-escape-quotes-after-insert nil)
    :bind (([remap backward-sexp] . my/sp-beginning-of-sexp)
           ([remap forward-sexp] . my/sp-end-of-sexp)
           ([remap forward-sexp] . my/sp-end-of-sexp))
    )
#+end_src
** ace-window - Quickly switch windows
#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :defer t
    :custom
    (aw-keys '(?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9))
    (aw-background nil)
    (aw-ignored-buffers '("*Ilist*" "*Calc Trail*" " *LV*"))
    :custom-face
    (aw-leading-char-face ((t (:inherit ace-jump-face-foreground :height 3.0))))
    :bind (([remap other-window] . ace-window)))
#+end_src
** multiple-cursors.el - Multiple cursors for Emacs.
#+begin_src emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :custom
    (mc/list-file (locate-user-emacs-file ".mc-lists.el"))
    (mc/max-cursors nil)
    (mc/always-run-for-all nil)
    (mc/always-repeat-command nil)
    :bind (("M-C-SPC" . set-rectangular-region-anchor)
           ("C->" . mc/mark-next-like-this)
           ("C-<" . mc/mark-previous-like-this)))
#+end_src
** view.el [built-in] - peruse file or buffer without editing
#+begin_src emacs-lisp
  (use-package view
    :ensure nil
    :bind (("C-`" . view-mode)
           :map view-mode-map
           ("n" . next-line)
           ("p" . previous-line)))
#+end_src
* Searching
** isearch [built-in]
#+begin_src emacs-lisp
  (use-package isearch
    :ensure nil
    :config
    (setq search-highlight t)
    (setq search-whitespace-regexp ".*?")
    (setq isearch-lax-whitespace t)
    (setq isearch-regexp-lax-whitespace nil)
    (setq isearch-lazy-count t)
    (setq isearch-lazy-highlight t)
    (defun my/isearch-and-regex (search-input &optional lax)
      (message search-input)
      search-input)
    (isearch-define-mode-toggle and "^" my/isearch-and-regex
      "Turning on and search turns off regexp mode.")
    :bind (:map isearch-mode-map
                ("C-g" . isearch-cancel)
                ("<help>" . nil)
                ("C-h <help>" . nil)
                ("<f1> <help>" . nil)
                ("M-ESC ESC" . nil)))
#+end_src
** replace / occur [built-in]
#+begin_src emacs-lisp
  (use-package replace
    :ensure nil
    :demand
    :init
    (defun my/occur-mode-move-beginning-of-line (arg)
      (interactive "^p")
      (or arg (setq arg 1))
      (if (/= arg 1)
          (let ((line-move-visual nil))
            (line-move (1- arg) t)))
      (let ((current-line (thing-at-point 'line t)))
        (if (string-match-p "^[[:space:]]*[0-9]+:" current-line)
            (progn
              (move-beginning-of-line 1)
              (re-search-forward "^[[:space:]]*[0-9]+:"))
          (move-beginning-of-line 1))))
    :bind (:map occur-mode-map
                ("C-a" . my/occur-mode-move-beginning-of-line)
                ("q" . kill-buffer-and-window)
                ([remap next-line] . next-error-no-select)
                ([remap previous-line] . previous-error-no-select)
                :map occur-edit-mode-map
                ("C-a" . my/occur-mode-move-beginning-of-line)))
#+end_src
** grep [built-in]
#+begin_src emacs-lisp
  (use-package grep
    :ensure nil
    :bind (:map grep-mode-map
                ("e" . wgrep-change-to-wgrep-mode)
                ("C-c '" . wgrep-change-to-wgrep-mode)
                ("q" . kill-buffer-and-window)))
#+end_src
** wgrep - Writable grep buffer and apply the changes to files
#+begin_src emacs-lisp
  (use-package wgrep
    :ensure t
    :commands (wgrep-setup wgrep-change-to-wgrep-mode)
    :bind (:map wgrep-mode-map
                ("C-x C-s" . nil)
                ("C-c c" . wgrep-finish-edit)
                ("C-c k" . wgrep-abort-changes)
                ("C-c r" . wgrep-remove-change)
                ("C-c u" . wgrep-remove-all-change)))
#+end_src
** rg - A search tool based on ripgrep
#+begin_src emacs-lisp
  (use-package rg
    :ensure t
    :commands (rg
               rg-project
               rg-literal
               rg-dwim
               rg-dwim-project-dir
               rg-dwim-current-dir
               rg-dwim-current-file)
    :custom
    (rg-command-line-flags nil)
    (rg-buffer-name "ripgrep")
    (rg-ignore-ripgreprc t)
    :bind (:map rg-mode-map
                ("C-c '" . wgrep-change-to-wgrep-mode)
                ("q" . kill-buffer-and-window)))

  (use-package rg-menu
    :ensure nil ;; part of rg
    :commands (rg-menu rg-enable-menu))

  (use-package wgrep-rg
    :ensure nil ;; part of rg
    :commands (wgrep-rg-setup)
    :hook
    (rg-mode-hook . wgrep-rg-setup))
#+end_src
* Coloring / themes / fonts
#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t
    :defer 1)

  (use-package zenburn-theme
    :ensure t
    :defer 1)

  (use-package spacemacs-theme
    :ensure t
    :defer 1)

  (use-package ample-theme
    :ensure t
    :defer 1)

  (use-package sexy-monochrome-theme
    :ensure t
    :defer 1)

  (use-package gruber-darker-theme
    :ensure t
    :defer 1)

  (use-package doom-themes
    :ensure t
    :init
    (load-theme 'doom-one t))

  (use-package face-remap
    :ensure nil
    :demand
    :init
    (defvar my/font-cycle-list nil
      "The list of fonts used by `my/font-cycle-step'")
    (defvar my/font-cycle-list--idx 0
      "The next index into `my/font-cycle-step'.
  The element at that index will be used at the next call to `my/font-cycle-step'.")
    (setq my/font-cycle-list nil)
    (setq my/font-cycle-list--idx 0)
    (defun my/font-cycle-step ()
      "Cycles to the next font defined in `my/font-cycle-list'."
      (interactive)
      (when (and (display-graphic-p) (not (null (cdr my/font-cycle-list))))
        (let ((next-font (nth my/font-cycle-list--idx my/font-cycle-list)))
          (set-face-attribute 'default nil :font next-font)
          (message "Switching font to %s." next-font)
          (setq my/font-cycle-list--idx (mod (1+ my/font-cycle-list--idx) (length my/font-cycle-list))))))
    (when (display-graphic-p)
      (let ((font-list (font-family-list)))
        (when (member "Fira Code" font-list)
          (push "Fira Code:size=12:hintstyle=hintfull:autohint=true:antialise=true:rgba=rgb" my/font-cycle-list))
        (when (member "Source Code Pro" font-list)
          (push "Source Code Pro:size=12:hintstyle=hintfull:autohint=true:antialise=true:rgba=rgb" my/font-cycle-list))
        (when (member "Hack" font-list)
          (push "Hack:size=12:hintstyle=hintfull:autohint=true:antialise=true:rgba=rgb" my/font-cycle-list))
        (when (member "Inconsolata" font-list)
          (push "Inconsolata:size=14:hintstyle=hintfull:autohint=true:antialise=true:rgba=rgb" my/font-cycle-list))
        (when (member "Victor Mono" font-list)
          (push "Victor Mono:size=12:hintstyel=hintfull:autohint=true:antialise=true:rgba=rgb" my/font-cycle-list)))
      (if (null my/font-cycle-list)
          (error "Failed to load custom fonts")
        (my/font-cycle-step)))
    (defun my/text-scale-reset ()
      (interactive)
      (text-scale-set 0))
    (set-face-background 'glyphless-char "red")
    :bind (("M-<kp-add>" . text-scale-increase)
           ("M-<kp-subtract>" . text-scale-decrease)
           ("M-<kp-multiply>" . my/font-cycle-step)
           ("M-<kp-0>" . my/text-scale-reset)))
#+end_src
* Modeline
#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :demand
    :init
    (line-number-mode 1)
    (column-number-mode 1)
    (setq-default mode-line-percent-position '(-3 "%p"))
    ;; mode-line-position-column-line-format '(" %l,%c") ; Emacs 28
    (setq-default mode-line-format
                  '("%e"
                    mode-line-front-space
                    mode-line-mule-info
                    mode-line-client
                    mode-line-modified
                    mode-line-remote
                    mode-line-frame-identification
                    mode-line-buffer-identification
                    "  "
                    mode-line-position
                    (vc-mode vc-mode)
                    "  "
                    mode-line-modes
                    " "
                    mode-line-misc-info
                    mode-line-end-spaces))
    (setq-default header-line-format mode-line-format)
    (setq-default header-line-format nil)
    (setq-default mode-line-format nil))

  (use-package telephone-line
    :ensure t
    :diminish telephone-line-mode
    :commands (telephone-line-mode)
    :init
    (setq telephone-line-height 24)
    (setq telephone-line-primary-left-separator 'telephone-line-cubed-left)
    (setq telephone-line-secondary-left-separator 'telephone-line-cubed-hollow-left)
    (setq telephone-line-primary-right-separator 'telephone-line-cubed-right)
    (setq telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-right)
    :config
    (setq telephone-line-lhs
          '((accent . (telephone-line-vc-segment
                       telephone-line-erc-modified-channels-segment
                       telephone-line-process-segment))
            (nil . (telephone-line-minor-mode-segment
                    telephone-line-buffer-segment))))
    (setq telephone-line-rhs
          '((nil . (telephone-line-flycheck-segment
                    telephone-line-misc-info-segment))
            (accent . (telephone-line-major-mode-segment))
            (nil . (telephone-line-airline-position-segment))))
    :hook
    (emacs-startup-hook . telephone-line-mode))

  (use-package keycast
    :ensure t
    :commands (keycast-mode)
    :config
    (setq keycast-separator-width 1)
    (setq keycast-mode-line-remove-tail-elements nil)
    (setq keycast-mode-line-insert-after 'mode-line-buffer-identification)
    (dolist (input '(self-insert-command
                     org-self-insert-command))
      (add-to-list 'keycast-substitute-alist `(,input "." "Typing…")))
    (dolist (event '(mouse-event-p
                     mouse-movement-p
                     mwheel-scroll))
      (add-to-list 'keycast-substitute-alist `(,event nil))))
#+end_src
* Shells
** shell
#+begin_src emacs-lisp
  (use-package shell
    :ensure nil
    :hook
    (shell-mode-hook . (lambda ()
                         (face-remap-set-base 'comint-highlight-prompt :inherit nil))))
#+end_src
** eshell
#+begin_src emacs-lisp
  (use-package eshell
    :ensure nil)

  (use-package esh-mode
    :ensure nil)

  (use-package em-hist
    :ensure nil
    :after (:all esh-mode)
    :config
    (setq-default eshell-history-file-name (expand-file-name "eshell-history" user-emacs-cache-directory))
    (setq-default eshell-hist-ignoredups t)
    (setq-default eshell-save-history-on-exit t))
#+end_src
** ansi-term
#+begin_src emacs-lisp
  (use-package term
    :ensure nil
    :config
    :bind (:map term-raw-map
                ("M-1" . nil)
                ("M-2" . nil)
                ("M-3" . nil)
                ("M-4" . nil)
                ("M-5" . nil)
                ("M-6" . nil)
                ("M-7" . nil)
                ("M-8" . nil)
                ("M-9" . nil)
                ("M-0" . nil)))
#+end_src
* TRAMP
#+begin_src emacs-lisp
  (use-package tramp
    :ensure nil
    :init
    (setq-default tramp-persistency-file-name (expand-file-name "tramp" user-emacs-cache-directory)))
#+end_src
* Project management
** projectile - Manage and navigate projects in Emacs easily
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :diminish
    :commands (projectile-mode)
    :custom
    (projectile-cache-file (expand-file-name "projectile.cache" user-emacs-cache-directory))
    (projectile-known-projects-file (expand-file-name "projectile-bookmarks.eld" user-emacs-cache-directory))
    (projectile-tags-backend 'ggtags)
    (projectile-switch-project-action 'projectile-dired)
    (projectile-ignored-projects `(,user-emacs-directory))
    :init
    (projectile-mode)
    :bind (("<escape> <escape> p" . projectile-switch-project)
           ("C-x p o" . projectile-ripgrep)
           ("C-x p O" . projectile-grep)
           ("C-x p t" . projectile-test-project)))
#+end_src
** fzf - A front-end for fzf.
#+begin_src emacs-lisp
  (use-package fzf
    :ensure t
    :after (:all projectile ggtags))
#+end_src
* Programming generic
** abbrev [built-in]
#+begin_src emacs-lisp
  (use-package abbrev
    :ensure nil
    :diminish
    :custom
    (abbrev-file-name (expand-file-name "abbrev_defs" use-emacs-directory))
    (only-global-abbrevs nil)
    :config
    (read-abbrev-file abbrev-file-name t))
#+end_src
** paren [built-in] - highlight matching paren
#+begin_src emacs-lisp
  (use-package paren
    :ensure nil
    :config
    (setq show-paren-delay 0.25)
    (setq show-paren-style 'parenthesis)
    :hook
    (prog-mode-hook . show-paren-mode))
#+end_src
** autoinsert [built-in] - auto insert text when a new file is created
#+begin_src emacs-lisp
  (use-package autoinsert
    :ensure nil
    :diminish auto-insert-mode
    :commands (auto-insert-mode define-auto-insert)
    :init
    (defun my/auto-insert-using-yasnippet (mode name)
      "Expand a yas snippet with the given NAME in MODE."
      (yas-expand-snippet
       (yas--template-content
        (yas--get-template-by-uuid mode name))))
    (setq auto-insert 'other)
    (setq auto-insert-query nil)
    (setq auto-insert-alist nil)
    (define-auto-insert '(sh-mode . "Shell script") '(lambda () (my/auto-insert-using-yasnippet 'sh-mode "new-file-template")))
    :hook
    (find-file-hook . auto-insert)
    (emacs-startup-hook . auto-insert-mode))
#+end_src
** yasnippet - A template system for Emacs
#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :diminish yas-minor-mode
    :commands (yas-minor-mode yas-reload-all yas-expand-snippet)
    :hook
    (prog-mode-hook . yas-minor-mode)
    (org-mode-hook . yas-minor-mode)
    :config
    (setq yas-snippet-dirs
          `(,(file-name-as-directory (expand-file-name "snippets" user-emacs-directory))))
    (yas-reload-all))
#+end_src
** lsp - Language Server Protocol support for Emacs
#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :commands (lsp)
    :init
    (defun my/lsp-find-definition-at-mouse (click)
      "Click to start `xref-find-definitions-at-mouse' at clicked point."
      (interactive "e")
      (call-interactively #'mouse-set-point)
      (call-interactively #'xref-find-definitions-at-mouse))
    :custom
    (lsp-keymap-prefix "s-g")
    (lsp-session-file (expand-file-name "lsp-session-v1" user-emacs-cache-directory))
    (lsp-enable-snippet nil)
    (lsp-completion-provider :none)
    :hook
    (lsp-mode-hook . company-mode)
    :bind (:map lsp-mode-map
                ("C-<down-mouse-1>" . my/lsp-find-definition-at-mouse)
                ("C-<mouse-1>" . my/lsp-find-definition-at-mouse)
                ("<wheel-left>" . xref-go-back)
                ("<wheel-right>" . xref-go-use)))

  (use-package lsp-ui
    :ensure t
    :hook
    (lsp-mode-hook . lsp-ui-mode)
    :custom
    (lsp-ui-peek-enable t)
    (lsp-ui-sideline-enable t)
    (lsp-ui-sideline-show-hover t)
    (lsp-ui-sideline-update-mode 'line)
    (lsp-ui-sideline-delay 1)
    (lsp-ui-doc-enable t)
    (lsp-ui-doc-show-with-cursor nil)
    (lsp-ui-doc-show-with-mouse nil)
    (lsp-ui-doc-position 'at-point))

  (use-package lsp-maybe
    :ensure nil
    :load-path "elisp"
    :commands (lsp-maybe lsp-maybe-add-predicate))
#+end_src
** ggtags - emacs frontend to GNU Global source code tagging system
#+begin_src emacs-lisp
  (use-package ggtags
    :ensure t
    :diminish)
#+end_src
** company - Modular text completion framework
#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :diminish
    :custom
    (company-tooltip-align-annotations t)
    (company-minimum-prefix-length 1)
    (company-show-quick-access 'left)
    (company-quick-access-modifier 'meta)
    (company-quick-access-keys '("1" "2" "3" "4" "5" "6" "7" "8" "9" "0"))
    :init
    (setq tab-always-indent 'complete)
    (defun my/wrap--company-yasnippet--candidates (orig-fun &rest args)
      "Wrapper for `company-yasnippet--candidates'.
  For some reason, the yasnippet backend also provides completion if the prefix
  is empty.  This gives yasnippet completion everytime and makes completion
  often a burden.

  A less hacky way of implementing this would be using a transformer and removing
  all yasnippet candidates if there are more than a certain threshold (using the
  `company-backend' text property), but it is useless work to compute all the
  candidates if they are later dropped."
      (if (and (stringp (car args)) (string-blank-p (car args)))
          nil
        (apply orig-fun args)))
    (defun my/company-backend-with-yas (backends)
      "Add :with company-yasnippet to company BACKENDS.
   Taken from https://github.com/syl20bnr/spacemacs/pull/179."
      (if (and (listp backends) (member 'company-yasnippet backends))
          backends
        (append (if (consp backends)
                    backends
                  (list backends))
                '(:with company-yasnippet))))
    (defun my/company-sort-yas-first (candidates)
      (sort candidates
            (lambda (c1 c2)
              (equal (get-text-property 0 'company-backend c1) 'company-yasnippet)))
      candidates)
    :config
    ;; (setq company-backends (delete 'company-dabbrev company-backends))
    ;; (setq company-backends (delete 'company-bbdb company-backends))
    ;; (setq company-backends (mapcar #'my/company-backend-with-yas company-backends))
    (setq company-backends '((company-capf :with company-yasnippet)
                             (company-dabbrev-code company-keywords company-files)
                             (company-dabbrev)))
    (setq company-transformers '(delete-consecutive-dups
                                 company-sort-by-occurrence
                                 my/company-sort-yas-first))
    (advice-add 'company-yasnippet--candidates :around #'my/wrap--company-yasnippet--candidates)
    :bind (([remap c-indent-line-or-region] . company-indent-or-complete-common)
           ([remap indent-for-tab-command] . company-indent-or-complete-common)
           :map company-active-map
           ("C-n" . company-select-next-or-abort)
           ("C-j" . company-select-next-or-abort)
           ("C-p" . company-select-previous-or-abort)
           ("C-k" . company-select-previous-or-abort)
           ("<return>" . company-complete-selection)
           ("RET" . company-complete-selection)
           ("<tab>" . company-complete-selection)
           ("TAB" . company-complete-selection)
           :map company-search-map
           ("C-n" . company-select-next-or-abort)
           ("C-j" . company-select-next-or-abort)
           ("C-p" . company-select-previous-or-abort)
           ("C-k" . company-select-previous-or-abort)))

  (use-package company-dabbrev-code
    :ensure nil ;; packaged with company
    :commands (company-dabbrev-code)
    :config
    (add-to-list 'company-dabbrev-code-modes 'sh-mode)
    ;; Change using setq-local for mode specific configurations.
    (setq company-dabbrev-code-other-buffers t)
    (setq company-dabbrev-code-everywhere t)
    (setq company-dabbrev-code-ignore-case nil))

  (use-package company-quickhelp
    :ensure t
    :custom
    (company-quickhelp-delay 1)
    (company-quickhelp-max-lines 40)
    :hook
    (company-mode-hook . company-quickhelp-mode))
#+end_src
** flycheck - On-the-fly syntax checking
#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :defer 1
    :diminish
    :commands (flycheck-mode)
    :config
    (define-fringe-bitmap 'flycheck-fringe-bitmap-one-excl
      (vector #b00000000
              #b00000000
              #b00000000
              #b00110000
              #b00110000
              #b00110000
              #b00110000
              #b00110000
              #b00110000
              #b00110000
              #b00110000
              #b00000000
              #b00110000
              #b00110000
              #b00000000
              #b00000000
              #b00000000))
    (define-fringe-bitmap 'flycheck-fringe-bitmap-two-excl
      (vector #b00000000
              #b00000000
              #b00000000
              #b01100110
              #b01100110
              #b01100110
              #b01100110
              #b01100110
              #b01100110
              #b01100110
              #b01100110
              #b00000000
              #b01100110
              #b01100110
              #b00000000
              #b00000000
              #b00000000))

    (flycheck-define-error-level 'error
      :severity 100
      :compilation-level 2
      :overlay-category 'flycheck-error-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-two-excl
      :fringe-face 'flycheck-fringe-error
      :error-list-face 'flycheck-error-list-error)
    (flycheck-define-error-level 'warning
      :severity 10
      :compilation-level 1
      :overlay-category 'flycheck-warning-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-one-excl
      :fringe-face 'flycheck-fringe-warning
      :error-list-face 'flycheck-error-list-warning)
    (flycheck-define-error-level 'info
      :severity -10
      :compilation-level 0
      :overlay-category 'flycheck-info-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-one-excl
      :fringe-face 'flycheck-fringe-info
      :error-list-face 'flycheck-error-list-info)
    :hook
    (lsp-mode-hook . flycheck-mode)
    (emacs-lisp-mode-hook . flycheck-mode))

  (use-package flycheck-pos-tip
    :ensure t
    :after (:all flycheck)
    :init
    (eval-after-load 'flycheck (flycheck-pos-tip-mode)))
#+end_src
** next-error [built-in]
#+begin_src emacs-lisp
  (use-package simple
    :ensure nil
    :demand
    :custom
    (next-error-recenter '(4))
    :config
    (which-key-add-key-based-replacements "M-g e" "next-error prefix")
    :bind (("M-g e n" . next-error)
           ("M-g e p" . previous-error)
           ("M-g e b" . next-error-select-buffer)))
#+end_src
* Programming languages
** C/C++
#+begin_src emacs-lisp
    (use-package cc-mode ;; built-in
      :ensure nil
      :init
      (defun my/c-mark-block ()
        "Put mark at end of current statement, point at beginning."
        (interactive)
        (let ((start (progn
                       (call-interactively #'backward-up-list)
                       (point)))
              (end (progn
                       (call-interactively #'forward-list)
                       (point))))
          (goto-char start)
          (push-mark end)
          (setq mark-active t)))
      (defun lsp-maybe-active-if-compile-commands-in-projectile-root ()
        "Enable `lsp' if the project root contains `compile_commands.json'.
    The project root is found using `projectile-project-root'."
        (let ((project-root (projectile-project-root)))
          (if (not project-root)
              t
            (file-exists-p (expand-file-name "compile_commands.json" project-root)))))
      :config
      (lsp-maybe-add-predicate 'c-mode #'lsp-maybe-active-if-compile-commands-in-projectile-root)
      :bind
      (:map c-mode-map
            ("M-h" . my/c-mark-block)
            ("C-M-h" . c-mark-function))
      :hook
      (c-mode-common-hook . lsp-maybe)
      (c-mode-hook . lsp-maybe)
      (c++-mode-hook . lsp-maybe))

    (defconst openjdk-cc-style
      `((c-recognize-knr-p . nil)
        (c-enable-xemacs-performance-kludge-p . t)
        (c-basic-offset . 2)
        (indent-tabs-mode . nil)
        (c-comment-only-line-offset . 0)
        (c-hanging-braces-alist . ((defun-open after)
                                   (defun-close before after)
                                   (class-open after)
                                   (class-close before after)
                                   (inexpr-class-open after)
                                   (inexpr-class-close before)
                                   (namespace-open after)
                                   (inline-open after)
                                   (inline-close before after)
                                   (block-open after)
                                   (block-close . c-snug-do-while)
                                   (extern-lang-open after)
                                   (extern-lang-close after)
                                   (statement-case-open after)
                                   (substatement-open after)))
        (c-hanging-colons-alist . ((case-label)
                                   (label after)
                                   (access-label after)
                                   (member-init-intro before)
                                   (inher-intro)))
        (c-hanging-semi&comma-criteria
         . (c-semi&comma-no-newlines-for-oneline-inliners
            c-semi&comma-inside-parenlist
            c-semi&comma-no-newlines-before-nonblanks))
        (c-indent-comments-syntactically-p . t)
        (comment-column . 40)
        (c-indent-comment-alist . ((other . (space . 2))))
        (c-cleanup-list . (brace-else-brace
                           brace-elseif-brace
                           brace-catch-brace
                           empty-defun-braces
                           defun-close-semi
                           list-close-comma
                           scope-operator))
        (c-offsets-alist . ((arglist-intro google-c-lineup-expression-plus-4)
                            (func-decl-cont . ++)
                            (member-init-intro . ++)
                            (inher-intro . ++)
                            (comment-intro . 0)
                            (arglist-close . c-lineup-arglist)
                            (topmost-intro . 0)
                            (block-open . 0)
                            (inline-open . 0)
                            (substatement-open . 0)
                            (statement-cont
                             .
                             (,(when (fboundp 'c-no-indent-after-java-annotations)
                                 'c-no-indent-after-java-annotations)
                              ,(when (fboundp 'c-lineup-assignments)
                                 'c-lineup-assignments)
                              ++))
                            (label . /)
                            (case-label . +)
                            (statement-case-open . +)
                            (statement-case-intro . +) ; case w/o {
                            (access-label . /)
                            (innamespace . 0))))
      "OpenJDK C/C++ Programming Style.")

    (c-add-style "OpenJDK" openjdk-cc-style nil)
#+end_src
** Rust
#+begin_src emacs-lisp
  (use-package rustic
    :ensure t
    :hook
    (rustic-mode-hook . lsp)
    (rustic-mode-hook . company-mode))

  (setq mouse-wheel-scroll-amount '(3 ((shift) . 1) ((control) . nil)))
  (setq mouse-wheel-progressive-speed nil)
#+end_src
** Emacs-lisp
#+begin_src emacs-lisp
  (use-package elisp-mode
    :ensure nil
    :init
    (defun my/configure-elisp-mode ()
      (setq-local indent-tabs-mode nil)
      (setq-local fill-column 80)
      (setq-local show-trailing-whitespace t))
    :hook
    (elisp-mode-hook . (lambda ()
                         (my/configure-elisp-mode)
                         (display-fill-column-indicator-mode)))
    (emacs-lisp-mode-hook . (lambda ()
                              (my/configure-elisp-mode)
                              (display-fill-column-indicator-mode))))

  (use-package pp
    :ensure nil
    :bind (([remap eval-last-sexp] . pp-eval-last-sexp)))

  (use-package eldoc
    :ensure nil
    :diminish
    :config
    (global-eldoc-mode 1))
#+end_src
** Ocaml
#+begin_src emacs-lisp
  (use-package tuareg
    :ensure t
    :init
    (add-to-list 'safe-local-variable-values '(eval projectile-project-compilation-cmd))
    :hook
    (tuareg-mode-hook . utop-minor-mode)
    (tuareg-mode-hook . lsp)
    (tuareg-mode-hook . company-mode)
    :config
    (add-hook 'tuareg-mode-hook #'electric-pair-local-mode)
    (setq auto-mode-alist
          (append '(("\\.ml[ily]?$" . tuareg-mode)
                    ("\\.topml$" . tuareg-mode))
                  auto-mode-alist)))

  ;(use-package merlin
  ;  :ensure t
  ;  :after (:all tuareg)
  ;  :config
  ;  (add-hook 'tuareg-mode-hook 'merlin-mode)
  ;  (add-hook 'merlin-mode-hook #'company-mode)
  ;  (setq merlin-error-after-save nil))

  (use-package utop
    :ensure t
    :commands (utop-minor-mode)
    :config
    (autoload 'utop-minor-mode "utop" "Minor mode for utop" t)
    (setq utop-command "opam config exec -- dune utop . -- -emacs")
    :bind ((([remap tuareg-eval-phrase] . utop-eval-phrase)
            ([remap tuareg-eval-buffer] . utop-eval-buffer)
            ([remap tuareg-eval-region] . utop-eval-region))))

  (use-package dune
    :ensure t)
#+end_src
** Common lisp
#+begin_src emacs-lisp
  (use-package sly
    :ensure t
    :commands (sly sly-mode)
    :custom
    (sly-kill-without-query-p t)
    (sly-net-coding-system 'utf-8-unix)
    (sly-complete-symbol-function #'sly-simple-completions)
    :config
    (setq inferior-lisp-program "sbcl")
    (defun sly-apropos-next-symbol ()
      "Move cursor down to the next symbol in an `sly-apropos-mode' buffer."
      (interactive nil sly-apropos-mode)
      (forward-line)
      (while (and (not (eq (get-text-property (point) 'face) 'sly-apropos-symbol))
                  (< (point) (point-max)))
        (forward-line)))
    (defun sly-apropos-previous-symbol ()
      "Move cursor back to the last symbol in an `sly-apropos-mode' buffer."
      (interactive nil sly-apropos-mode)
      (forward-line -1)
      (while (and (not (eq (get-text-property (point) 'face) 'sly-apropos-symbol))
                  (> (point) (point-min)))
        (forward-line -1)))
    :bind (:map sly-mode-map
                ("C-c C-d ." . sly-describe-symbol)
                ("C-c C-d C-." . sly-describe-symbl)
                :map sly-apropos-mode-map
                ("n" . sly-apropos-next-symbol)
                ("p" . sly-apropos-previous-symbol)
                :map sly-inspector-mode-map
                ("?" . describe-mode)
                ("SPC" . scroll-up-command)
                ("S-SPC" . scroll-down-command)
                ("DEL" . scroll-down-command)
                ("TAB" . forward-button)
                ("<backtab>" . backward-button)
                ("C-M-i" . backward-button)
                ("C-c C-c" . sly-button-inspect)
                ("r" . sly-inspector-next)
                ("l" . sly-inspector-pop)
                ("C-c C-f" . sly-inspector-next)
                ("C-c C-b" . sly-inspector-pop)
                ("<wheel-left>" . sly-inspector-pop)
                ("<wheel-right>" . sly-inspector-next)
                ("<mouse-8>" . sly-inspector-pop)
                ("<mouse-9>" . sly-inspector-next))
    :hook
    (sly-mode-hook . company-mode))
#+end_src

** Shell
The shell mode is built-in.
Flycheck can use ~shellcheck~ out of the box.
The ~company-shell~ package provides completion for CLI utilities and environment variables,
but not for variables or functions defined in the shell file.
Use ~company-dabbrev-code~ for now, until another tool is found.
#+begin_src emacs-lisp
  (use-package sh-script
    :ensure nil
    :commands (sh-mode)
    :init
    (defun my/configure-sh-mode ()
      (setq-local tab-width 4)
      (setq-local indent-tabs-mode nil)
      (setq-local fill-column 119)
      (setq-local show-trailing-whitespace t)
      (setq-local company-dabbrev-minimum-length 2)
      (setq-local company-dabbrev-code-everywhere t)
      (setq-local company-dabbrev-code-other-buffers t)
      (setq-local company-backends '((company-dabbrev-code :with company-yasnippet company-shell company-shell-env)
                                     (company-shell company-shell-env :with company-yasnippet))))
    (setq sh-basic-offset 4)
    :hook
    (sh-mode-hook . flycheck-mode)
    (sh-mode-hook . company-mode)
    (sh-mode-hook . display-fill-column-indicator-mode)
    (sh-mode-hook . my/configure-sh-mode)
    :bind (:map sh-mode-map
                ("C-c (" . nil)
                ("C-c +" . nil)
                ("C-c :" . nil)
                ("C-c C-\\" . nil)
                ("C-c TAB" . nil)
                ("C-c C-l" . nil)
                ("C-c C-r" . nil)
                ("C-c C-c" . nil)
                ("C-c C-f" . nil)
                ("C-c C-n" . nil)
                ("C-c C-o" . nil)
                ("C-c C-s" . nil)
                ("C-c C-t" . nil)
                ("C-c C-u" . nil)
                ("C-c C-w" . nil)
                ("C-c C-x" . nil)
                ("C-c C-z" . nil)))

  (use-package shell
    :ensure nil
    :commands (shell-mode)
    :config
    (setq-default sh-basic-offset 4)
    :hook
    (shell-mode-hook . (lambda () (display-line-numbers-mode 0))))

  (use-package company-shell
    :ensure t
    :init
    (setq company-shell-delete-duplicates t)
    (setq company-shell-use-help-arg nil))
#+end_src
** Python
#+begin_src emacs-lisp
  (use-package python
    :ensure nil
    :defer t
    :init
    (defun my/python-mode-hook ()
      (setq fill-column 88))
    :hook
    (python-mode-hook . my/python-mode-hook)
    (python-mode-hook . display-fill-column-indicator-mode)
    )

  (use-package elpy
    :ensure t
    :defer t
    :commands (elpy-enable elpy-config elpy-rpc-reinstall-virtualenv)
    :init
    (advice-add 'python-mode :before 'elpy-enable)
    :config
    (setq elpy-rpc-virtualenv-path 'default)
    (setq elpy-rpc-python-command "python3")
    (setq elpy-rpc-ignored-buffer-size (* 1024 1024)) ;; Some projects are nuts
    (setq elpy-modules (delq 'elpy-module-yasnippet elpy-modules)))
#+end_src
** Groovy
#+begin_src emacs-lisp
  (use-package groovy-mode
    :ensure t)
#+end_src
** jenkinsfile-mode
#+begin_src emacs-lisp
  (use-package jenkinsfile-mode
    :ensure t
    :after (:all groovy-mode))
#+end_src
* Markup languages
** Org Mode
#+begin_src emacs-lisp
  (use-package org
    :ensure nil
    :commands (org-mode)
    :config
    (setq org-directory "~/Documents/org")
    (setq org-imenu-depth 7)
    ;;
    (setq org-adapt-indentation nil)
    ;; agenda
    (setq org-agenda-files '("~/Documents/org"))
    (setq org-agenda-span 14)
    (setq org-agenda-start-on-weekday 1)
    ;; code blocks languages
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (shell . t)
       (python . t)
       (perl . t)))
    :bind (:map org-mode-map
                ("C-c a" . org-agenda)
                ("C-c ." . org-time-stamp)
                ("C-c C-." . org-time-stamp-inactive)
                :map org-src-mode-map
                ("C-c C-c" . org-edit-src-exit))
    :hook
    (org-mode-hook . abbrev-mode)
    (org-mode-hook . (lambda () (setq indent-tabs-mode nil))))

  (use-package org-superstar
    :ensure t
    :after (:all org)
    :commands (org-superstar-mode)
    :config
    (setq org-superstar-remove-leading-stars t)
    (setq org-bullets-bullet-list '("◉" "○" "✸" "✿" "☼" "⚬"))
    :hook
    (org-mode-hook . org-superstar-mode))
#+end_src
** Markdown
#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :commands (markdown-mode)
    :config
    (setq markdown-command "multimarkdown"))
#+end_src
** TOML
#+begin_src emacs-lisp
  (use-package toml-mode
    :ensure t
    :mode (("\\.toml\\'" . toml-mode))
    :commands (toml-mode))
#+end_src
** YAML
#+begin_src emacs-lisp
  (use-package yaml-mode
    :ensure t
    :mode (("\\.yml\\'" . yaml-mode)
           ("\\.yaml\\'" . yaml-mode))
    :commands (yaml-mode))
#+end_src
** JSON
#+begin_src emacs-lisp
  (use-package json-mode
    :ensure t
    :mode (("\\.json\\'" . json-mode))
    :commands (json-mode))
#+end_src
* Configuration files
** git-modes
#+begin_src emacs-lisp
  (use-package git-modes
    :ensure t
    :commands (gitattributes-mode gitconfig-mode gitignore-mode))
#+end_src
** xmodmap
#+begin_src emacs-lisp
  (use-package xmodmap-mode
    :ensure nil
    :mode (("\\.Xmodmap\\'" . xmodmap-mode))
    :commands (xmodmap-mode))
#+end_src
* Tools
** Magit - A Git Porcelain inside Emacs
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :commands (magit-status git-commit-turn-on-flyspell)
    :config
    (magit-auto-revert-mode 1)
    :hook
    (magit-mode-hook . magit-load-config-extensions)
    (git-commit-setup-hook . git-commit-turn-on-flyspell)
    :bind (:map magit-section-mode-map
                ("M-1" . nil)
                ("M-2" . nil)
                ("M-3" . nil)
                ("M-4" . nil)))

  (use-package git-commit ;; part of magit
    :ensure nil
    :config
    (setq git-commit-summary-max-length 72)
    :hook
    (git-commit-mode-hook . (lambda ()
                              (setq-local fill-column 72)
                              (display-fill-column-indicator-mode 1)))
    :bind (:map git-commit-mode-map
                ("C-c c" . with-editor-finish)
                ("C-c k" . with-editor-cancel)))

  (use-package git-modes
    :ensure t)
#+end_src
** spray - A speed reading mode for Emacs
#+begin_src emacs-lisp
  (use-package spray
    :ensure t
    :commands (spray-mode)
    :init
    (setq spray-wpm 375) ;; Words per minute
    (setq spray-height 400) ;; Height of characters
    (setq spray-margin-top 1) ;; Character margin at top of buffer
    (setq spray-margin-left 1) ;; Character margin at left of buffer
    (setq spray-ramp 3) ;; Initial words before ramping up to full speed
    :bind (("<f6>" . spray-mode)
           :map spray-mode-map
           ("SPC" . spray-start/stop)
           ("h" . spray-backward-word)
           ("<left>" . spray-backward-word)
           ("l" . spray-forward-word)
           ("<right>" . spray-forward-word)
           ("f" . spray-faster)
           ("s" . spray-slower)
           ("q" . spray-quit)
           ("RET" . spray-quit)
           ("<return>" . spray-quit)))
#+end_src
* OTHER
#+begin_src emacs-lisp
  (defun my/ref-find-definitions-at-mouse (event)
    "Find the definition of identifier at or around mouse click.
  This command is intended to be bound to a mouse event."
    (interactive "e")
    (let ((identifier
           (save-excursion
             (mouse-set-point event)
             (xref-backend-identifier-at-point (xref-find-backend)))))
      (if identifier
          (xref-find-definitions identifier)
        (user-error "No identifier here"))))

  (unless (fboundp 'xref-find-definitions-at-mouse)
    (defalias 'xref-find-definitions-at-mouse 'my/xref-find-definitions-at-mouse))

  ;;; misc stuff

  (add-hook 'term-mode-hook (lambda () (display-line-numbers-mode 0)))
#+end_src
* Postface
#+begin_src emacs-lisp
  (provide 'settings)
  ;;; settings.el ends here

#+end_src
* Using local build of Emacs
Install dependencies:
#+begin_src sh
  # pacman -Syu $(pacman -Si emacs-nativecomp |grep 'Depends On' |awk '{for(i=4;i<=NF;++i)print $i}')
#+end_src
Build with a prefix of /opt/emacs. Need to create a .desktop file in ~/.local/share/applications.
#+begin_src sh
  $ git clean -xdf
  $ git pull
  $ bash autogen.sh
  $ emacs -nw -q --batch --eval '(message "%s" system-configuration-options)' 2>&1 |xargs bash configure
  # --with-cairo --with-harfbuzz --with-modules --with-wide-int --with-x-toolkit=gtk3 --with-xft --with-sound=alsa --with-mailutils --enable-link-time-optimization --with-native-compilation --prefix=/opt/emacs 'CFLAGS=-march=native -O2 -pipe -fstack-protector-strong --param=ssp-buffer-size=4 -fno-plt' CPPFLAGS=-D_FORTIFY_SOURCE=2 LDFLAGS=-Wl,-O1,--sort-common,--as-needed,-z,relro,-z,now
  $ make NATIVE_FULL_AOT=1 -j16
  $ sudo make install
#+end_src
