#+TITLE: Emacs configuration in org-mode
#+AUTHOR: Christoph Göttschkes
#+EMAIL: just.mychris@googlemail.com
#+STARTUP: showeverything

* Configuration dependencies
To please the compiler, we need to require all the dependencies the settings have, which are not loaded using use-package, or are needed by use-package.
This is mostly use-package and local utilities which are used throught the configuration or are configured to be used interactively.
#+begin_src emacs-lisp
  ;;; settings.el --- personal configuration           -*- lexical-binding: t; -*-
  ;;; Commentary:
  ;; Generated from `settings.org' in `init.el'.
  ;;; Code:
  (eval-when-compile
    (require 'use-package))
  (require 'use-package-ligature)
  (require 'delight)
  (require 'bind-key)
  (require 'my-utils)

  (eval-and-compile
    (require 'general)
    (general-create-definer emacs-map)
    (general-create-definer evil-imap :states 'insert)
    (general-create-definer evil-emap :states 'emacs)
    (general-create-definer evil-nmap :states 'normal)
    (general-create-definer evil-vmap :states 'visual)
    (general-create-definer evil-mmap :states 'motion)
    (general-create-definer evil-omap :states 'operator)
    (general-create-definer evil-rmap :states 'replace)
    (general-create-definer evil-iemap :states '(insert emacs))
    (general-create-definer evil-nvmap :states '(normal visual))

    (general-create-definer buffer-local-leader
      :states 'normala
      :keymaps 'override
      :prefix "SPC g")
    (general-create-definer system-local-leader
      :states 'normal
      :keymaps 'override
      :prefix "SPC s")
    (general-create-definer c-x-leader
      :states 'normal
      :keymaps 'override
      :prefix "DEL"))

  (eval-and-compile
    (defvar user-emacs-cache-directory)) ;; from init.el
#+end_src
* Miscellaneous settings
** General Emacs configuration
#+begin_src emacs-lisp
  (setq
   blink-cursor-mode nil
   global-hl-line-mode t
   visible-bell t
   large-file-warning-threshold (* 100 1024 1024)
   read-process-output-max (* 1024 1024)
   initial-major-mode 'text-mode
   frame-title-format '("Emacs - "
                        (:eval (if (buffer-file-name)
                                   (abbreviate-file-name (buffer-file-name))
                                 "%b"))
                        (:eval (when (buffer-modified-p)
                                 " ↯"))))
  (defalias 'yes-or-no-p 'y-or-n-p)
  (put 'narrow-to-region 'disabled nil)
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
  (put 'overwrite-mode 'disabled t)
  (emacs-map
    "C-z" nil ;; Use C-z as a prefix key.
    "<help>" nil
    "C-h <help>" nil
    "<f1> <help>" nil
    "<find>" nil
    "<open>" nil
    "<clear>" nil
    "<f16>" nil
    "<f18>" nil
    "<f20>" nil
    "C-x C-z" nil
    "C-h g" nil ;; Who needs that?
    "<f1> g" nil
    "C-h n" nil
    "C-h C-n" nil
    "<f1> n" nil
    "<f1> C-n" nil
    "<f1> 4 i" nil
    "C-h 4 i" nil
    "M-`" nil ;; tmm-menubar
    "<f10>" nil ;; menu-bar-open
    "C-<f10>" nil ;; buffer-menu-open
    "C-x i" nil ;; insert-file
    "M-<" nil
    "M-C-{" '(beginning-of-buffer :no-autoload t)
    "M->" nil
    "M-C-}" '(end-of-buffer :no-autoload t))
  (emacs-map
    "<menu>" '(:keymap iso-transl-ctl-x-8-map))
  (emacs-map
    'iso-transl-ctl-x-8-map
    "<menu>" '(execute-extended-command :no-autoload t))
  (emacs-map
    "<up>" nil
    "C-<up>" nil
    "M-<up>" nil
    "C-M-<up>" nil
    "<down>" nil
    "C-<down>" nil
    "M-<down>" nil
    "C-M-<down>" nil
    "<left>" nil
    "C-<left>" nil
    "M-<left>" nil
    "C-M-<left>" nil
    "<right>" nil
    "<C-right>" nil
    "<M-right>" nil
    "<C-M-right>" nil)
  (c-x-leader
    "s" #'save-buffer
    "k" #'kill-buffer
    "f" #'find-file
    "b" #'switch-to-buffer)

  (setq
   initial-buffer-choice nil
   inhibit-startup-message t
   inhibit-startup-screen t
   inhibit-startup-buffer-menu t
   inhibit-x-resources t)
  ;; This is a weird one, see
  ;; https://emacshorrors.com/posts/advertising-your-freedom.html
  (fset 'display-startup-echo-area-message 'ignore)
#+end_src
** cua-base.el [built-in] - Emulate CUA key bindings
#+begin_src emacs-lisp
  (use-package cua-base
    :ensure nil
    :commands (cua-mode)
    :hook
    (emacs-startup-hook . (lambda () (cua-mode -1))))
#+end_src
** nsm.el [built-in] - Network Security Manager
#+begin_src emacs-lisp
  (use-package nsm
    :ensure nil
    :demand t
    :custom
    (nsm-settings-file (expand-file-name "network-security.data" user-emacs-cache-directory))
    (network-security-level 'high))
#+end_src
** Emacs server and desktop
#+begin_src emacs-lisp
  (use-package server
    :ensure nil
    :commands (server-start))

  (use-package desktop
    :ensure nil
    :custom
    (desktop-auto-save-timeout 300)
    (desktop-path (list (file-name-as-directory user-emacs-cache-directory)))
    (desktop-base-file-name "desktop")
    (desktop-files-not-to-save nil)
    (desktop-globals-to-clear nil)
    (desktop-load-locked-desktop t)
    (desktop-missing-file-warning nil)
    (desktop-restore-eager 0)
    (desktop-restore-frames nil)
    (desktop-save 'ask-if-new)
    :hook
    (emacs-startup-hook . (lambda () (desktop-save-mode -1))))
#+end_src
** Make sure that UTF-8 is used everywhere.
#+begin_src emacs-lisp
  (use-package mule
    :ensure nil
    :demand t
    :init
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (set-language-environment 'utf-8)
    (set-selection-coding-system 'utf-8)
    (prefer-coding-system 'utf-8)
    (set-input-method nil)
    (setq locale-coding-system 'utf-8)
    (add-to-list 'process-coding-system-alist '("python" . (utf-8 . utf-8)))
    (add-to-list 'process-coding-system-alist '("elpy" . (utf-8 . utf-8))))
#+end_src
** Savehist (minibuffer history)
#+begin_src emacs-lisp
  (use-package savehist
    :ensure nil
    :delight (savehist-mode)
    :custom
    (savehist-file (expand-file-name "savehist" user-emacs-cache-directory))
    (history-length 1000)
    (history-delete-duplicates t)
    (savehist-save-minibuffer-history t)
    :hook
    (emacs-startup-hook . savehist-mode))
#+end_src
** Saveplace (cursor position)
#+begin_src emacs-lisp
  (use-package saveplace
    :ensure nil
    :delight (save-place-mode)
    :custom
    (save-place-file (expand-file-name "saveplace" user-emacs-cache-directory))
    (save-place-forget-unreadable-files t)
    :hook
    (emacs-startup-hook . save-place-mode))
#+end_src
** Backups and auto-save
#+begin_src emacs-lisp
  (use-package files
    :ensure nil
    :demand t
    :init
    ;; backups
    (let
        ((backup-dir (file-name-as-directory (expand-file-name "backups" user-emacs-cache-directory))))
      (unless (file-exists-p backup-dir) (make-directory backup-dir t))
      (setq-default backup-directory-alist `(("." . ,backup-dir)))
      (setq-default backup-by-copying t)
      (setq-default delete-old-versions t)
      (setq-default kept-new-versions 5)
      (setq-default kept-old-versions 2)
      (setq-default create-lockfiles nil))
    ;; auto-save
    (let
        ((auto-save-dir (file-name-as-directory (expand-file-name "auto-save" user-emacs-cache-directory)))
         (auto-save-list-dir (file-name-as-directory (expand-file-name "auto-save-list" user-emacs-cache-directory))))
      (unless (file-exists-p auto-save-dir) (make-directory auto-save-dir t))
      (unless (file-exists-p auto-save-list-dir) (make-directory auto-save-list-dir t))
      (setq-default auto-save-file-name-transforms `((".*" ,auto-save-dir t)))
      (setq-default auto-save-list-file-prefix (expand-file-name "saves-" auto-save-list-dir))
      (setq-default auto-save-default t)
      (setq-default auto-save-timeout 10)
      (setq-default auto-save-interval 200)))
#+end_src
** Completion for recent files and directories
#+begin_src emacs-lisp
  (use-package recentf
    :ensure nil
    :delight (recentf-mode)
    :commands (recentf-mode
               recentf-cleanup)
    :custom
    (recentf-save-file (expand-file-name "recentf" user-emacs-cache-directory))
    (recentf-save-file-modes #o600)
    (recentf-max-saved-items 1024)
    (recentf-exclude '(;; compressed files and archives
                       "\\.tar$" "\\.tbz2$" "\\.tbz$" "\\.tgz$" 
                       "\\.bz2$" "\\.bz$" "\\.gz$" "\\.gzip$" "\\.xz$" "\\.zpaq$"
                       "\\.lz$" "\\.lrz$" "\\.lzo$" "\\.lzma$" "\\.shar$" "\\.kgb$"
                       "\\.zip$" "\\.Z$" "\\.7z$" "\\.rar$"
                       ;; TRAMP paths
                       "^/sudo:" "^/ssh:"))
    (recentf-auto-cleanup 60)
    :config
    (advice-add #'recentf-cleanup :after #'(lambda (&rest _ignored)
                                             ;; Don't show the message in the bottom of the screen
                                             (message nil)))
    :hook
    (recentf-mode-hook . (lambda ()
                           ;; run a cleanup at startup and use `recentf-auto-cleanup'
                           ;; to cleanup every now and then
                           (run-with-idle-timer 5 nil (lambda ()
                                                        (recentf-cleanup)))))
    (emacs-startup-hook . recentf-mode))
#+end_src
** Line numbers
#+begin_src emacs-lisp
  (use-package display-line-numbers
    :ensure nil
    :delight (display-line-numbers-mode)
    :commands (display-line-numbers-mode
               global-display-line-numbers-mode)
    :custom
    (display-line-numbers-type 'relative)
    (display-line-numbers-width-start t)
    (display-line-numbers-grow-only t)
    :init
    (set-face-attribute 'line-number-current-line nil :weight 'bold)
    :hook
    (prog-mode-hook . (lambda ()
                        (setq display-line-numbers-type 'visual)))
    (emacs-startup-hook . global-display-line-numbers-mode))
#+end_src
** S - The long lost Emacs string manipulation library
#+begin_src emacs-lisp
  (use-package s
    :demand t
    :ensure t)
#+end_src
** f - Modern API for working with files and directories
#+begin_src emacs-lisp
  (use-package f
    :demand t
    :ensure t)
#+end_src
** dash - A modern list API for Emacs.
#+begin_src emacs-lisp
  (use-package dash
    :demand t
    :ensure t)
#+end_src
** font-utils - Utilities for Unicode characters
#+begin_src emacs-lisp
  (use-package font-utils
    :ensure t
    :demand t
    :custom
    (font-utils-less-feedback nil)
    (font-utils-use-persistent-storage "font-utils")
    (font-utils-use-memory-cache t))
#+end_src
** ucs-utils - Utilities for Unicode characters
#+begin_src emacs-lisp
  (use-package ucs-utils
    :ensure t
    :demand t
    :custom
    (ucs-utils-trade-memory-for-speed t)
    (ucs-utils-use-persistent-storage "ucs-utils")
    (ucs-utils-hide-numbered-cjk-ideographs t))
#+end_src
** package [built-in] - Simple package system for Emacs
#+begin_src emacs-lisp
  (use-package package
    :ensure nil
    :demand t
    :custom
    (package-enable-at-startup nil) ;; Also configured in early-init.el
    (package-quickstart nil) ;; Also configured in early-init.el
    :general
    (emacs-map
      'package-menu-mode-map
      "q" '(kill-buffer-and-window :no-autoload t)))
#+end_src
** GCMH - the Garbage Collector Magic Hack
#+begin_src emacs-lisp
  (use-package gcmh
    :ensure t
    :delight (gcmh-mode)
    :commands (gcmh-mode)
    :functions (gcmh-idle-garbage-collect)
    :custom
    (gcmh-idle-delay 'auto)
    (gcmh-auto-idle-delay-factor 10)
    (gcmh-high-cons-threshold (* 16 1024 1024))
    (gcmh-verbose nil)
    :hook
    (emacs-startup-hook . gcmh-mode))
#+end_src
** utils - Personal utilities
#+begin_src emacs-lisp
  (use-package my-utils
    :ensure nil
    :demand t
    :commands (+delete-most-recent-window)
    :general
    (emacs-map
      "C-x 9" #'+delete-most-recent-window))
#+end_src
* Evil
** evil - Extensible Vi layer for Emacs.
#+begin_src emacs-lisp
  ;; `evil-collection' assumes that
  ;;   `evil-want-keybinding' is set to `t'
  ;;   `evil-want-integration' is set to `nil'
  ;; before loading `evil' and `evil-collection'
  ;; See https://github.com/emacs-evil/evil-collection#installation
  ;; With byte-code compilation turned on, it doesn't work if it is
  ;; specified in the :init or :preface section
  (eval-and-compile
    (setq evil-want-keybinding nil)
    (setq evil-want-integration t))
  (use-package evil
    :ensure t
    :custom
    (evil-echo-state nil)
    (evil-want-C-u-scroll t)
    (evil-want-C-i-jump nil)
    (evil-undo-system #'undo-tree)
    :config
    (defun +evil-set-cursor (orig-fun &rest args)
      (if (display-graphic-p)
          (apply orig-fun args)
        (let ((specs (car args)))
          (unless (equal cursor-type specs)
            (let ((shape (or (car-safe specs) specs))
                  (param))
              (setq param
                    (cond ((eq shape 'bar) "6")
                          ((eq shape 'hbar) "4")
                          (t "2")))
              (send-string-to-terminal
               (concat "\e[" param " q")))))))
    (advice-add #'evil-set-cursor :around #'+evil-set-cursor)
    (evil-select-search-module 'evil-search-module 'isearch)
    (evil-set-initial-state 'help-mode 'normal)
    :hook
    (emacs-startup-hook . evil-mode)
    (evil-mode-hook . (lambda ()
                        (evil-imap
                          'eshell-mode-map
                          "<left>" #'evil-backward-char
                          "<right>" #'evil-forward-char
                          "C-<left>" #'evil-backward-word-begin
                          "C-<right>" #'evil-forward-word-begin
                          "C-w" evil-window-map)))
    :general
    (evil-emap
      :keymaps '(gdb-breakpoints-mode-map
                 gdb-registers-mode-map
                 gdb-locals-mode-map
                 gdb-frames-mode-map)
      "C-w" '(:keymap evil-window-map)))
#+end_src
** evil-org - evil keybindings for org-mode
#+begin_src emacs-lisp
  (use-package evil-org
    :ensure (evil-org :pin melpa)
    :after (:all evil org)
    :delight (evil-org-mode)
    :hook
    (org-mode-hook . evil-org-mode))
#+end_src
** evil-collection - A set of keybindings for Evil mode
#+begin_src emacs-lisp
  (use-package evil-collection
    :ensure t
    :after (:all evil)
    :commands (evil-collection-init)
    :config
    (delete 'help evil-collection-mode-list)
    :hook
    (evil-mode-hook . evil-collection-init)
    (evil-mode-hook . (lambda ()
                        ;; delight this mode in :delight doesn't work because the file is not in the load path
                        (delight 'evil-collection-unimpaired-mode nil "evil-collection-unimpaired"))))
#+end_src
** evil-escape - Customizable key sequence to escape from insert state and everything else in Emacs.
#+begin_src emacs-lisp
  (use-package evil-escape
    :ensure t
    :after (:all evil)
    :delight (evil-escape-mode)
    :custom
    (evil-escape-key-sequence "jk")
    (evil-escape-delay 0.1)
    (evil-escape-unodered-key-sequence nil)
    :hook
    (evil-mode-hook . evil-escape-mode))
#+end_src
** evil-easymotion
#+begin_src emacs-lisp
  (use-package evil-easymotion
    :ensure t
    :after (:all evil)
    :demand t
    :functions (evilem-default-keybindings)
    :hook
    (evil-mode-hook . (lambda ()
                        (when (and (bound-and-true-p evil-mode)
                                   (fboundp 'evilem-default-keybindings))
                          (evilem-default-keybindings "C-a")))))
#+end_src
** my-evil-commands - Additional evil commands
#+begin_src emacs-lisp
  (use-package my-evil-commands
    :ensure nil
    :after (:all evil)
    :general
    (evil-nmap
      "g ;" #'+evil-goto-last-change-center
      "g ," #'+evil-goto-last-change-reverse-center)
    (evil-mmap
      "`" #'+evil-goto-mark-center
      "'" #'+evil-goto-mark-line-center
      "C-w m" '(+switch-to-minibuffer-window :no-autoload t)))
#+end_src
* Interface enhancements
** Minibuffer [built-in]
#+begin_src emacs-lisp
  (use-package minibuffer
    :ensure nil
    :custom
    (minibuffer-default-prompt-format " [...]")
    :config
    (defun +switch-to-minibuffer-window ()
      "Switch to minibuffer window (if active)."
      (interactive)
      (when (active-minibuffer-window)
        (select-frame-set-input-focus (window-frame (active-minibuffer-window)))
        (select-window (active-minibuffer-window))))

    (defun +kill-other-buffers ()
      "Kill all other buffers."
      (interactive)
      (mapc #'+kill-buffer-save (delq (current-buffer) (buffer-list))))

    ;; https://www.emacswiki.org/emacs/KillingBuffers#toc9
    (defvar kill-buffer-save-list '("*scratch*" "*Messages*")
      "A list holding buffer names which should not be killed by `kill-buffer-save'.")
    (defun +kill-buffer-save (&optional buffer-or-name)
      "Only kill buffers not in the kill-buffer-save-list."
      (interactive)
      (or buffer-or-name (setq buffer-or-name (current-buffer)))
      (if (member
           (if (bufferp buffer-or-name) (buffer-name buffer-or-name) buffer-or-name)
           kill-buffer-save-list)
          (bury-buffer buffer-or-name)
        (kill-buffer buffer-or-name)))
    (defun +focus-minibuffer-or-completion ()
      "Focus the active minibuffer or completion window.
  TODO: needs refactoring."
      (interactive)
      (let* ((mini (active-minibuffer-window))
             (completions (get-window-with-predicate
                           (lambda (window)
                             (org-string-match-p
                              "\\*\\(Completions\\|Embark Collect \\(Live\\|Completions\\)\\)"
                              (format "%s" window))))))
        (cond ((and mini (not (minibufferp)))
               (select-window mini nil))
              ((and completions (not (eq (selected-window) completions)))
               (select-window completions nil)))))
    (setq completion-styles '(basic orderless))
    (setq completion-category-defaults nil)
    (setq completion-cycle-threshold 5)
    (setq completion-ignore-case t)
    (setq completion-category-defaults nil)
    (setq completion-auto-help nil)
    (setq read-file-name-completion-ignore-case t)
    (setq read-buffer-completion-ignore-case t)
    (setq completion-ignore-case t)
    (setq enable-recursive-minibuffers t)
    :general
    (emacs-map
      :no-autoload t
      "H-f" #'+focus-minibuffer-or-completion
      "C-x k" #'+kill-buffer-save
      "C-x K" #'+kill-other-buffer
      "C-x C-o" #'+switch-to-minibuffer-window)
    (emacs-map
      'minibuffer-local-map
      :no-autoload t
      "<left>" #'left-char
      "C-<left>" #'left-word
      "<right>" #'right-char
      "C-<right>" #'right-word
      "C-<kp-7>" #'minibuffer-keyboard-quit)
    (emacs-map
      'minibuffer-local-completion-map
      "RET" #'minibuffer-force-complete-and-exit
      "<tab>" #'minibuffer-complete
      "<backtab>" #'minibuffer-force-complete
      "M-RET" #'exit-minibuffer)
    (emacs-map
      'minibuffer-local-filename-completion-map
      "RET" #'minibuffer-force-complete-and-exit))

  (use-package minibuf-eldef
    :ensure nil
    :hook
    (emacs-startup-hook . minibuffer-electric-default-mode))

  (use-package mb-depth
    :ensure nil
    :custom
    (minibuffer-depth-indicator-function (lambda (depth) (format "[%2d] " depth)))
    :hook
    (emacs-startup-hook . minibuffer-depth-indicate-mode))
#+end_src
** autorevert [built-in]
#+begin_src emacs-lisp
  (use-package autorevert
    :ensure nil
    :delight (auto-revert-mode)
    :commands (auto-revert-mode
               global-auto-revert-mode)
    :custom
    (auto-revert-verbose t)
    :hook
    (find-file-hook . auto-revert-mode))
#+end_src
** imenu [built-in] - find major definitions in a file by name
#+begin_src emacs-lisp
  (use-package imenu
    :ensure nil
    :commands (imenu)
    :hook
    (imenu-after-jump-hook . (lambda () (recenter-top-bottom))))

  (use-package imenu-list
    :ensure (imenu-list :pin melpa)
    :after (:all imenu)
    :defer t
    :commands (imenu-list
               imenu-list-minor-mode
               imenu-list-show
               imenu-list-quit-window)
    :functions (imenu-list-ret-dwim
                imenu-list-resize-window
                imenu-list-update)
    :custom
    (imenu-list-idle-update-delay 0.5)
    (imenu-list-position 'right)
    (imenu-list-buffer-name "*Ilist*")
    :init
    (defun +imenu-list-toggle ()
      "Open the imenu-list buffer."
      (interactive)
      (if (string= (buffer-name) "*Ilist*")
          (imenu-list-quit-window)
        (progn
          (imenu-list-minor-mode 1)
          (if (get-buffer "*Ilist*")
              (imenu-list-show)
            (imenu-list))
          (imenu-list-update)
          (imenu-list-resize-window)
          (enlarge-window-horizontally 2))))
    (defun +imenu-list-ret-dwim ()
      "Jump to the entry at `point' and close the imenu-list window."
      (interactive)
      (call-interactively #'imenu-list-ret-dwim)
      (kill-buffer "*Ilist*"))
    :general
    (emacs-map
      :no-autoload t
      "<f7>" #'+imenu-list-toggle)
    (emacs-map
      'imenu-list-major-mode-map
      "RET" #'imenu-list-display-dwim
      "<return>" #'imenu-list-display-dwim
      "TAB" '(hs-toggle-hiding :no-autoload t)
      "<tab>" '(hs-toggle-hiding :no-autoload t))
    :hook
    (imenu-list-major-mode-hook . (lambda () (display-line-numbers-mode 0))))
#+end_src
** vertico - VERTical Interactive COmpletion
#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :delight (vertico-mode)
    :commands (vertico-mode)
    :custom
    (vertico-scroll-margin 0)
    (vertico-count 10)
    (vertico-resize nil)
    (vertico-cycle t)
    :general
    (emacs-map
      'vertico-map
      "<right>" '(forward-char :no-autoload t)
      "<left>" '(backward-char :no-autoload t)
      "<up>" #'vertico-previous
      "<down>" #'vertico-next
      "C-<up>" '(previous-history-element :no-autoload t)
      "C-<down>" '(next-history-element :no-autoload t)
      "C-<return>" #'vertico-exit-input
      "<backspace>" #'delete-backward-char
      "C-<backspace>" #'vertico-directory-delete-word
      "C-f" '(forward-char :no-autoload t)
      "C-b" '(backward-char :no-autoload t)
      "C-p" #'vertico-previous
      "C-k" #'vertico-previous
      "C-n" #'vertico-next
      "C-j" #'vertico-next
      "<prior>" #'vertico-scroll-up
      "C-u" #'vertico-scroll-up
      "<next>" #'vertico-scroll-down
      "C-d" #'vertico-scroll-down)
    (evil-imap
      'vertico-map
      "C-p" #'vertico-previous
      "C-k" #'vertico-previous
      "C-n" #'vertico-next
      "C-j" #'vertico-next)
    :hook
    (emacs-startup-hook . vertico-mode))

  (use-package vertico-quick
    :ensure nil
    :after (:all vertico)
    :custom
    (vertico-quick1 "aoeuid")
    (vertico-quick2 "htns")
    :commands (vertico-quick-insert
               vertico-quick-exit
               vertico-quick-jump)
    :general
    (emacs-map
      'vertico-map
      "M-f" #'vertico-quick-insert
      "M-," #'vertico-quick-insert
      "M-." #'vertico-quick-exit))

  (use-package vertico-directory
    :ensure nil ;; part of vertico
    :after (:all vertico)
    :commands (vertico-directory-tidy)
    :general
    (emacs-map
      'vertico-map
      "<return>" #'vertico-directory-enter
      "<backspace>" #'vertico-directory-delete-char
      "M-<backspace>" #'vertico-directory-delete-word)
    :hook
    (rfn-eshadow-update-overlay . vertico-directory-tidy))

  (use-package vertico-multiform
    :ensure nil ;; part of vertico
    :after (:all vertico)
    :delight (vectico-multiform-mode)
    :commands (vertico-multiform-mode)
    :custom
    (vertico-multiform-commands '((consult-line buffer)
                                  (consult-imenu reverse buffer)))
    (vertico-multiform-categories '((imenu (:not indexed mouse))
                                    (symbol (vertico-sort-function . vertico-sort-alpha))))
    :hook
    (vertico-mode-hook . (lambda ()
                           (vertico-multiform-mode (if (bound-and-true-p vertico-mode) 1 -1)))))
#+end_src
** Consult - Consulting completing-read
#+begin_src emacs-lisp
  (use-package consult
    :ensure (consult :pin melpa)
    :functions (consult-completion-in-region
                consult-register-format)
    :init
    (setq-default completion-in-region-function #'(lambda (&rest args)
                                                    (apply (if vertico-mode
                                                               #'consult-completion-in-region
                                                             #'completion--in-region)
                                                           args))
                  register-preview-function #'consult-register-format)
    :custom
    (consult-line-numbers-widen t)
    (consult-async-min-input 3)
    (consult-async-input-debounce 0.5)
    (consult-async-input-throttle 0.8)
    (consult-narrow-key ">")
    :general
    (buffer-local-leader
      ":" #'consult-goto-line
      ";" #'consult-goto-line
      "l" #'consult-line
      "s" #'consult-isearch-history
      "m" #'consult-mark)
    (system-local-leader
      "y" #'consult-yank-from-kill-ring
      "g" #'consult-ripgrep
      "G" #'consult-grep
      "f" #'consult-find)
    (emacs-map
      "M-X" #'consult-mode-command
      [remap switch-to-buffer] #'consult-buffer)
    (emacs-map
      'consult-narrow-map
      "?" #'consult-narrow-help)
    (evil-nmap
      [remap bookmark-jump] '(consult-bookmark :no-autoload t)
      "g l" #'consult-goto-line)
    :hook
    (embark-collect-mode-hook . consult-preview-at-point-mode))

  (use-package consult-imenu
    :ensure nil ;; part of consult
    :general
    (buffer-local-leader
      "i" #'consult-imenu))

  (use-package consult-register
    :ensure nil ;; part of consult
    :general
    (emacs-map
      [remap jump-to-register] #'consult-register-load
      [remap point-to-register] #'consult-register-store))

  (use-package consult-lsp
    :ensure t
    :after (:all lsp consult)
    :general
    (emacs-map
      'lsp-mode-map
      "M-s S" #'consult-lsp-symbols
      "M-s s" #'consult-lsp-file-symbols))
#+end_src
** Marginalia - Enrich existing commands with completion annotations
#+begin_src emacs-lisp
  (use-package marginalia
    :ensure t
    :commands (marginalia-mode)
    :custom
    (marginalia-max-relative-age 0)
    :config
    ;; something changed in marginalia
    ;; TODO: refactor
    ;;(setq-default marginalia-annotators
    ;;              '(marginalia-annotators-heavy
    ;;                marginalia-annotators-light))
    :hook
    (emacs-startup-hook . marginalia-mode))
#+end_src
** Embark - Conveniently act on minibuffer completions
#+begin_src emacs-lisp
  (use-package embark
    :ensure t
    :custom
    (embark-quit-after-action t)
    (embark-mixed-indicator-delay 0)
    (embark-verbose-indicator-display-action '(display-buffer-at-bottom (window-height . fit-window-to-buffer)))
    :config
    ;; Show Embark actions via which-key
    ;; The following implementation is no longer supported.
    ;; See https://github.com/oantolin/embark/wiki/Additional-Configuration#use-which-key-like-a-key-menu-prompt
    ;; (setq embark-action-indicator
    ;;       (lambda (map)
    ;;        (which-key--show-keymap "Embark" map nil nil 'no-paging)
    ;;        #'which-key--hide-popup-ignore-command)
    ;;      embark-become-indicator embark-action-indicator)
    (defun +embark-collect-toggle-mark ()
      "Toggle the mark of the candidate at point in an Embark collect buffer."
      (interactive)
      (embark-collect-mark (embark-collect--marked-p)))
    :general
    (emacs-map
      "M-g a" #'embark-act
      "M-g M-a" #'embark-act)
    (emacs-map
      'embark-collect-mode-map
      "SPC" '(+embark-collect-toggle-mark :no-autoload t))
    (emacs-map
      'minibuffer-local-map
      "M-a" #'embark-act
      "M-b" #'embark-become
      "M-e" #'embark-export))

  (use-package embark-consult
    :ensure t
    :after (:all embark consult)
    :demand t)

  (use-package zed-embark
    :ensure nil
    :after (:all embark consult)
    :general
    (emacs-map
      'minibuffer-local-completion-map
      "C-n" #'zed-embark-switch-to-completion-buffer-top))
#+end_src
** Orderless - Use space-separated search terms in any order when completing with Icomplete or the default interface
#+begin_src emacs-lisp
  (use-package orderless
    :ensure t
    ;; If it is lazy loaded, a message is show in the minibuffer the
    ;; first time it is used
    :demand t
    :custom
    (completion-styles '(basic orderless))
    (completion-category-defaults nil)
    (completion-category-overrides
     '((file (styles . (basic partial-completion orderless)))
       (project-file (styles . (basic substring partial-completion orderless)))
       (imenu (styles . (basic substring orderless)))
       (kill-ring (styles . (basic substring orderless)))
       (consult-location (styles . (basic substring orderless)))))
    :config
    (defun my/orderless-literal-style-dispatcher (pattern _index _total)
      "Style dispatcher which recognizes patterns which have an \"=\" as suffix and
  dispatches those to the orderless-literal style."
      (when (string-suffix-p "=" pattern)
        `(orderless-literal . ,(substring pattern 0 -1))))
    (defun my/orderless-initialism-style-dispatcher (pattern _index _total)
      "Style dispatchter which recognizes patterns which have an \";\" as suffix and
  dispatches those to the orderless-literal style."
      (when (string-suffix-p ";" pattern)
        `(orderless-initialism . ,(substring pattern 0 -1))))
    (defun my/orderless-flex-style-dispatcher (pattern _index _total)
      "Style dispatcher which recognizes patterns which have an \",\" as suffix and
  dispatches those to the orderless-flex style."
      (when (string-suffix-p "," pattern)
        `(orderless-flex . ,(substring pattern 0 -1))))
    (setq orderless-component-separator " +")
    (setq orderless-matching-styles
          '(orderless-prefixes
            orderless-initialism
            orderless-regexp
            orderless-flex))
    (setq orderless-style-dispatchers
          '(my/orderless-literal-style-dispatcher
            my/orderless-initialism-style-dispatcher
            my/orderless-flex-style-dispatcher))
    :general
    (emacs-map
      'minibuffer-local-completion-map
      "SPC" nil
      "?" nil))
#+end_src
** perspective - switch between named "perspectives" of the editor
#+begin_src emacs-lisp
  (use-package perspective
    :disabled t
    :ensure t
    :commands (persp-mode
               persp-switch
               persp-kill
               persp-current-name)
    :custom
    (persp-show-modestring t)
    (persp-modestring-short t)
    (persp-initial-frame-name "001")
    (persp-suppress-no-prefix-key-warning t)
    :config
    (defun persp-switch-to-frame-1 ()
      (interactive)
      (persp-switch "001"))
    (defun persp-switch-to-frame-2 ()
      (interactive)
      (persp-switch "010"))
    (defun persp-switch-to-frame-3 ()
      (interactive)
      (persp-switch "011"))
    (defun persp-switch-to-frame-4 ()
      (interactive)
      (persp-switch "100"))
    (defun persp-switch-to-frame-5 ()
      (interactive)
      (persp-switch "101"))
    (defun persp-switch-to-frame-6 ()
      (interactive)
      (persp-switch "110"))
    (defun persp-switch-to-frame-7 ()
      (interactive)
      (persp-switch "111"))
    (defun persp-kill-current-frame ()
      (interactive)
      (persp-kill (persp-current-name)))
    :general
    (emacs-map
      "M-1" '(persp-switch-to-frame-1 :no-autoload t)
      "M-2" '(persp-switch-to-frame-2 :no-autoload t)
      "M-3" '(persp-switch-to-frame-3 :no-autoload t)
      "M-4" '(persp-switch-to-frame-4 :no-autoload t)
      "M-5" '(persp-switch-to-frame-5 :no-autoload t)
      "M-6" '(persp-switch-to-frame-6 :no-autoload t)
      "M-7" '(persp-switch-to-frame-7 :no-autoload t)
      "M-0" '(persp-kill-current-frame :no-autoload t))
    :hook
    (emacs-startup-hook . persp-mode))
#+end_src
** tab-bar.el [built-in] - frame-local tabs with named persistent window configurations
#+begin_src emacs-lisp
  (use-package tab-bar
    :ensure nil
    :general
    (emacs-map
      "C-x t l" #'tab-next
      "C-x t h" #'tab-previous))
#+end_src
* Help / Discovery / Cheat sheets
** help [built-in]
#+begin_src emacs-lisp
  (use-package help
    :ensure nil
    :commands (help-mode)
    :config
    (advice-add #'help-window-display-message
                :after #'(lambda (&rest _ignored)
                           ;; Don't show the message in the bottom of the screen
                           (message nil)))
    :general
    (emacs-map
      'help-mode-map
      "<mouse-8>" #'help-go-back
      "<wheel-left>" #'help-go-back
      "<mouse-9>" #'help-go-forward
      "<wheel-right>" #'help-go-forward
      "d" #'scroll-down-command
      "u" #'scroll-up-command)
    (evil-nmap
      'help-mode-map
      "d" #'evil-scroll-down
      "u" #'evil-scroll-up
      "g]" #'forward-button
      "g[" #'backward-button
      "gr" #'revert-buffer
      "<" #'help-go-back
      ">" #'help-go-forward
      "<tab>" #'forward-button
      "<backtab>" #'backward-button)
    (evil-mmap
      'help-mode-map
      "<mouse-8>" #'help-go-back
      "<wheel-left>" #'help-go-back))

  (use-package help-fns
    :ensure nil
    :commands (describe-keymap
               describe-command)
    :general
    (emacs-map
      "C-h K" #'describe-keymap))
#+end_src
** info [built-in]
#+begin_src emacs-lisp
  (use-package info
    :ensure nil
    :general
    (emacs-map
      'Info-mode-map
      "TAB" #'Info-next-reference
      "<mouse-8>" #'Info-history-back
      "<wheel-left>" #'Info-history-back
      "<mouse-9>" #'Info-history-forward
      "<wheel-right>" #'Info-history-forward)
    (evil-mmap
      'Info-mode-map
      "<return>" #'Info-follow-nearest-node
      "C-t" #'Info-history-back
      "C-o" #'Info-history-back
      "C-i" #'Info-history-forward
      "gj" #'Info-next
      "gk" #'Info-prev
      "TAB" #'Info-next-reference
      "g TAB" #'Info-next-reference
      "g]" #'Info-next-reference
      "g[" #'Info-prev-reference
      "T" #'Info-toc))
#+end_src
** man [built-in]
#+begin_src emacs-lisp
  (use-package man
    :ensure nil
    :commands (Man-next-section)
    :custom
    (Man-notify-method 'aggressive)
    :general
    (emacs-map
      'Man-mode-map
      [remap Man-next-section] #'(lambda (_n)
                                   (interactive "p" man-common)
                                   (call-interactively #'Man-next-section)
                                   (recenter))))
#+end_src
** which-key - Display available key bindings in popup
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :delight (which-key-mode)
    :commands (which-key-mode
               which-key-add-key-based-replacements
               which-key-add-major-mode-key-based-replacements
               which-key-add-keymap-based-replacements)
    :custom
    (echo-keystrokes 0)
    (which-key-idle-delay 0.4)
    (which-key-idle-secondary-delay 0)
    (which-key-max-description-length 32)
    (which-key-add-column-padding 2)
    (which-key-min-display-lines 7)
    (which-key-use-C-h-commands t)
    (which-key-show-early-on-C-h t)
    (which-key-compute-remaps t)
    :config
    (which-key-add-key-based-replacements "C-x a" "abbrev prefix")
    (which-key-add-key-based-replacements "C-x t" "tab-bar prefix")
    (which-key-add-key-based-replacements "C-x C-k" "kmacro prefix")
    (which-key-add-key-based-replacements "SPC g e" "next-error prefix")
    (which-key-add-key-based-replacements "SPC g h" "hi-lock prefix")
    (which-key-add-key-based-replacements "g ." "evil-mc prefix")
    (which-key-add-key-based-replacements "SPC c" "bookmark prefix")
    :hook
    (emacs-startup-hook . which-key-mode))

  (use-package which-key-posframe
    :if (and (window-system) (version<= "26.1" emacs-version))
    :ensure t
    :after (:all which-key)
    :delight (which-key-posframe-mode)
    :commands (which-key-posframe-mode)
    :custom
    (which-key-posframe-font nil)
    (which-key-posframe-poshandler #'+which-key-posframe-poshandler)
    (which-key-posframe-border-width 2)
    :preface
    (declare-function posframe-poshandler-frame-center "posframe")
    :config
    (defun +which-key-posframe-poshandler (info)
      (let ((centered (posframe-poshandler-frame-center info)))
        (cons (car centered) (/ (cdr centered) 2 ))))
    :hook
    (which-key-mode-hook . which-key-posframe-mode))
#+end_src
** free-keys - Show free keybindings for modkeys or prefixes
I found the ~free-keys~ documentation a bit confusing in the beginning.
If the prefix should be changed (using "p" in the buffer), do not type the prefix (don't hold C-c), but write the string into the completion buffer (type "C" "-" "c").
Same is true for the prefix argument.
Execute ~free-keys~ using C-u M-x "free-keys" and then type "C" "-" "c" into the completion buffer.
#+begin_src emacs-lisp
  (use-package free-keys
    :ensure t
    :commands (free-keys
               free-key-change-buffer
               free-key-set-prefix)
    :custom
    (free-keys-modifiers '("" "C" "M" "C-M"))
    :general
    (emacs-map
      "C-h C-k" #'free-keys)
    (emacs-map
      'free-keys-mode-map
      "q" '(kill-buffer-and-window :no-autoload t))
    (evil-nmap
      'free-keys-mode-map
      "q" '(kill-buffer-and-window :no-autoload t)
      "p" #'free-keys-set-prefix
      "b" #'free-keys-change-buffer
      "<" '(beginning-of-buffer :no-autoload t)
      ">" '(end-of-buffer :no-autoload t)))
#+end_src
** keyfreq - track command frequencies
#+begin_src emacs-lisp
  (use-package keyfreq
    :ensure t
    :commands (keyfreq-mode
               keyfreq-autosave-mode)
    :custom
    (keyfreq-buffer "*keyfreq-show*")
    (keyfreq-file (expand-file-name "keyfreq.hist" user-emacs-cache-directory))
    (keyfreq-file-lock (expand-file-name "keyfreq.hist.lock" user-emacs-cache-directory))
    :config
    (setq-default keyfreq-excluded-commands
                  '(self-insert-command
                    org-self-insert-command
                    mwheel-scroll
                    mouse-drag-region
                    mouse-set-point))
    :hook
    (emacs-startup-hook . keyfreq-mode)
    (emacs-startup-hook . keyfreq-autosave-mode))
#+end_src
** help-fns+.el - Extensions to `help-fns.el'
#+begin_src emacs-lisp
  (use-package help-fns+
    :ensure nil
    :commands (describe-buffer
               describe-option
               describe-option-of-type
               describe-file))
#+end_src
* File manager
** dired [built-in] - directory editor
#+begin_src emacs-lisp
  (use-package dired
    :ensure nil
    :defer t
    :commands (dired
               dired-other-window
               dired-other-frame
               dired-other-tab
               dired-jump
               dired-jump-other-window)
    :custom
    (dired-listing-switches "-AblGh --group-directories-first")
    :config
    (defun +dired-alternate-up-directory ()
      "In Dired, visit the parent directory via `find-alternate-file'.
  This kills the Dired buffer, then visits the parent directory."
      (interactive)
      (find-alternate-file ".."))
    (defun +dired-open ()
      "In Dired, visit the file or directory named on this line.
  If one is about to visit a directory, it is opened via `find-alternate-file'.
  This kills the Dired buffer, then visits the directory.
  Otherwise, it is opened via `find-file'."
      (interactive)
      (if (file-directory-p (dired-get-file-for-visit))
          (find-alternate-file (dired-get-file-for-visit))
        (find-file (dired-get-file-for-visit))))
    (defun +dired-mouse-find-file (event)
      (interactive "e")
      (dired-mouse-find-file event #'find-file #'find-alternate-file))
    (put 'dired-find-alternate-file 'disabled nil)
    :general
    (emacs-map
      "C-x D" #'dired-jump)
    (emacs-map
      'dired-mode-map
      "<return>" '(+dired-open :no-autoload t)
      "<up>" #'dired-previous-line
      "<down>" #'dired-next-line
      "^" '(+dired-alternate-up-directory :no-autoload t)
      "o" '(+dired-open :no-autoload t)
      "C-o" #'dired-find-file-other-window
      "C-<return>" #'dired-find-file-other-window
      "<mouse-2>" '(+dired-mouse-find-file :no-autoload t)
      "<mouse-8>" '(+dired-alternate-up-directory :no-autoload t)
      "C-<mouse-2>" #'dired-mouse-find-file-other-window
      "C-<mouse-1>" #'dired-mouse-find-file-other-window
      "C-<down-mouse-1>" #'dired-mouse-find-file-other-window))
#+end_src
** neotree - A tree plugin like NerdTree for Vim
#+begin_src emacs-lisp
  (use-package neotree
    :disabled t
    :ensure t
    :commands (neotree-toggle)
    :custom
    (neo-smart-open t)
    (neo-vc-integration '(face char))
    (neo-window-fixed-size nil)
    (neo-window-width 55)
    (neo-theme (if (display-graphic-p) 'icons 'arrow))
    :general
    (emacs-map
      "<f8>" #'neotree-toggle)
    (emacs-map
      'neotree-mode-map
      "<C-return>" #'neotree-change-root
      "d" #'neotree-delete-node
      "<delete>" #'neotree-delete-node
      "C-h" #'neotree-hidden-file-toggle
      "r" #'neotree-rename-node))
#+end_src
** treemacs - A tree style file explorer package
#+begin_src emacs-lisp
  (use-package treemacs
    :ensure t
    :commands (treemacs)
    :custom
    (treemacs-persist-file (expand-file-name "treemacs-persist" user-emacs-cache-directory))
    :general
    (emacs-map
      "<f8>" #'treemacs)
    (emacs-map
      'treemacs-mode-map
      "<up>" #'treemacs-previous-line
      "<down>" #'treemacs-next-line)
    :config
    (treemacs-follow-mode)
    :hook
    (treemacs-mode-hook . (lambda () (display-line-numbers-mode 0))))

  (use-package treemacs-projectile
    :ensure t
    :after (:all treemacs projectile))

  (use-package treemacs-magit
    :ensure t
    :after (:all treemacs magit))

  (use-package treemacs-persp
    :ensure t
    :after (:all treemacs perspective))
#+end_src
#+end_src
* Visual
** whitespace [built-in]
#+begin_src emacs-lisp
  (use-package whitespace
    :ensure nil
    :delight (whitespace-mode)
    :commands (whitespace-mode)
    :custom
    (whitespace-style '(face tab-mark newline-mark))
    (whitespace-display-mappings
     '((space-mark 32 [9251] [46])
       (space-mark 160 [164] [95])
       (tab-mark 9 [8677 9] [187 9] [92 9])
       (newline-mark 10 [8617 10] [36 10]))))
#+end_src
** hi-lock [built-in] - minor mode for interactive automatic highlighting
#+begin_src emacs-lisp
  (use-package hi-lock
    :ensure nil
    :demand t
    :delight (hi-lock-mode)
    :commands (hil-lock-mode
               global-hi-lock-mode)
    :config
    (defun +highlight-region-or-symbol (&optional face)
      "Highlight occurences of either the currently region or the symbol at point."
      (interactive
       (list (hi-lock-read-face-name)))
      (or (facep face) (setq face 'hi-yellow))
      (unless hi-lock-mode (hi-lock-mode 1))
      (let ((thing-to-highlight
             (if (use-region-p)
                 (buffer-substring (region-beginning) (region-end))
               (thing-at-point 'symbol 'no-properties))))
        (unless thing-to-highlight
          (user-error "Nothing to highlight"))
        (hi-lock-set-pattern (regexp-quote thing-to-highlight) face)))

    (defun +unhighlight-region-or-symbol ()
      "Unhighlight either the currently region or the symbol at point."
      (interactive nil hi-lock-mode)
      (let ((thing-to-highlight
             (if (use-region-p)
                 (buffer-substring (region-beginning) (region-end))
               (thing-at-point 'symbol 'no-properties))))
        (unhighlight-regexp (regexp-quote thing-to-highlight))))

    (defun +unhighlight-all ()
      "Unhighlight everything that has been previously highlighted."
      (interactive nil hi-lock-mode)
      (unhighlight-regexp t))
    :general
    (buffer-local-leader
      'hi-lock-map
      :no-autoload t
      "h i" #'hi-lock-find-patterns
      "h l" #'highlight-lines-matching-regexp
      "h p" #'highlight-phrase
      "h h" #'highlight-regexp
      "h r" #'unhighlight-regexp
      "h b" #'hi-lock-write-interactive-patterns
      "h ." #'+highlight-region-or-symbol
      "h ," #'+unhighlight-region-or-symbol
      "h U" #'+unhighlight-all
      "h q" #'+unhighlight-all)
    (emacs-map
      "C-x w i" nil
      "C-x w l" nil
      "C-x w p" nil
      "C-x w h" nil
      "C-x w ." nil
      "C-x w r" nil
      "C-x w b" nil)
    :hook
    (emacs-startup-hook . global-hi-lock-mode))
#+end_src
** highlight-thing - Minimalistic minor mode to highlight current thing under point
#+begin_src emacs-lisp
  (use-package highlight-thing
    :ensure t
    :delight (highlight-thing-mode)
    :commands (highlight-thing-mode
               global-hightlight-thing-mode)
    :custom
    (highlight-thing-delay-seconds 2)
    (highlight-thing-exclude-thing-under-point t)
    (highlight-thing-prefer-active-region t)
    :hook
    (emacs-startup-hook . global-highlight-thing-mode))
#+end_src
** undo-tree - Treat undo history as a tree
#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure (undo-tree :pin gnu-elpa-devel)
    :delight (undo-tree-mode)
    :commands (global-undo-tree-mode
               unto-tree-visualize
               unto-tree-undo)
    :custom
    (undo-tree-auto-save-history t)
    (undo-tree-history-directory-alist
     `(("." . ,(file-name-as-directory
                (expand-file-name "undo" user-emacs-cache-directory)))))
    (undo-tree-visualizer-diff t)
    (undo-tree-visualizer-timestamps t)
    :config
    (let
        ((undo-dir (file-name-as-directory
                    (expand-file-name "undo" user-emacs-cache-directory))))
      (unless (file-exists-p undo-dir) (make-directory undo-dir t)))
    :general
    (emacs-map
      'undo-tree-map
      [remap undo] #'undo-tree-undo
      [remap undo-redo] #'undo-tree-redo
      "C-x U" #'undo-tree-visualize)
    (emacs-map
      'undo-tree-visualizer-mode-map
      "C-x u" #'undo-tree-visualize-quit)
    :hook
    (emacs-startup-hook . global-undo-tree-mode)
    (evil-local-mode-hook . turn-on-undo-tree-mode))
#+end_src
* Editing
** expand-region - Increase selected region by semantic units
#+begin_src emacs-lisp
  (use-package expand-region
    :ensure t
    :commands (er/expand-region
               er/contract-region
               er/mark-symbol)
    :general
    (emacs-map
      "C-=" #'er/expand-region
      "C-+" #'er/contract-region
      "M-C-S-SPC" #'er/mark-symbol))
#+end_src
** string-inflection - underscore -> UPCASE -> CamelCase -> lowerCamelCase conversion of names
#+begin_src emacs-lisp
  (use-package string-inflection
    :ensure t
    :commands (string-inflection-all-cycle
               string-inflection-upcase
               string-inflection-java-style-cycle
               string-inflection-python-style-cycle
               string-inflection-ruby-style-cycle)
    :config
    (defun +string-inflection-cycle-auto-detection ()
      (interactive)
      (cond
       ((eq major-mode 'java-mode)
        (string-inflection-java-style-cycle))
       ((eq major-mode 'python-mode)
        (string-inflection-python-style-cycle))
       ((eq major-mode 'ruby-mode)
        (string-inflection-ruby-style-cycle))
       (t
        (string-inflection-all-cycle))))
    :general
    (emacs-map
      "M-u" #'string-inflection-upcase
      "M-l" '(+string-inflection-cycle-auto-detection :no-autoloads t)))
#+end_src
** delsel [built-in] - delete selection if you insert
#+begin_src emacs-lisp
  (use-package delsel
    :ensure nil
    :commands (delete-selection-mode)
    :hook
    (emacs-startup-hook . delete-selection-mode))
#+end_src
* Kill-ring
** System clipboard integration
#+begin_src emacs-lisp
  (use-package menu-bar
    :ensure nil
    :commands (clipboard-kill-region
               clipboard-kill-ring-save
               clipboard-yank)
    :custom
    (save-interprogram-paste-before-kill t)
    :general
    (emacs-map
      "<XF86Cut>" #'clipboard-kill-region
      "<XF86Copy>" #'clipboard-kill-ring-save
      "<XF86Paste>" #'clipboard-yank))
#+end_src
* Movement / Navigation
#+begin_src emacs-lisp
  (use-package simple
    :ensure nil
    :custom
    (scroll-error-top-bottom 'true)
    (scroll-margin 0)
    (scroll-conservatively 100000)
    (scroll-preserve-screen-position 1)
    :config
    (defun backward-kill-char-or-word ()
      "Kill characters backward.
  If the characters behind the cursor form a word
  \(possibly with ablank behind it\), `backward-kill-word'.
  If there are multiple blanks, `delete-horizontal-space',
  otherwise `backward-delete-char'"
      (interactive)
      (cond
       ((looking-back "[[:word:]][[:blank:]]?" 1)
        (backward-kill-word 1))
       ((looking-back "[[:blank:]]+" 1)
        (delete-horizontal-space t))
       (t
        (delete-char -1))))
    (defun forward-paragraph-recenter (&optional _arg)
      "Move forward to end of paragraph and center point using `recenter'.
  With argument ARG, do it ARG times; a negative argument ARG = -N means
  move backward N paragraphs."
      (interactive "^p")
      (call-interactively #'forward-paragraph)
      (recenter nil t))
    (defun backward-paragraph-recenter (&optional _arg)
      "Move backward to start of paragraph and center point using `recenter'.
  a negative argument ARG = -N means move forward N paragraphs."
      (interactive "^p")
      (call-interactively #'backward-paragraph)
      (recenter nil t))
    :general
    (emacs-map
      :no-autoload t
      "M-d" #'backward-kill-char-or-word
      [mouse-8] #'pop-tag-mark
      [C-mouse-8] #'previous-buffer
      [C-mouse-9] #'next-buffer
      "M-}" #'forward-paragraph-recenter
      "M-{" #'backward-paragraph-recenter
      "M-i" #'back-to-indentation))
#+end_src
** goto-chg - Go to last change
#+begin_src emacs-lisp
  (use-package goto-chg
    :ensure t
    :commands (goto-last-change
               goto-last-change-reverse)
    :general
    (emacs-map
      "M-s c" #'goto-last-change
      "M-s C" #'goto-last-change-reverse))
#+end_src
** disable-mouse - Disable mouse commands globally
#+begin_src emacs-lisp
  (use-package disable-mouse
    :disabled t
    :ensure t
    :delight (disable-mouse-mode)
    :commands (disable-mouse-mode
               disable-mouse-global-mode
               disable-mouse-in-keymap
               +disable-mouse-in-evil-mode)
    :config
    (defun +disable-mouse-in-evil-mode ()
      (interactive)
      (when (bound-and-true-p evil-made)
        (mapc #'disable-mouse-in-keymap
              (list evil-motion-state-map
                    evil-normal-state-map
                    evil-visual-state-map
                    evil-insert-state-map))))
    :hook
    (emacs-startup-hook . disable-mouse-global-mode)
    (evil-mode-hook . +disable-mouse-in-evil-mode))
#+end_src
** golden-ratio-scroll-screen - Scroll half screen down or up, and highlight current line
#+begin_src emacs-lisp
  (use-package golden-ratio-scroll-screen
    :ensure t
    :custom
    (golden-ratio-scroll-highlight-flag nil "Do not highlight current line before/after scroll")
    :general
    (emacs-map
      [remap scroll-down-command] #'golden-ratio-scroll-screen-down
      [remap scroll-up-command] #'golden-ratio-scroll-screen-up)
    :hook
    (golden-ratio-scroll-screen-up-hook . (lambda () (recenter)))
    (golden-ratio-scroll-screen-down-hook . (lambda () (recenter))))
#+end_src
** move-text - Move current line or region with M-up or M-down.
#+begin_src emacs-lisp
  (use-package move-text
    :ensure t
    :commands (move-text-up
               move-text-down
               move-text-line-up
               move-text-line-down
               move-text-region
               move-text-region-up
               move-text-region-down)
    :general
    (emacs-map
      "M-p" #'move-text-up
      "M-n" #'move-text-down))
#+end_src
** iy-go-to-char.el - Go to next CHAR
#+begin_src emacs-lisp
  (use-package iy-go-to-char
    :ensure nil ;; Not on melpa.
    :general
    (emacs-map
      "M-m" #'iy-go-up-to-char
      "M-M" #'iy-go-up-to-char-backward))
#+end_src
** Avy - Jump to arbitrary positions in visible text and select text quickly
#+begin_src emacs-lisp
  (use-package avy
    :ensure t
    :custom
    (avy-keys (list ?h ?t ?n ?s ?d ?u ?e ?o ?a))
    :general
    (buffer-local-leader
      "g" #'avy-goto-line
      "c" #'avy-goto-char
      "f" #'avy-goto-word-0)
    (evil-nmap
      "M-f" #'avy-goto-line))
#+end_src
** smartparens - Automatic insertion, wrapping and paredit-like navigation with user defined pairs.
#+begin_src emacs-lisp
  (use-package smartparens
    :ensure t
    :delight (smartparens-mode)
    :commands (smartparens-mode
               sp-beginning-of-sexp
               sp-end-of-sexp)
    :custom
    (sp-autoinsert-pair nil)
    (sp-escape-quotes-after-insert nil)
    :config
    (defun +sp-beginning-of-sexp (&optional ARG)
      "Like `sp-beginning-of-sexp` but a bit better.
  Falls back to `backward-sexp` if point does not move."
      (interactive "^P")
      (let ((current-point (point)))
        (sp-beginning-of-sexp ARG)
        (when (= (point) current-point)
          (backward-sexp ARG))))
    (defun +sp-end-of-sexp (&optional ARG)
      "Like `sp-beginning-of-sexp` but a bit better.
  Falls back to `forward-sexp` if point does not move."
      (interactive "^P")
      (let ((current-point (point)))
        (sp-end-of-sexp ARG)
        (when (= (point) current-point)
          (forward-sexp ARG))))
    :general
    (emacs-map
      :no-autoload t
      [remap backward-sexp] #'+sp-beginning-of-sexp
      [remap forward-sexp] #'+sp-end-of-sexp)
    :hook
    (prog-mode-hook . smartparens-mode))
#+end_src
** ace-window - Quickly switch windows
#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :commands (ace-window)
    :custom
    (aw-keys '(?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9))
    (aw-background nil)
    (aw-ignored-buffers '("*Ilist*" "*Calc Trail*" " *LV*"))
    :custom-face
    (aw-leading-char-face ((t (:inherit ace-jump-face-foreground :height 3.0))))
    :general
    (emacs-map
      [remap other-window] #'ace-window))
#+end_src
** multiple-cursors.el - Multiple cursors for Emacs.
#+begin_src emacs-lisp
  (use-package multiple-cursors
    :disabled t
    :ensure t
    :custom
    (mc/list-file (locate-user-emacs-file ".mc-lists.el"))
    (mc/max-cursors nil)
    (mc/always-run-for-all nil)
    (mc/always-repeat-command nil)
    :general
    (emacs-map
      "M-C-SPC" #'set-rectangular-region-anchor
      "C->" #'mc/mark-next-like-this
      "C-<" #'mc/mark-previous-like-this))
#+end_src
** evil-mc - Multiple cursors implementation for evil-mode
#+begin_src emacs-lisp
  (use-package evil-mc
    :ensure (evil-mc :pin melpa)
    :after (:all evil)
    :delight (evil-mc-mode)
    :commands (global-evil-mc-mode)
    :init
    ;; (setq-default evil-mc-one-cursor-show-mode-line-text nil)
    :general
    (emacs-map
      "C->" #'evil-mc-make-cursor-move-next-line
      "C-<" #'evil-mc-make-cursor-move-prev-line)
    :hook
    (evil-mode-hook . global-evil-mc-mode))
#+end_src
** view.el [built-in] - peruse file or buffer without editing
#+begin_src emacs-lisp
  (use-package view
    :ensure nil
    :commands (view-mode)
    :general
    (emacs-map
      "M-z" #'view-mode)
    (emacs-map
      'view-mode-map
      :no-autoload t
      "n" #'next-line
      "p" #'previous-line)
    (evil-nmap
      'view-mode-map
      :no-autoload t
      "d" #'View-scroll-page-forward
      "u" #'View-scroll-page-backward))
#+end_src
** link-hint - Use avy to open, copy, etc. visible links
#+begin_src emacs-lisp
  (use-package link-hint
    :ensure t
    :commands (link-hint-open-link
               link-hint-copy-link
               link-hint-copy-all-links
               link-hint-open-all-links
               link-hint-copy-link-at-point
               link-hint-open-link-at-point
               link-hint-copy-multiple-links
               link-hint-open-multiple-links)
    :custom
    (link-hint-restore t)
    :general
    (evil-nmap
      "SPC f o" #'link-hint-open-link
      "SPC f c" #'link-hint-copy-link))
#+end_src
** +link-hint - Enhancements for link-hint
#+begin_src emacs-lisp
  (use-package +link-hint
    :ensure nil
    :after (link-hint)
    :demand t
    :config
    (+link-hint-setup))
#+end_src
* Searching
** isearch [built-in]
#+begin_src emacs-lisp
  (use-package isearch
    :ensure nil
    :config
    (eval-when-compile (require 'isearch))
    (setq search-highlight t)
    (setq search-whitespace-regexp ".*?")
    (setq isearch-lax-whitespace t)
    (setq isearch-regexp-lax-whitespace nil)
    (setq isearch-lazy-count t)
    (setq isearch-lazy-highlight t)
    (eval-and-compile
      (defun +isearch-and-regex (search-input &optional _lax)
        (message search-input)
        search-input)
      (isearch-define-mode-toggle and "^" +isearch-and-regex
        "Turning on and search turns off regexp mode."))
    :general
    (emacs-map 'isearch-mode-map
      "C-g" #'isearch-cancel
      "<help>" nil
      "C-h <help>" nil
      "<f1> <help>" nil
      "M-ESC ESC" nil))
#+end_src
** replace / occur [built-in]
#+begin_src emacs-lisp
  (use-package replace
    :ensure nil
    :demand t
    :config
    (defun +occur-mode-move-beginning-of-line (arg)
      (interactive "^p")
      (or arg (setq arg 1))
      (if (/= arg 1)
          (let ((line-move-visual nil))
            (line-move (1- arg) t)))
      (let ((current-line (thing-at-point 'line t)))
        (if (string-match-p "^[[:space:]]*[0-9]+:" current-line)
            (progn
              (move-beginning-of-line 1)
              (re-search-forward "^[[:space:]]*[0-9]+:"))
          (move-beginning-of-line 1))))
    (defun +occur-mode-goto-occurrence-stay-occurrence-buffer (&optional _event)
      (interactive (list last-nonmenu-event))
      (let ((window (selected-window)))
        (call-interactively #'occur-mode-goto-occurrence)
        (select-window window)))
    :general
    (buffer-local-leader
      "&" #'query-replace
      "%" #'replace-string
      "o" #'occur
      "O" #'multi-occur)
    (emacs-map
      'occur-mode-map
      "C-a" #'+occur-mode-move-beginning-of-line
      "^" #'+occur-mode-move-beginnig-of-line
      "S-<return>" #'+occur-mode-goto-occurrence-stay-occurrence-buffer)
    (emacs-map
      'occur-mode-map
      :no-autoload t
      "q" #'kill-buffer-and-window
      "<up>" #'previous-line
      "<down>" #'next-line
      "j" #'next-line
      "k" #'previous-line
      [remap next-line] #'next-error-no-select
      [remap previous-line] #'previous-error-no-select)
    (emacs-map
      'occur-edit-mode-map
      "C-a" #'+occur-mode-move-beginning-of-line))
#+end_src
** grep [built-in]
#+begin_src emacs-lisp
  (use-package grep
    :ensure nil
    :commands (grep
               grep-mode
               grep-process-setup
               grep-compute-defaulst
               find-grep
               grep-find
               lgrep
               rgrep
               zrgrep
               rzgrep)
    :general
    (emacs-map
      'grep-mode-map
      "e" #'wgrep-change-to-wgrep-mod
      "q" '(kill-buffer-and-window :no-autoload t)))
#+end_src
** wgrep - Writable grep buffer and apply the changes to files
#+begin_src emacs-lisp
  (use-package wgrep
    :ensure t
    :commands (wgrep-setup
               wgrep-change-to-wgrep-mode)
    :general
    (emacs-map
      'grep-mode-map
      "C-c '" #'wgrep-change-to-wgrep-mode)
    (emacs-map
      'wgrep-mode-map
      "C-x C-s" nil
      "C-c c" #'wgrep-finish-edit
      "C-c k" #'wgrep-abort-changes
      "C-c r" #'wgrep-remove-change
      "C-c u" #'wgrep-remove-all-change)
    :hook
    (rg-mode-hook . wgrep-rg-setup))
#+end_src
** rg - A search tool based on ripgrep
#+begin_src emacs-lisp
  (use-package rg
    :ensure t
    :commands (rg
               rg-project
               rg-literal
               rg-dwim
               rg-dwim-project-dir
               rg-dwim-current-dir
               rg-dwim-current-file)
    :custom
    (rg-command-line-flags nil)
    (rg-buffer-name "ripgrep")
    (rg-ignore-ripgreprc t)
    :general
    (emacs-map
      'rg-mode-map
      :no-autoload t
      "C-c '" #'wgrep-change-to-wgrep-mode
      "q" #'kill-buffer-and-window))

  (use-package rg-menu
    :ensure nil ;; part of rg
    :commands (rg-menu rg-enable-menu))

  (use-package wgrep-rg
    :ensure nil ;; part of rg
    :commands (wgrep-rg-setup))
#+end_src
* Coloring / themes / fonts
#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t)

  (use-package zenburn-theme
    :ensure t)

  (use-package spacemacs-common
    :ensure (spacemacs-theme :pin melpa-stable))

  (use-package solarized-theme
    :ensure (solarized-theme :pin melpa-stable))

  (use-package ample-theme
    :ensure t)

  (use-package sexy-monochrome-theme
    :ensure t)

  (use-package gruber-darker-theme
    :ensure t)

  (use-package doom-themes
    :ensure t)

  (use-package gruvbox-theme
    :ensure t)

  (use-package custom
    :ensure nil
    :commands (switch-theme
               load-theme
               enable-theme)
    :config
    (defun switch-theme (theme)
      (interactive
       (list
        (intern (completing-read "Switch custom theme: "
                                 (mapcar #'symbol-name
                                         (custom-available-themes))))))
      (unless (custom-theme-name-valid-p theme)
        (error "Invalid theme name `%s'" theme))
      (unless (eq theme (car custom-enabled-themes))
        (mapc #'disable-theme custom-enabled-themes)
        (if (custom-theme-p theme)
            (enable-theme theme)
          (load-theme theme :no-confirm))))
    :hook
    (emacs-startup-hook . (lambda ()
                            (if (or (display-graphic-p)
                                    ;; daemon running on GNU/Linux with X
                                    (and (eq system-type 'gnu/linux) (daemonp) (getenv "DISPLAY")))
                                (switch-theme 'gruvbox-dark-soft)
                              (switch-theme 'gruvbox-dark-soft)))))

  (use-package ligature
    :ensure t
    :commands (ligature-mode
               global-ligature-mode
               ligature-set-ligatures)
    :config
    (ligature-set-ligatures 'c-mode '("==" "!=" "<=" ">=" ">>" "<<" "||" "&&" "++" "--" "->" "//"
                                      ("0" (rx (and "x" (+ (in "A-F" "a-f" "0-9")))))))
    (ligature-set-ligatures 'c++-mode '("==" "!=" "<=" ">=" "<=>" ">>" "<<" "||" "&&" "++" "--" "->" "//"
                                        ("0" (rx (and "x" (+ (in "A-F" "a-f" "0-9")))))))
    :hook
    (emacs-startup-hook . global-ligature-mode))

  (use-package face-remap
    :ensure nil
    :demand t
    :init
    ;;;; Monospace font cycling and initial setup
    (defvar +font-cycle-list nil
      "The list of fonts used by `+font-cycle-step'")
    (defvar +font-cycle-list--idx 0
      "The next index into `+font-cycle-step'.
  The element at that index will be used at the next call to `+font-cycle-step'.")
    (setq +font-cycle-list nil)
    (setq +font-cycle-list--idx 0)
    (defun +font-cycle-step ()
      "Cycles to the next font defined in `+font-cycle-list'."
      (interactive)
      (when (and (display-graphic-p) (not (null (cdr +font-cycle-list))))
        (let ((next-font (nth +font-cycle-list--idx +font-cycle-list)))
          (set-face-attribute 'default nil :font next-font)
          (message "Switching font to %s." next-font)
          (setq +font-cycle-list--idx (mod (1+ +font-cycle-list--idx) (length +font-cycle-list))))))
    (defun +text-scale-reset ()
      (interactive)
      (text-scale-set 0))
    (defun +initialize-fonts ()
      (unless +font-cycle-list
        (when (font-utils-exists-p "Source Code Pro")
          (push "Source Code Pro:size=14:hintstyle=hintfull:autohint=true:antialise=true:rgba=rgb" +font-cycle-list))
        (when (font-utils-exists-p "Hack")
          (push "Hack:size=14:hintstyle=hintfull:autohint=true:antialise=true:rgba=rgb" +font-cycle-list))
        (when (font-utils-exists-p "Inconsolata")
          (push "Inconsolata:size=14:hintstyle=hintfull:autohint=true:antialise=true:rgba=rgb" +font-cycle-list))
        (when (font-utils-exists-p "Victor Mono")
          (push "Victor Mono:size=14:hintstyel=hintfull:autohint=true:antialise=true:rgba=rgb" +font-cycle-list))
        (when (font-utils-exists-p "Fira Code")
          (push "Fira Code:size=14:hintstyle=hintfull:autohint=true:antialise=true:rgba=rgb" +font-cycle-list))
        (unless +font-cycle-list
          (warn "settings.el: Failed to load custom fonts"))
        (+font-cycle-step)))
    (cond
     ((display-graphic-p)
      (add-hook 'emacs-startup-hook #'+initialize-fonts))
     ((and (eq system-type 'gnu/linux) (daemonp) (getenv "DISPLAY"))
      ;; daemon running on GNU/Linux with X
      (add-hook 'server-after-make-frame-hook #'(lambda () (when window-system (+initialize-fonts))))))
    (set-face-background 'glyphless-char "red")
    :general
    (emacs-map
      "M-<kp-add>" #'text-scale-increase
      "M-<kp-subtract>" #'text-scale-decrease
      "M-<kp-multiply>" #'+font-cycle-step
      "M-<kp-0>" #'+text-scale-reset))
#+end_src
* Modeline
#+begin_src emacs-lisp
  (use-package simple
    :ensure nil
    :init
    (setq-default mode-line-percent-position '(-3 "%p"))
    ;; mode-line-position-column-line-format '(" %l,%c") ; Emacs 28
    (setq-default mode-line-format
                  '("%e"
                    mode-line-front-space
                    mode-line-mule-info
                    mode-line-client
                    mode-line-modified
                    mode-line-remote
                    mode-line-frame-identification
                    mode-line-buffer-identification
                    "  "
                    mode-line-position
                    (vc-mode vc-mode)
                    "  "
                    mode-line-modes
                    " "
                    mode-line-misc-info
                    mode-line-end-spaces))
    :hook
    (emacs-startup-hook . line-number-mode)
    (emacs-startup-hook . column-number-mode))

  (use-package telephone-line
    :ensure (telephone-line :pin melpa)
    :delight (telephone-line-mode)
    :custom
    (telephone-line-height 24)
    (telephone-line-primary-left-separator 'telephone-line-cubed-left)
    (telephone-line-secondary-left-separator 'telephone-line-cubed-hollow-left)
    (telephone-line-primary-right-separator 'telephone-line-cubed-right)
    (telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-right)
    :config
    (setq-default
     telephone-line-lhs '((accent . (telephone-line-vc-segment
                                     telephone-line-erc-modified-channels-segment
                                     telephone-line-process-segment))
                          (evil . (telephone-line-evil-tag-segment))
                          (nil . (telephone-line-minor-mode-segment
                                  telephone-line-buffer-segment)))
     telephone-line-rhs '((nil . (telephone-line-flycheck-segment
                                  telephone-line-misc-info-segment
                                  telephone-line-projectile-segment))
                          (accent . (telephone-line-major-mode-segment))
                          (nil . (telephone-line-airline-position-segment))))
    :hook
    (emacs-startup-hook . telephone-line-mode))

  (use-package keycast
    :ensure t
    :commands (keycast-mode)
    :config
    (setq keycast-mode-line-remove-tail-elements nil)
    (setq keycast-mode-line-insert-after 'mode-line-buffer-identification)
    (dolist (input '(self-insert-command
                     org-self-insert-command))
      (add-to-list 'keycast-substitute-alist `(,input "." "Typing…")))
    (dolist (event '(mouse-event-p
                     mouse-movement-p
                     mwheel-scroll))
      (add-to-list 'keycast-substitute-alist `(,event "." "Mouse…"))))
#+end_src
* Shells
** shell [built-in] - specialized comint.el for running the shell
#+begin_src emacs-lisp
  (use-package shell
    :ensure nil
    :commands (shell
               shell-mode)
    :hook
    (shell-mode-hook . (lambda ()
                         (display-line-numbers-mode 0)
                         (face-remap-set-base 'comint-highlight-prompt :inherit nil))))
#+end_src
** eshell [built-in] - the Emacs command shell
#+begin_src emacs-lisp
  (use-package eshell
    :ensure nil
    :preface
    (defvar +eshell-frame-shell-alist nil)
    :config
    ;; These hooks are used for emacsclient which open an eshell in the server.
    ;; Every eshell is associated with its frame.  If a frame is deleted, all
    ;; eshells which have been created by this frame are killed as well.
    (add-hook 'eshell-mode-hook #'(lambda ()
                                    (let ((frame (selected-frame))
                                          (buffer (current-buffer)))
                                      (setf (alist-get frame +eshell-frame-shell-alist)
                                            (append (list buffer) (alist-get frame +eshell-frame-shell-alist))))))
    (add-to-list 'delete-frame-functions
                 #'(lambda (frame)
                     (let ((buffers (assoc frame +eshell-frame-shell-alist)))
                       (while buffers
                         (when (buffer-live-p (car buffers))
                           (kill-buffer (car buffers)))
                         (setq buffers (cdr buffers)))))))

  (use-package esh-mode
    :ensure nil
    :preface
    (defvar-local +eshell-last-directory-cache nil)
    :commands (esh-mode)
    :hook
    (eshell-post-command-hook . (lambda ()
                                  (when (or (null +eshell-last-directory-cache)
                                            (not (string= +eshell-last-directory-cache default-directory)))
                                    (eval-and-compile
                                      (require 'vc-git)
                                      (require 'vc-hg))
                                    (cond
                                     ((vc-git-root default-directory)
                                      (vc-mode-line default-directory 'Git))
                                     ((vc-hg-root default-directory)
                                      (vc-mode-line default-directory 'Hg))
                                     (t
                                      (setq vc-mode nil)))))))

  (use-package em-hist
    :ensure nil
    :after (:all esh-mode)
    :config
    (setq-default eshell-history-file-name (expand-file-name "eshell-history" user-emacs-cache-directory))
    (setq-default eshell-hist-ignoredups t)
    (setq-default eshell-save-history-on-exit t))

  (use-package eshell-cmds
    :ensure nil
    :after (:all esh-mode)
    :demand t)
#+end_src
** term [built-in] - general command interpreter in a window stuff
#+begin_src emacs-lisp
  (use-package term
    :ensure nil
    :config
    (defun +kill-term-process-sentinel ()
      (let* ((buff (current-buffer))
             (proc (get-buffer-process buff)))
        (set-process-sentinel
         proc
         `(lambda (process event)
            (when (string= event "finished\n")
              (kill-buffer ,buff))))))
    :hook
    (term-mode-hook . (lambda () (display-line-numbers-mode 0)))
    (term-exec-hook . +kill-term-process-sentinel)
    :general
    (evil-imap
      'term-raw-map
      "<delete>" #'term-send-del)
    (emacs-map
      'term-raw-map
      "M-1" nil
      "M-2" nil
      "M-3" nil
      "M-4" nil
      "M-5" nil
      "M-6" nil
      "M-7" nil
      "M-8" nil
      "M-9" nil
      "M-0" nil))
#+end_src
* TRAMP
#+begin_src emacs-lisp
  (use-package tramp
    :ensure nil
    :custom
    (tramp-persistency-file-name (expand-file-name "tramp" user-emacs-cache-directory)))
#+end_src
* Project management
** projectile - Manage and navigate projects in Emacs easily
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :delight (projectile-mode)
    :commands (projectile-mode)
    :custom
    (projectile-cache-file (expand-file-name "projectile.cache" user-emacs-cache-directory))
    (projectile-known-projects-file (expand-file-name "projectile-bookmarks.eld" user-emacs-cache-directory))
    (projectile-tags-backend 'ggtags)
    (projectile-switch-project-action 'projectile-dired)
    (projectile-ignored-projects `(,user-emacs-directory))
    :general
    (emacs-map
      "<escape> <escape> p" #'projectile-switch-project
      "M-s p" #'projectile-switch-project
      "C-x p o" #'projectile-ripgrep
      "C-x p O" #'projectile-grep
      "C-x p t" #'projectile-test-project)
    :hook
    (emacs-startup-hook . projectile-mode))
#+end_src
** fzf - A front-end for fzf.
#+begin_src emacs-lisp
  (use-package fzf
    :ensure t
    :after (:all projectile ggtags))
#+end_src
** bookmark [built-in] - Set bookmarks, maybe annotate them, jump to them later
#+begin_src emacs-lisp
  (use-package bookmark
    :ensure nil
    :commands (bookmark-maybe-load-default-file
               bookmark-load
               bookmark-jump
               bookmark-set
               bookmark-set-no-overwrite
               bookmark-save
               bookmark-bmenu-list)
    :custom
    (bookmark-save-flag 5)
    (bookmark-default-file (expand-file-name "bookmarks.eld" user-emacs-directory))
    (bookmark-sort-flag t)
    (bookmark-fringe-mark nil)
    :general
    (emacs-map
      'bookmark-map
      "m" #'bookmark-set-no-overwrite
      "M" #'bookmark-set
      "L" #'bookmark-bmenu-list)
    (evil-nmap
      "SPC c" '(:keymap bookmark-map)))
#+end_src
* Programming generic
** abbrev [built-in] - abbrev mode commands for Emacs
#+begin_src emacs-lisp
  (use-package abbrev
    :ensure nil
    :delight (abbrev-mode)
    :commands (abbrev-mode
               edit-abbrevs-mode
               read-abbrev-file
               quietly-read-abbrev-file
               write-abbrev-file
               expand-abbrev
               unexpand-abbrev
               abbrev-insert
               insert-abbrevs
               list-abbrevs
               define-abbrevs
               edit-abbrevs
               edit-abbrevs-redefine
               add-global-abbrev
               add-mode-abbrev
               inverse-add-global-abbrev
               inversa-add-mode-abbrev
               insert-abbrev-table-description
               abbrev-suggest-show-report)
    :custom
    (abbrev-file-name (expand-file-name "abbrev_defs" user-emacs-directory))
    (only-global-abbrevs nil "Enable mode-specific abbrevs")
    (abbrev-all-caps nil)
    (abbrev-suggest nil "Do not suggest using an abbrev in the echo area")
    :hook
    ((org-mode-hook . abbrev-mode)))
#+end_src
** paren [built-in] - highlight matching paren
#+begin_src emacs-lisp
  (use-package paren
    :ensure nil
    :custom
    (show-paren-delay 0.25)
    (show-paren-style 'parenthesis)
    :hook
    (prog-mode-hook . show-paren-mode))
#+end_src
** autoinsert [built-in] - auto insert text when a new file is created
#+begin_src emacs-lisp
  (use-package autoinsert
    :ensure nil
    :delight (auto-insert-mode)
    :commands (auto-insert-mode)
    :custom
    (auto-insert 'other)
    (auto-insert-query nil)
    (auto-insert-alist nil)
    :init
    (defun +auto-insert-using-yasnippet (mode name)
      "Expand a yas snippet with the given NAME in MODE."
      (eval-and-compile '(require yasnippet))
      (yas-expand-snippet
       (yas--template-content
        (yas--get-template-by-uuid mode name))))
    :config
    (define-auto-insert '(sh-mode . "Shell script") '(lambda () (+auto-insert-using-yasnippet 'sh-mode "new-file-template")))
    (define-auto-insert '(emacs-lisp-mode . "Emacs Lisp") '(lambda () (+auto-insert-using-yasnippet 'emacs-lisp-mode "new-file-template")))
    :hook
    (find-file-hook . auto-insert))
#+end_src
** treesit [built-in] - tree-sitter utilities
#+begin_src emacs-lisp
  (use-package treesit
    :ensure nil
    :demand t
    :if (file-directory-p
         (file-name-as-directory
          (expand-file-name "dist" (expand-file-name "tree-sitter-module" user-emacs-directory))))
    :custom
    (treesit-extra-load-path
     (list (file-name-as-directory
            (expand-file-name "dist" (expand-file-name "tree-sitter-module" user-emacs-directory))))))
#+end_src
** xref [built-in] - Cross-referencing commands
#+begin_src emacs-lisp
  (use-package xref
    :ensure nil
    :config
    (defun +ref-find-definitions-at-mouse (event)
      "Find the definition of identifier at or around mouse click.
  This command is intended to be bound to a mouse event."
      (interactive "e")
      (let ((identifier
             (save-excursion
               (mouse-set-point event)
               (xref-backend-identifier-at-point (xref-find-backend)))))
        (if identifier
            (xref-find-definitions identifier)
          (user-error "No identifier here"))))

    (unless (fboundp 'xref-find-definitions-at-mouse)
      (defalias 'xref-find-definitions-at-mouse '+xref-find-definitions-at-mouse)))
#+end_src
** yasnippet - A template system for Emacs
#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :commands (yas-minor-mode
               yas-reload-all
               yas-expand-snippet)
    :custom
    (yas-snippet-dirs
     `(,(file-name-as-directory (expand-file-name "snippets" user-emacs-directory))))
    (yas-indent-line 'auto)
    (yas-also-auto-indent-first-line t)
    (yas-also-indent-empty-lines nil)
    (yas-wrap-around-region t)
    :init
    (setq yas-alias-to-yas/prefix-p nil)
    :config
    (yas-reload-all)
    (defun +yas--find-next-field-expand-abbrev-advice (&rest args)
      "Advice which should run before `yas--find-next-field' to expand abbrevs"
      (expand-abbrev))
    (advice-add 'yas--find-next-field :before #'+yas--find-next-field-expand-abbrev-advice)
    :hook
    (prog-mode-hook . yas-minor-mode)
    (org-mode-hook . yas-minor-mode))
#+end_src
** lsp - Language Server Protocol support for Emacs
#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :commands (lsp)
    :custom
    (lsp-keymap-prefix "s-g")
    (lsp-session-file (expand-file-name "lsp-session-v1" user-emacs-cache-directory))
    (lsp-enable-snippet nil)
    (lsp-completion-provider :none)
    :config
    (defun +lsp-find-definition-at-mouse (_click)
      "Click to start `xref-find-definitions-at-mouse' at clicked point."
      (interactive "e")
      (call-interactively #'mouse-set-point)
      (call-interactively #'xref-find-definitions-at-mouse))
    :general
    (emacs-map
      'lsp-mode-map
      "C-<down-mouse-1>" #'+lsp-find-definition-at-mouse
      "C-<mouse-1>" #'+lsp-find-definition-at-mouse
      "<wheel-left>" #'xref-go-back
      "<wheel-right>" #'xref-go-use)
    :hook
    (lsp-mode-hook . company-mode))

  (use-package lsp-ui
    :ensure t
    :custom
    (lsp-ui-peek-enable t)
    (lsp-ui-sideline-enable t)
    (lsp-ui-sideline-show-hover t)
    (lsp-ui-sideline-update-mode 'line)
    (lsp-ui-sideline-delay 1)
    (lsp-ui-doc-enable t)
    (lsp-ui-doc-show-with-cursor nil)
    (lsp-ui-doc-show-with-mouse nil)
    (lsp-ui-doc-position 'at-point))

  (use-package lsp-maybe
    :ensure nil
    :commands (lsp-maybe lsp-maybe-add-predicate))
#+end_src
** ggtags - emacs frontend to GNU Global source code tagging system
#+begin_src emacs-lisp
  (use-package ggtags
    :ensure t
    :delight (ggtags-mode))
#+end_src
** company - Modular text completion framework
#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :custom
    (company-tooltip-align-annotations t)
    (company-minimum-prefix-length 1)
    (company-show-quick-access 'left)
    (company-quick-access-modifier 'meta)
    (company-quick-access-keys '("1" "2" "3" "4" "5" "6" "7" "8" "9" "0"))
    :init
    (setq tab-always-indent 'complete)
    (defun my/wrap--company-yasnippet--candidates (orig-fun &rest args)
      "Wrapper for `company-yasnippet--candidates'.
  For some reason, the yasnippet backend also provides completion if the prefix
  is empty.  This gives yasnippet completion everytime and makes completion
  often a burden.

  A less hacky way of implementing this would be using a transformer and removing
  all yasnippet candidates if there are more than a certain threshold (using the
  `company-backend' text property), but it is useless work to compute all the
  candidates if they are later dropped."
      (if (and (stringp (car args)) (string-blank-p (car args)))
          nil
        (apply orig-fun args)))
    (defun my/company-backend-with-yas (backends)
      "Add :with company-yasnippet to company BACKENDS.
   Taken from https://github.com/syl20bnr/spacemacs/pull/179."
      (if (and (listp backends) (member 'company-yasnippet backends))
          backends
        (append (if (consp backends)
                    backends
                  (list backends))
                '(:with company-yasnippet))))
    (defun my/company-sort-yas-first (candidates)
      (sort candidates
            (lambda (c1 _c2)
              (equal (get-text-property 0 'company-backend c1) 'company-yasnippet)))
      candidates)
    :config
    ;; (setq company-backends (delete 'company-dabbrev company-backends))
    ;; (setq company-backends (delete 'company-bbdb company-backends))
    ;; (setq company-backends (mapcar #'my/company-backend-with-yas company-backends))
    (setq company-backends '((company-capf :with company-yasnippet)
                             (company-dabbrev-code company-keywords company-files)
                             (company-dabbrev)))
    (setq company-transformers '(delete-consecutive-dups
                                 company-sort-by-occurrence
                                 my/company-sort-yas-first))
    (advice-add 'company-yasnippet--candidates :around #'my/wrap--company-yasnippet--candidates)
    :general
    (emacs-map
      [remap c-indent-line-or-region] #'company-indent-or-complete-common
      [remap indent-for-tab-command] #'company-indent-or-complete-common)
    (emacs-map
      'company-active-map
      "C-n" #'company-select-next-or-abort
      "C-j" #'company-select-next-or-abort
      "C-p" #'company-select-previous-or-abort
      "C-k" #'company-select-previous-or-abort
      "<return>" nil
      "RET" nil
      "<tab>" #'company-complete-selection
      "TAB" #'company-complete-selection)
    (emacs-map
      'company-search-map
      "C-n" #'company-select-next-or-abort
      "C-j" #'company-select-next-or-abort
      "C-p" #'company-select-previous-or-abort
      "C-k" #'company-select-previous-or-abort))

  (use-package company-dabbrev-code
    :ensure nil ;; packaged with company
    :commands (company-dabbrev-code)
    :config
    (add-to-list 'company-dabbrev-code-modes 'sh-mode)
    ;; Change using setq-local for mode specific configurations.
    (setq company-dabbrev-code-other-buffers t)
    (setq company-dabbrev-code-everywhere t)
    (setq company-dabbrev-code-ignore-case nil))

  (use-package company-quickhelp
    :ensure t
    :commands (company-quickhelp-mode
               +company-quickhelp-mode-toggle)
    :custom
    (company-quickhelp-delay 1)
    (company-quickhelp-max-lines 40)
    :config
    (defun +company-quickhelp-mode-toggle ()
      "Enable/Disable the `company-quickhelp-mode' dependent on the status of the
  `company-mode'."
      (interactive)
      (company-quickhelp-mode (if (bound-and-true-p company-mode) 1 -1)))
    :hook
    (company-mode-hook . +company-quickhelp-mode-toggle))
#+end_src
** flycheck - On-the-fly syntax checking
#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :delight (flycheck-mode)
    :commands (flycheck-mode)
    :functions (flycheck-define-error-level)
    :config
    (define-fringe-bitmap 'flycheck-fringe-bitmap-one-excl
      (vector #b00000000
              #b00000000
              #b00000000
              #b00110000
              #b00110000
              #b00110000
              #b00110000
              #b00110000
              #b00110000
              #b00110000
              #b00110000
              #b00000000
              #b00110000
              #b00110000
              #b00000000
              #b00000000
              #b00000000))
    (define-fringe-bitmap 'flycheck-fringe-bitmap-two-excl
      (vector #b00000000
              #b00000000
              #b00000000
              #b01100110
              #b01100110
              #b01100110
              #b01100110
              #b01100110
              #b01100110
              #b01100110
              #b01100110
              #b00000000
              #b01100110
              #b01100110
              #b00000000
              #b00000000
              #b00000000))

    (flycheck-define-error-level 'error
      :severity 100
      :compilation-level 2
      :overlay-category 'flycheck-error-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-two-excl
      :fringe-face 'flycheck-fringe-error
      :error-list-face 'flycheck-error-list-error)
    (flycheck-define-error-level 'warning
      :severity 10
      :compilation-level 1
      :overlay-category 'flycheck-warning-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-one-excl
      :fringe-face 'flycheck-fringe-warning
      :error-list-face 'flycheck-error-list-warning)
    (flycheck-define-error-level 'info
      :severity -10
      :compilation-level 0
      :overlay-category 'flycheck-info-overlay
      :fringe-bitmap 'flycheck-fringe-bitmap-one-excl
      :fringe-face 'flycheck-fringe-info
      :error-list-face 'flycheck-error-list-info)
    :hook
    (lsp-mode-hook . flycheck-mode)
    (org-src-mode-hook . (lambda ()
                           (setq-local flycheck-disabled-checkers
                                       '(emacs-lisp-checkdoc)))))

  (use-package flycheck-popup-tip
    :ensure t
    :after (:all flycheck)
    :commands (flycheck-popup-tip-mode
               +flycheck-popup-tip-mode-toggle)
    :custom
    (flycheck-popup-tip-error-prefix "\u27a4 ")
    :config
    (defun +flycheck-popup-tip-mode-toggle ()
      "Enable/Disable `flycheck-popup-tip-mode' dependent on the status of the
  `flycheck-mode'."
      (interactive)
      (flycheck-popup-tip-mode (if (bound-and-true-p flycheck-mode) 1 -1)))
    :hook
    (flycheck-mode-hook . +flycheck-popup-tip-mode-toggle))
#+end_src
** next-error [built-in]
#+begin_src emacs-lisp
  (use-package simple
    :ensure nil
    :demand t
    :custom
    (next-error-recenter '(4))
    :general
    (buffer-local-leader
      "e n" #'next-error
      "e p" #'previous-error
      "e b" #'next-error-select-buffer))
#+end_src
** gdb-mi [built-in] - User Interface for running GDB
#+begin_src emacs-lisp
  (use-package gdb-mi
    :ensure nil)
#+end_src
* Programming languages
** C/C++
#+begin_src emacs-lisp
  (use-package cc-mode ;; built-in
    :ensure nil
    :config
    (defun my/c-mark-block ()
      "Put mark at end of current statement, point at beginning."
      (interactive)
      (let ((start (progn
                     (call-interactively #'backward-up-list)
                     (point)))
            (end (progn
                   (call-interactively #'forward-list)
                   (point))))
        (goto-char start)
        (push-mark end)
        (setq mark-active t)))
    (defun lsp-maybe-active-if-compile-commands-in-projectile-root ()
      "Enable `lsp' if the project root contains `compile_commands.json'.
  The project root is found using `projectile-project-root'."
      (let ((project-root (projectile-project-root)))
        (if (not project-root)
            t
          (file-exists-p (expand-file-name "compile_commands.json" project-root)))))
    (defun +c-mode-setup ()
      (lsp-maybe)
      (display-fill-column-indicator-mode) 
      (setq-local indent-tabs-mode nil))
    (lsp-maybe-add-predicate 'c-mode #'lsp-maybe-active-if-compile-commands-in-projectile-root)
    :general
    (emacs-map
      'c-mode-map
      "M-h" #'my/c-mark-block
      "C-M-h" #'c-mark-function)
    :hook
    (c-mode-common-hook . +c-mode-setup)
    (c-mode-hook . +c-mode-setup)
    (c++-mode-hook . +c-mode-setup))

  (defconst openjdk-cc-style
    `((c-recognize-knr-p . nil)
      (c-enable-xemacs-performance-kludge-p . t)
      (c-basic-offset . 2)
      (indent-tabs-mode . nil)
      (c-comment-only-line-offset . 0)
      (c-hanging-braces-alist . ((defun-open after)
                                 (defun-close before after)
                                 (class-open after)
                                 (class-close before after)
                                 (inexpr-class-open after)
                                 (inexpr-class-close before)
                                 (namespace-open after)
                                 (inline-open after)
                                 (inline-close before after)
                                 (block-open after)
                                 (block-close . c-snug-do-while)
                                 (extern-lang-open after)
                                 (extern-lang-close after)
                                 (statement-case-open after)
                                 (substatement-open after)))
      (c-hanging-colons-alist . ((case-label)
                                 (label after)
                                 (access-label after)
                                 (member-init-intro before)
                                 (inher-intro)))
      (c-hanging-semi&comma-criteria
       . (c-semi&comma-no-newlines-for-oneline-inliners
          c-semi&comma-inside-parenlist
          c-semi&comma-no-newlines-before-nonblanks))
      (c-indent-comments-syntactically-p . t)
      (comment-column . 40)
      (c-indent-comment-alist . ((other . (space . 2))))
      (c-cleanup-list . (brace-else-brace
                         brace-elseif-brace
                         brace-catch-brace
                         empty-defun-braces
                         defun-close-semi
                         list-close-comma
                         scope-operator))
      (c-offsets-alist . ((arglist-intro google-c-lineup-expression-plus-4)
                          (func-decl-cont . ++)
                          (member-init-intro . ++)
                          (inher-intro . ++)
                          (comment-intro . 0)
                          (arglist-close . c-lineup-arglist)
                          (topmost-intro . 0)
                          (block-open . 0)
                          (inline-open . 0)
                          (substatement-open . 0)
                          (statement-cont
                           .
                           (,(when (fboundp 'c-no-indent-after-java-annotations)
                               'c-no-indent-after-java-annotations)
                            ,(when (fboundp 'c-lineup-assignments)
                               'c-lineup-assignments)
                            ++))
                          (label . /)
                          (case-label . +)
                          (statement-case-open . +)
                          (statement-case-intro . +) ; case w/o {
                          (access-label . /)
                          (innamespace . 0))))
    "OpenJDK C/C++ Programming Style.")

  (c-add-style "OpenJDK" openjdk-cc-style nil)
#+end_src
** Rust
#+begin_src emacs-lisp
  (use-package rustic
    :ensure t
    :hook
    (rustic-mode-hook . lsp)
    (rustic-mode-hook . company-mode))

  (setq mouse-wheel-scroll-amount '(3 ((shift) . 1) ((control) . nil)))
  (setq mouse-wheel-progressive-speed nil)
#+end_src
** Emacs-lisp
#+begin_src emacs-lisp
  (use-package elisp-mode
    :ensure nil
    :commands (emacs-lisp-mode)
    :config
    (defun +emacs-lisp-mode-setup ()
      (setq-local indent-tabs-mode t)
      (setq-local fill-column 80)
      (setq-local show-trailing-whitespace t)
      (display-fill-column-indicator-mode 1)
      (flycheck-mode 1)
      (company-mode 1))
    :hook
    (emacs-lisp-mode-hook . +emacs-lisp-mode-setup))

  (use-package pp
    :ensure nil
    :general
    (emacs-map
      [remap eval-last-sexp] #'pp-eval-last-sexp))

  (use-package eldoc
    :ensure nil
    :delight (eldoc-mode)
    :hook
    (emacs-lisp-mode-hook . global-eldoc-mode))
#+end_src
** Ocaml
#+begin_src emacs-lisp
  (use-package tuareg
    :ensure t
    :init
    (add-to-list 'safe-local-variable-values '(eval projectile-project-compilation-cmd))
    :config
    (add-hook 'tuareg-mode-hook #'electric-pair-local-mode)
    (setq auto-mode-alist
          (append '(("\\.ml[ily]?$" . tuareg-mode)
                    ("\\.topml$" . tuareg-mode))
                  auto-mode-alist))
    :hook
    (tuareg-mode-hook . utop-minor-mode)
    (tuareg-mode-hook . lsp)
    (tuareg-mode-hook . company-mode))

  (use-package utop
    :ensure t
    :commands (utop-minor-mode)
    :config
    (autoload 'utop-minor-mode "utop" "Minor mode for utop" t)
    (setq utop-command "opam config exec -- dune utop . -- -emacs")
    :general
    (emacs-map
      [remap tuareg-eval-phrase] #'utop-eval-phrase
      [remap tuareg-eval-buffer] #'utop-eval-buffer
      [remap tuareg-eval-region] #'utop-eval-region))

  (use-package dune
    :ensure t)
#+end_src
** Common lisp
#+begin_src emacs-lisp
  (use-package sly
    :ensure t
    :commands (sly sly-mode)
    :custom
    (sly-kill-without-query-p t)
    (sly-net-coding-system 'utf-8-unix)
    (sly-complete-symbol-function #'sly-simple-completions)
    :config
    (setq inferior-lisp-program "sbcl")
    (defun sly-apropos-next-symbol ()
      "Move cursor down to the next symbol in an `sly-apropos-mode' buffer."
      (interactive nil sly-apropos-mode)
      (forward-line)
      (while (and (not (eq (get-text-property (point) 'face) 'sly-apropos-symbol))
                  (< (point) (point-max)))
        (forward-line)))
    (defun sly-apropos-previous-symbol ()
      "Move cursor back to the last symbol in an `sly-apropos-mode' buffer."
      (interactive nil sly-apropos-mode)
      (forward-line -1)
      (while (and (not (eq (get-text-property (point) 'face) 'sly-apropos-symbol))
                  (> (point) (point-min)))
        (forward-line -1)))
    :general
    (emacs-map 'sly-mode-map
      "C-c C-d ." #'sly-describe-symbol
      "C-c C-d C-." #'sly-describe-symbl)
    (emacs-map 'sly-apropos-mode-map
      "n" #'sly-apropos-next-symbol
      "p" #'sly-apropos-previous-symbol)
    (emacs-map 'sly-inspector-mode-map
      "?" #'describe-mode
      "SPC" #'scroll-up-command
      "S-SPC" #'scroll-down-command
      "DEL" #'scroll-down-command
      "TAB" #'forward-button
      "<backtab>" #'backward-button
      "C-M-i" #'backward-button
      "C-c C-c" #'sly-button-inspect
      "r" #'sly-inspector-next
      "l" #'sly-inspector-pop
      "C-c C-f" #'sly-inspector-next
      "C-c C-b" #'sly-inspector-pop
      "<wheel-left>" #'sly-inspector-pop
      "<wheel-right>" #'sly-inspector-next
      "<mouse-8>" #'sly-inspector-pop
      "<mouse-9>" #'sly-inspector-next)
    (evil-imap 'sly-mrepl-mode-map
      "<up>" #'sly-mrepl-previous-input-or-button
      "<down>" #'sly-mrepl-next-input-or-button)
    :hook
    (sly-mode-hook . company-mode))
#+end_src

** Shell
The shell mode is built-in.
Flycheck can use ~shellcheck~ out of the box.
The ~company-shell~ package provides completion for CLI utilities and environment variables,
but not for variables or functions defined in the shell file.
Use ~company-dabbrev-code~ for now, until another tool is found.
#+begin_src emacs-lisp
  (use-package sh-script
    :ensure nil
    :commands (sh-mode)
    :init
    (defun +sh-mode-setup ()
      (setq-local tab-width 4)
      (setq-local indent-tabs-mode nil)
      (setq-local fill-column 132)
      (setq-local show-trailing-whitespace t)
      (setq-local company-dabbrev-minimum-length 2)
      (setq-local company-dabbrev-code-everywhere t)
      (setq-local company-dabbrev-code-other-buffers t)
      (setq-local company-backends '((company-dabbrev-code :with company-yasnippet company-shell company-shell-env)
                                     (company-shell company-shell-env :with company-yasnippet))))
    (setq sh-basic-offset 4)
    :general
    (emacs-map'sh-mode-map
     "C-c (" nil
     "C-c +" nil
     "C-c :" nil
     "C-c C-\\" nil
     "C-c TAB" nil
     "C-c C-l" nil
     "C-c C-r" nil
     "C-c C-c" nil
     "C-c C-f" nil
     "C-c C-n" nil
     "C-c C-o" nil
     "C-c C-s" nil
     "C-c C-t" nil
     "C-c C-u" nil
     "C-c C-w" nil
     "C-c C-x" nil
     "C-c C-z" nil)
    :hook
    (sh-mode-hook . flycheck-mode)
    (sh-mode-hook . company-mode)
    (sh-mode-hook . display-fill-column-indicator-mode)
    (sh-mode-hook . +sh-mode-setup))

  (use-package company-shell
    :ensure t
    :init
    (setq company-shell-delete-duplicates t)
    (setq company-shell-use-help-arg nil))
#+end_src
** Python
#+begin_src emacs-lisp
  (use-package python
    :ensure nil
    :defer t
    :init
    (defun +python-mode-setup ()
      (setq-local fill-column 80))
    :hook
    (python-mode-hook . +python-mode-setup)
    (python-mode-hook . display-fill-column-indicator-mode))

  (use-package elpy
    :ensure t
    :defer t
    :commands (elpy-enable elpy-config elpy-rpc-reinstall-virtualenv)
    :init
    (advice-add 'python-mode :before 'elpy-enable)
    :config
    (setq elpy-rpc-virtualenv-path 'default)
    (setq elpy-rpc-python-command "python3")
    (setq elpy-rpc-ignored-buffer-size (* 1024 1024)) ;; Some projects are nuts
    (setq elpy-modules (delq 'elpy-module-yasnippet elpy-modules)))
#+end_src
** Groovy
#+begin_src emacs-lisp
  (use-package groovy-mode
    :ensure t)
#+end_src
** FASM
#+begin_src emacs-lisp
  (use-package fasm-mode
    :ensure nil
    :mode (("\\.ASM\\'" . fasm-mode))
    :commands (fasm-mode)
    :config
    (defun +fasm-mode-setup ()
      (setq-local fasm-basic-offset 8)
      (setq-local tab-width 8)
      (setq-local indent-tabs-mode t)
      (setq-local fill-column 88))
    :hook
    (fasm-mode-hook . +fasm-mode-setup))
#+end_src
** jenkinsfile-mode
#+begin_src emacs-lisp
  (use-package jenkinsfile-mode
    :ensure t
    :after (:all groovy-mode))
#+end_src
** make-mode [built-in]
#+begin_src emacs-lisp
  (use-package make-mode
    :ensure nil
    :commands (makefile-mode)
    :functions (+makefile-mode-setup)
    :config
    (defun +makefile-join-line (&optional arg beg end)
      "Join this line to previous in a makefile specific way.
  With prefix ARG, join the current line to the following line.
  When BEG and END are non-nil, join all lines in the region they
  define.  Interactively, BEG and END are, respectively, the start
  and end of the region if it is active, else nil.  (The region is
  ignored if prefix ARG is given.)"
      (interactive
       (progn (barf-if-buffer-read-only)
              (cons current-prefix-arg
                    (and (use-region-p)
                         (list (region-beginning) (region-end))))))
      ;; Consistently deactivate mark even when no text is changed.
      (setq deactivate-mark t)
      (if (and beg (not arg))
          ;; Region is active.  Go to END, but only if region spans
          ;; multiple lines.
          (and (goto-char beg)
               (> end (line-end-position))
               (goto-char end))
        ;; Region is inactive.  Set a loop sentinel
        ;; (subtracting 1 in order to compare less than BOB).
        (setq beg (1- (line-beginning-position (and arg 2))))
        (when arg (forward-line)))
      (let ((prefix (and (> (length fill-prefix) 0)
                         (regexp-quote fill-prefix))))
        (while (and (> (line-beginning-position) beg)
                    (forward-line 0)
                    (= (preceding-char) ?\n))
          (delete-char -1)
          ;; If the appended line started with the fill prefix,
          ;; delete the prefix.
          (if (and prefix (looking-at prefix))
              (replace-match "" t t))
          ;; Additional fixes for makefile specific line joining.
          (cond
           ;; If two .PHONY: targets are joined, remove the target and make it
           ;; a single one
           ((and (looking-at "\\.PHONY:")
                 (string-prefix-p ".PHONY:" (buffer-substring-no-properties
                                             (line-beginning-position)
                                             (line-end-position))))
            (delete-char 7))
           ;; If lines have been splitted, remove the backslash of the end of
           ;; the previous line
           ((looking-back "\\\\" 1)
            (delete-char -1))
           ;; If two comment lines have been joined, remove the pound symbol
           ((and (nth 4 (syntax-ppss))
                 (looking-at "#"))
            (delete-char 1)))
          (fixup-whitespace))))
    (defun +makefile-mode-setup ()
      (setq-local tab-width 8)
      (setq-local indent-tabs-mode t)
      (setq-local fill-column 132)
      (setq-local show-trailing-whitespace t)
      (setq-local makefile-space 'trailing-whitespace)
      (display-fill-column-indicator-mode 1))
    (with-eval-after-load 'evil
      (evil-define-operator +evil-makefile-join (beg end)
        "Join the selected lines in a makefile specific way."
        :motion evil-line
        (let ((count (count-lines beg end)))
          (when (> count 1)
            (setq count (1- count)))
          (goto-char beg)
          (dotimes (_ count)
            (+makefile-join-line 1))))
      :general
      (evil-nmap
        'makefile-mode-map
        "J" #'+evil-makefile-join))
    :hook
    (makefile-mode-hook . +makefile-mode-setup))
#+end_src
* Markup languages
** Org Mode
#+begin_src emacs-lisp
  (use-package org
    :ensure nil
    :commands (org-mode)
    :custom
    (org-directory "~/Documents/org")
    (org-imenu-depth 7)
    (org-adapt-indentation nil)
    (org-agenda-files '("~/Documents/org"))
    (org-agenda-span 14)
    (org-agenda-start-on-weekday 1)
    :config
    ;; code blocks languages
    (org-babel-do-load-languages
     'org-babel-load-languages '((emacs-lisp . t)
                                 (shell . t)
                                 (python . t)
                                 (perl . t)))
    :general
    (emacs-map
      'org-mode-map
      "C-c a" #'org-agenda
      "C-c ." #'org-time-stamp
      "C-c C-." #'org-time-stamp-inactive)
    (emacs-map
      'org-src-mode-map
      "C-c C-c" #'org-edit-src-exit)
    :hook
    (org-mode-hook . (lambda () (setq indent-tabs-mode nil))))

  (use-package org-src
    :ensure nil
    :after (:all org)
    :commands (org-src-mode)
    :general
    (emacs-map
      'org-src-mode-map
      "C-c s" #'org-edit-src-save
      "C-c c" #'org-edit-src-exit
      "C-c k" #'org-edit-src-abort))

  (use-package org-superstar
    :ensure t
    :after (:all org)
    :delight (org-superstar-mode)
    :commands (org-superstar-mode)
    :custom
    (org-superstar-remove-leading-stars t)
    (org-superstar-headline-bullets-list  '("◉" "○" "✸" "✿" "☼" "⚬"))
    :hook
    (org-mode-hook . org-superstar-mode))
#+end_src
** Markdown
#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :commands (markdown-mode)
    :custom
    (markdown-command "multimarkdown"))
#+end_src
** TOML
#+begin_src emacs-lisp
  (use-package toml-mode
    :ensure t
    :mode (("\\.toml\\'" . toml-mode))
    :commands (toml-mode))
#+end_src
** YAML
#+begin_src emacs-lisp
  (use-package yaml-mode
    :ensure t
    :mode (("\\.yml\\'" . yaml-mode)
           ("\\.yaml\\'" . yaml-mode))
    :commands (yaml-mode))
#+end_src
** JSON
#+begin_src emacs-lisp
  (use-package json-mode
    :ensure t
    :mode (("\\.json\\'" . json-mode))
    :commands (json-mode))
#+end_src
* Configuration files
** git-modes
#+begin_src emacs-lisp
  (use-package git-modes
    :ensure t
    :commands (gitattributes-mode gitconfig-mode gitignore-mode))
#+end_src
** xmodmap
#+begin_src emacs-lisp
  (use-package xmodmap-mode
    :ensure nil
    :mode (("\\.Xmodmap\\'" . xmodmap-mode))
    :commands (xmodmap-mode))
#+end_src
** i3wm-config
#+begin_src emacs-lisp
  (use-package i3wm-config-mode
    :ensure t
    :commands (i3wm-config-mode))
#+end_src
* Tools
** Magit - A Git Porcelain inside Emacs
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :commands (magit-status
               magit-commit
               magit-load-config-extensions
               magit-auto-revert-mode
               git-commit-turn-on-flyspell
               magit-process-git)
    :functions (magit-restore-window-configuration
                magit-mode-get-buffers)
    :config
    (defun +kill-magit-buffers ()
      "Kill all magit buffers and restore the window configuration."
      (interactive)
      (magit-restore-window-configuration)
      (mapc #'kill-buffer (magit-mode-get-buffers)))
    :general
    (c-x-leader
      "g" #'magit-status)
    (emacs-map 'magit-status-mode-map
      "q" #'+kill-magit-buffers)
    (emacs-map 'magit-section-mode-map
      "M-1" nil
      "M-2" nil
      "M-3" nil
      "M-4" nil)
    :hook
    (magit-mode-hook . magit-load-config-extensions)
    (emacs-startup-hook . magit-auto-revert-mode))

  (use-package git-commit ;; part of magit
    :ensure nil
    :custom
    (git-commit-summary-max-length 72)
    :general
    (emacs-map 'git-commit-mode-map
      "C-c c" #'with-editor-finish
      "C-c k" #'with-editor-cancel)
    :hook
    (git-commit-setup-hook . (lambda ()
                               (setq-local fill-column 72)
                               (display-fill-column-indicator-mode 1)
                               (git-commit-turn-on-flyspell)
                               (when (fboundp 'evil-insert-state)
                                 (evil-insert-state)))))

  (use-package git-rebase ;; part of magit
    :ensure nil
    :general
    (emacs-map
      'git-rebase-mode-map
      "C-k" #'git-rebase-move-line-up
      "C-j" #'git-rebase-move-line-down))
#+end_src
** spray - A speed reading mode for Emacs
#+begin_src emacs-lisp
  (use-package spray
    :ensure t
    :commands (spray-mode)
    :custom
    (spray-wpm 375 "Words per minute")
    (spray-height 400 "Height of characters")
    (spray-margin-top 1 "Character margin at top of buffer")
    (spray-margin-left 1 "Character margin at left of buffer")
    (spray-ramp 3 "Initial words before ramping up to full speed")
    :general
    (emacs-map
      "<f6>" #'spray-mode)
    (emacs-map
      'spray-mode-map
      "SPC" #'spray-start/stop
      "h" #'spray-backward-word
      "<left>" #'spray-backward-word
      "l" #'spray-forward-word
      "<right>" #'spray-forward-word
      "f" #'spray-faster
      "s" #'spray-slower
      "q" #'spray-quit
      "RET" #'spray-quit
      "<return>" #'spray-quit))
#+end_src
** system-packages - functions to manage system packages
#+begin_src emacs-lisp
  (use-package system-packages
    :ensure t)
#+end_src
* Directory-local variables
#+begin_src emacs-lisp
  (dir-locals-set-class-variables
   'work-projects
   '((c-mode . ((fill-column . 80)
                (c-file-style . "linux")
                (indent-tabs-mode . t)
                (c-basic-offset . 8)))))
  (dir-locals-set-directory-class
   "/loc" 'work-projects)
#+end_src
* Postface
#+begin_src emacs-lisp
  (provide 'settings)

  ;; Local Variables:
  ;; indent-tabs-mode: nil
  ;; End:

  ;;; settings.el ends here
#+end_src
* Using local build of Emacs
Install dependencies:
#+begin_src sh
  # pacman -Syu $(pacman -Si emacs-nativecomp |grep 'Depends On' |awk '{for(i=4;i<=NF;++i)print $i}')
#+end_src
Build with a prefix of /opt/emacs. Need to create a .desktop file in ~/.local/share/applications.
#+begin_src sh
  $ git clean -xdf
  $ git pull
  $ bash autogen.sh
  $ emacs -nw -q --batch --eval '(message "%s" system-configuration-options)' 2>&1 |xargs bash configure
  # --with-cairo --with-harfbuzz --with-modules --with-x-toolkit=gtk3 --with-xft --with-sound=alsa --with-imagemagick --with-json --with-mailutils --with-tree-sitter --with-small-ja-dic --without-compress-install --with-native-compilation=aot --prefix=/opt/emacs 'CFLAGS=-mtune=native -march=native -O2 -g3 -pipe -fomit-frame-pointer --param=ssp-buffer-size=4 -fno-plt' CPPFLAGS=-D_FORTIFY_SOURCE=2 LDFLAGS=-Wl,--sort-common,--as-needed,-z,relro,-z,now
  $ make NATIVE_FULL_AOT=1 -j16
  $ sudo make install
#+end_src
